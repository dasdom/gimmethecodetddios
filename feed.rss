<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>GimmeTheCode: TDD iOS</title><description>A description of GimmeTheCodeTddIos</description><link>https://your-website-url.com</link><language>en</language><lastBuildDate>Tue, 20 Oct 2020 22:43:00 +0200</lastBuildDate><pubDate>Tue, 20 Oct 2020 22:43:00 +0200</pubDate><ttl>250</ttl><atom:link href="https://your-website-url.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://your-website-url.com/networking/chapter098</guid><title>Mocking and Stubbing an Upload Task with URLSession</title><description>Test wheather the method `loadUser` fetches data and calls completion closure.</description><link>https://your-website-url.com/networking/chapter098</link><pubDate>Fri, 16 Oct 2020 01:38:00 +0200</pubDate><content:encoded><![CDATA[<h1>Mocking and Stubbing an Upload Task with URLSession</h1><p>Test wheather the method <code>loadUser</code> fetches data and calls completion closure</p><h2>Step 0: Prerequisites</h2><p>Possibility to inject the url session as a dependency (see <strong>Dependency Injection</strong>)</p><h2>Step 0: Protocol</h2><pre><code><span class="keyword">protocol</span> DDHURLSessionProtocol {
  
  <span class="keyword">func</span> uploadTask(with request: <span class="type">URLRequest</span>, from bodyData: <span class="type">Data</span>?, completionHandler: <span class="keyword">@escaping</span> (<span class="type">Data</span>?, <span class="type">URLResponse</span>?, <span class="type">Error</span>?) -&gt; <span class="type">Void</span>) -&gt; <span class="type">URLSessionUploadTask</span>
}

<span class="keyword">extension</span> <span class="type">URLSession</span>: <span class="type">DDHURLSessionProtocol</span> {}
</code></pre><h2>Step 1.1: URLSession Stub</h2><pre><code><span class="keyword">class</span> StubURLSession: <span class="type">DDHURLSessionProtocol</span> {
  
  <span class="keyword">private var</span> urlRequest: <span class="type">URLRequest</span>?
  <span class="keyword">private var</span> uploadData: <span class="type">Data</span>?
  <span class="keyword">private let</span> uploadTask: <span class="type">StubURLSessionUploadTask</span>
  
  <span class="keyword">init</span>(data: <span class="type">Data</span>?, urlResponse: <span class="type">URLResponse</span>?, error: <span class="type">Error</span>?, testCase: <span class="type">XCTestCase</span>) {
    
    uploadTask = <span class="type">StubURLSessionUploadTask</span>(data: data, urlResponse: urlResponse, error: error, testCase: testCase)
  }
  
  <span class="keyword">func</span> waitForAsync() {
    uploadTask.<span class="property">testCase</span>.<span class="call">waitForExpectations</span>(timeout: <span class="number">5</span>)
  }
  
  <span class="keyword">var</span> lastURLRequest: <span class="type">URLRequest</span>? {
    uploadTask.<span class="property">testCase</span>.<span class="call">waitForExpectations</span>(timeout: <span class="number">5</span>)
    
    <span class="keyword">return</span> urlRequest
  }
  
  <span class="keyword">func</span> uploadTask(with request: <span class="type">URLRequest</span>, from bodyData: <span class="type">Data</span>?, completionHandler: <span class="keyword">@escaping</span> (<span class="type">Data</span>?, <span class="type">URLResponse</span>?, <span class="type">Error</span>?) -&gt; <span class="type">Void</span>) -&gt; <span class="type">URLSessionUploadTask</span> {
    
    <span class="keyword">self</span>.<span class="property">urlRequest</span> = request
    uploadTask.<span class="property">completionHandler</span> = completionHandler
    <span class="keyword">return</span> uploadTask
  }
}
</code></pre><h2>Step 1.2: URLSessionUploadTask Stub</h2><pre><code><span class="keyword">class</span> StubURLSessionUploadTask: <span class="type">URLSessionUploadTask</span> {
  
  <span class="keyword">private let</span> data: <span class="type">Data</span>?
  <span class="keyword">private let</span> urlResponse: <span class="type">URLResponse</span>?
  <span class="keyword">private let</span> responseError: <span class="type">Error</span>?
  <span class="keyword">let</span> testCase: <span class="type">XCTestCase</span>
  <span class="keyword">private let</span> expectation: <span class="type">XCTestExpectation</span>
  
  <span class="keyword">typealias</span> CompletionHandler = (<span class="type">Data</span>?, <span class="type">URLResponse</span>?, <span class="type">Error</span>?) -&gt; <span class="type">Void</span>
  <span class="keyword">var</span> completionHandler: <span class="type">CompletionHandler</span>?
  
  <span class="keyword">init</span>(data: <span class="type">Data</span>?, urlResponse: <span class="type">URLResponse</span>?, error: <span class="type">Error</span>?, testCase: <span class="type">XCTestCase</span>) {
    
    <span class="keyword">self</span>.<span class="property">data</span> = data
    <span class="keyword">self</span>.<span class="property">urlResponse</span> = urlResponse
    <span class="keyword">self</span>.<span class="property">responseError</span> = error
    <span class="keyword">self</span>.<span class="property">testCase</span> = testCase
    <span class="keyword">self</span>.<span class="property">expectation</span> = testCase.<span class="call">expectation</span>(description: <span class="string">"Async"</span>)
  }
  
  <span class="keyword">override func</span> resume() {
    <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">async</span> {
      <span class="keyword">self</span>.<span class="property">completionHandler</span>?(<span class="keyword">self</span>.<span class="property">data</span>, <span class="keyword">self</span>.<span class="property">urlResponse</span>, <span class="keyword">self</span>.<span class="property">responseError</span>)
      
      <span class="comment">// Fulfill expectation after a delay</span>
      <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">asyncAfter</span>(deadline: <span class="type">DispatchTime</span>.<span class="call">now</span>() + <span class="number">0.1</span>, execute: {
        <span class="keyword">self</span>.<span class="property">expectation</span>.<span class="call">fulfill</span>()
      })
    }
  }
}
</code></pre><h2>Step 2: Test Error Case - URLRequest Returns An Error</h2><pre><code>   <span class="keyword">func</span> test_loadUser_errorInCompletionBlock() {
    <span class="comment">// given</span>
    <span class="keyword">let</span> error = <span class="type">NSError</span>(domain: <span class="string">"FooError"</span>, code: <span class="number">42</span>, userInfo: <span class="keyword">nil</span>)
    <span class="keyword">let</span> stubSession = <span class="type">StubURLSession</span>(data: <span class="keyword">nil</span>, urlResponse: <span class="keyword">nil</span>, error: error, testCase: <span class="keyword">self</span>)
    sut.<span class="property">session</span> = stubSession
    
    <span class="comment">// when</span>
    <span class="keyword">var</span> result: <span class="type">NSError</span>? = <span class="keyword">nil</span>
    sut.<span class="call">upload</span>(
    user: <span class="type">User</span>(name: <span class="string">"Foo"</span>)) { error <span class="keyword">in</span>
      
      result = error <span class="keyword">as</span> <span class="type">NSError</span>?
    }
    
    <span class="comment">// then</span>
    <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"http://example.com/user"</span>)!
    <span class="call">XCTAssertEqual</span>(stubSession.<span class="property">lastURLRequest</span>, <span class="type">URLRequest</span>(url: url))
    <span class="call">XCTAssertEqual</span>(result!, error)
  }
</code></pre><h2>Step 3: Test Error Case - Data Returned Is Not JSON</h2><pre><code>   <span class="keyword">func</span> test_loadUser_errorWhenNotJSON() {
    <span class="comment">// given</span>
    <span class="keyword">let</span> data = <span class="string">"1234"</span>.<span class="call">data</span>(using: .<span class="dotAccess">utf8</span>)
    <span class="keyword">let</span> stubSession = <span class="type">StubURLSession</span>(data: data, urlResponse: <span class="keyword">nil</span>, error: <span class="keyword">nil</span>, testCase: <span class="keyword">self</span>)
    sut.<span class="property">session</span> = stubSession
    
    <span class="comment">// when</span>
    <span class="keyword">var</span> result: <span class="type">NSError</span>! = <span class="keyword">nil</span>
    sut.<span class="call">upload</span>(
    user: <span class="type">User</span>(name: <span class="string">"Foo"</span>)) { error <span class="keyword">in</span>
      
      result = error <span class="keyword">as</span> <span class="type">NSError</span>?
    }
    
    <span class="comment">// then</span>
    <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"http://example.com/user"</span>)!
    <span class="call">XCTAssertEqual</span>(stubSession.<span class="property">lastURLRequest</span>, <span class="type">URLRequest</span>(url: url))
    <span class="call">XCTAssertEqual</span>(result.<span class="property">localizedDescription</span>,
                   <span class="string">"The data couldn’t be read because it isn’t in the correct format."</span>)
  }
</code></pre><h2>Step 4: Test The Happy Path</h2><pre><code>   <span class="keyword">func</span> test_uploadUser_success() {
    <span class="comment">// given</span>
    <span class="keyword">let</span> data = <span class="keyword">try</span>! <span class="type">JSONSerialization</span>.<span class="call">data</span>(withJSONObject: [<span class="string">"success"</span>:<span class="keyword">true</span>], options: [])
    <span class="keyword">let</span> stubSession = <span class="type">StubURLSession</span>(data: data, urlResponse: <span class="keyword">nil</span>, error: <span class="keyword">nil</span>, testCase: <span class="keyword">self</span>)
    sut.<span class="property">session</span> = stubSession
    
    <span class="comment">// when</span>
    <span class="keyword">var</span> result: <span class="type">Error</span>? = <span class="type">NSError</span>(domain: <span class="string">"Foo"</span>, code: <span class="number">1234</span>, userInfo: <span class="keyword">nil</span>)
    sut.<span class="call">upload</span>(user: <span class="type">User</span>(name: <span class="string">"Foo"</span>)) { error <span class="keyword">in</span>
      result = error
    }
    
    <span class="comment">// then</span>
    <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"http://example.com/user"</span>)!
    <span class="call">XCTAssertEqual</span>(stubSession.<span class="property">lastURLRequest</span>, <span class="type">URLRequest</span>(url: url))
    <span class="call">XCTAssertNil</span>(result)
  }
</code></pre><h2>Step 5: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> APIClient: <span class="type">NSObject</span> {
  
  <span class="keyword">lazy var</span> session: <span class="type">DDHURLSessionProtocol</span>? = <span class="type">URLSession</span>.<span class="property">shared</span>
  
  <span class="keyword">func</span> upload(
    user: <span class="type">User</span>,
    completion: <span class="keyword">@escaping</span> ((<span class="type">Error</span>?) -&gt; <span class="type">Void</span>)) {
    
    <span class="keyword">guard let</span> url = <span class="type">URL</span>(string: <span class="string">"http://example.com/user"</span>) <span class="keyword">else</span> {
      <span class="call">fatalError</span>()
    }
    
    <span class="keyword">let</span> request = <span class="type">URLRequest</span>(url: url)
    
    <span class="keyword">let</span> userData = <span class="keyword">try</span>? <span class="type">JSONEncoder</span>().<span class="call">encode</span>(user)
    
    session?.<span class="call">uploadTask</span>(with: request, from: userData) { data, response, error <span class="keyword">in
      
      if let</span> unwrappedError = error {
        <span class="call">completion</span>(unwrappedError)
        <span class="keyword">return</span>
      }
      
      <span class="keyword">guard let</span> unwrappedData = data <span class="keyword">else</span> {
        <span class="keyword">return</span>
      }
      
      <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">async</span> {
        
        <span class="keyword">do</span> {
          <span class="keyword">let</span> json = <span class="keyword">try</span> <span class="type">JSONSerialization</span>.<span class="call">jsonObject</span>(with: unwrappedData, options: [])
          <span class="keyword">if let</span> responseData = json <span class="keyword">as</span>? [<span class="type">String</span>:<span class="type">Any</span>],
             <span class="keyword">let</span> success = responseData[<span class="string">"success"</span>] <span class="keyword">as</span>? <span class="type">Bool</span>, <span class="call">success</span> {
            
            <span class="call">completion</span>(<span class="keyword">nil</span>)
          }
        } <span class="keyword">catch</span> {
          <span class="call">completion</span>(error)
        }
      }
    }.<span class="call">resume</span>()  
  }
}

<span class="keyword">struct</span> User: <span class="type">Equatable</span>, <span class="type">Codable</span> {
  <span class="keyword">let</span> name: <span class="type">String</span>
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://your-website-url.com/networking/chapter097</guid><title>Mocking and Stubbing a Data Task with URLSession</title><description>Test wheather the method `loadUser` fetches data and calls completion closure.</description><link>https://your-website-url.com/networking/chapter097</link><pubDate>Fri, 16 Oct 2020 01:37:00 +0200</pubDate><content:encoded><![CDATA[<h1>Mocking and Stubbing a Data Task with URLSession</h1><p>Test wheather the method <code>loadUser</code> fetches data and calls completion closure</p><h2>Step 0: Prerequisites</h2><p>Possibility to inject the url session as a dependency (see <strong>Dependency Injection</strong>)</p><h2>Step 0: Protocol</h2><pre><code><span class="keyword">protocol</span> DDHURLSessionProtocol {
  <span class="keyword">func</span> dataTask(with url: <span class="type">URL</span>, completionHandler: <span class="keyword">@escaping</span> (<span class="type">Data</span>?, <span class="type">URLResponse</span>?, <span class="type">Error</span>?) -&gt; <span class="type">Void</span>) -&gt; <span class="type">URLSessionDataTask</span>
}

<span class="keyword">extension</span> <span class="type">URLSession</span>: <span class="type">DDHURLSessionProtocol</span> {}
</code></pre><h2>Step 1.1: URLSession Stub</h2><pre><code><span class="keyword">class</span> StubURLSession: <span class="type">DDHURLSessionProtocol</span> {
  
  <span class="keyword">private var</span> url: <span class="type">URL</span>?
  <span class="keyword">private let</span> dataTask: <span class="type">StubURLSessionDataTask</span>
  
  <span class="keyword">init</span>(data: <span class="type">Data</span>?, urlResponse: <span class="type">URLResponse</span>?, error: <span class="type">Error</span>?, testCase: <span class="type">XCTestCase</span>) {
    
    dataTask = <span class="type">StubURLSessionDataTask</span>(data: data, urlResponse: urlResponse, error: error, testCase: testCase)
  }
  
  <span class="keyword">func</span> waitForAsync() {
    dataTask.<span class="property">testCase</span>.<span class="call">waitForExpectations</span>(timeout: <span class="number">5</span>)
  }
  
  <span class="keyword">var</span> lastURL: <span class="type">URL</span>? {
    dataTask.<span class="property">testCase</span>.<span class="call">waitForExpectations</span>(timeout: <span class="number">5</span>)
    
    <span class="keyword">return</span> url
  }
  
  <span class="keyword">func</span> dataTask(with url: <span class="type">URL</span>, completionHandler: <span class="keyword">@escaping</span> (<span class="type">Data</span>?, <span class="type">URLResponse</span>?, <span class="type">Error</span>?) -&gt; <span class="type">Void</span>) -&gt; <span class="type">URLSessionDataTask</span> {
    
    <span class="keyword">self</span>.<span class="property">url</span> = url
    dataTask.<span class="property">completionHandler</span> = completionHandler
    <span class="keyword">return</span> dataTask
  }
}
</code></pre><h2>Step 1.2: URLSessionDataTask Stub</h2><pre><code><span class="keyword">class</span> StubURLSessionDataTask: <span class="type">URLSessionDataTask</span> {
  
  <span class="keyword">private let</span> data: <span class="type">Data</span>?
  <span class="keyword">private let</span> urlResponse: <span class="type">URLResponse</span>?
  <span class="keyword">private let</span> responseError: <span class="type">Error</span>?
  <span class="keyword">let</span> testCase: <span class="type">XCTestCase</span>
  <span class="keyword">private let</span> expectation: <span class="type">XCTestExpectation</span>
  
  <span class="keyword">typealias</span> CompletionHandler = (<span class="type">Data</span>?, <span class="type">URLResponse</span>?, <span class="type">Error</span>?) -&gt; <span class="type">Void</span>
  <span class="keyword">var</span> completionHandler: <span class="type">CompletionHandler</span>?
  
  <span class="keyword">init</span>(data: <span class="type">Data</span>?, urlResponse: <span class="type">URLResponse</span>?, error: <span class="type">Error</span>?, testCase: <span class="type">XCTestCase</span>) {
    
    <span class="keyword">self</span>.<span class="property">data</span> = data
    <span class="keyword">self</span>.<span class="property">urlResponse</span> = urlResponse
    <span class="keyword">self</span>.<span class="property">responseError</span> = error
    <span class="keyword">self</span>.<span class="property">testCase</span> = testCase
    <span class="keyword">self</span>.<span class="property">expectation</span> = testCase.<span class="call">expectation</span>(description: <span class="string">"Async"</span>)
  }
  
  <span class="keyword">override func</span> resume() {
    <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">async</span> {
      <span class="keyword">self</span>.<span class="property">completionHandler</span>?(<span class="keyword">self</span>.<span class="property">data</span>, <span class="keyword">self</span>.<span class="property">urlResponse</span>, <span class="keyword">self</span>.<span class="property">responseError</span>)
      
      <span class="comment">// Fulfill expectation after a delay</span>
      <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">asyncAfter</span>(deadline: <span class="type">DispatchTime</span>.<span class="call">now</span>() + <span class="number">0.1</span>, execute: {
        <span class="keyword">self</span>.<span class="property">expectation</span>.<span class="call">fulfill</span>()
      })
    }
  }
}
</code></pre><h2>Step 2: Test Error Case - URLRequest Returns An Error</h2><pre><code>   <span class="keyword">func</span> test_loadUser_errorInCompletionBlock() {
    <span class="comment">// given</span>
    <span class="keyword">let</span> error = <span class="type">NSError</span>(domain: <span class="string">"FooError"</span>, code: <span class="number">42</span>, userInfo: <span class="keyword">nil</span>)
    <span class="keyword">let</span> stubSession = <span class="type">StubURLSession</span>(data: <span class="keyword">nil</span>, urlResponse: <span class="keyword">nil</span>, error: error, testCase: <span class="keyword">self</span>)
    sut.<span class="property">session</span> = stubSession
    
    <span class="comment">// when</span>
    <span class="keyword">var</span> result: <span class="type">NSError</span>? = <span class="keyword">nil</span>
    sut.<span class="call">loadUser</span> { <span class="keyword">_</span>, error <span class="keyword">in</span>
      result = error <span class="keyword">as</span> <span class="type">NSError</span>?
    }
    
    <span class="comment">// then</span>
    <span class="call">XCTAssertEqual</span>(stubSession.<span class="property">lastURL</span>, <span class="type">URL</span>(string: <span class="string">"http://example.com/user"</span>))
    <span class="call">XCTAssertEqual</span>(result!, error)
  }
</code></pre><h2>Step 3: Test Error Case - Data Returned Is Not JSON</h2><pre><code>   <span class="keyword">func</span> test_loadUser_errorWhenNotJSON() {
    <span class="comment">// given</span>
    <span class="keyword">let</span> data = <span class="string">"1234"</span>.<span class="call">data</span>(using: .<span class="dotAccess">utf8</span>)
    <span class="keyword">let</span> stubSession = <span class="type">StubURLSession</span>(data: data, urlResponse: <span class="keyword">nil</span>, error: <span class="keyword">nil</span>, testCase: <span class="keyword">self</span>
    )
    sut.<span class="property">session</span> = stubSession
    
    <span class="comment">// when</span>
    <span class="keyword">var</span> result: <span class="type">NSError</span>! = <span class="keyword">nil</span>
    sut.<span class="call">loadUser</span> { <span class="keyword">_</span>, error <span class="keyword">in</span>
      result = error <span class="keyword">as</span> <span class="type">NSError</span>?
    }
    
    <span class="comment">// then</span>
    <span class="call">XCTAssertEqual</span>(stubSession.<span class="property">lastURL</span>, <span class="type">URL</span>(string: <span class="string">"http://example.com/user"</span>))
    <span class="call">XCTAssertEqual</span>(result.<span class="property">localizedDescription</span>,
                   <span class="string">"The data couldn’t be read because it isn’t in the correct format."</span>)
  }
</code></pre><h2>Step 4: Test The Happy Path</h2><pre><code>   <span class="keyword">func</span> test_loadUser_userInBlock() {
    <span class="comment">// given</span>
    <span class="keyword">let</span> data = <span class="keyword">try</span>! <span class="type">JSONSerialization</span>.<span class="call">data</span>(withJSONObject: [<span class="string">"name"</span>:<span class="string">"dasdom"</span>], options: [])
    <span class="keyword">let</span> stubSession = <span class="type">StubURLSession</span>(data: data, urlResponse: <span class="keyword">nil</span>, error: <span class="keyword">nil</span>, testCase: <span class="keyword">self</span>)
    sut.<span class="property">session</span> = stubSession
    
    <span class="comment">// when</span>
    <span class="keyword">var</span> result: <span class="type">User</span>? = <span class="keyword">nil</span>
    sut.<span class="call">loadUser</span> { user, <span class="keyword">_ in</span>
      result = user
    }
    
    <span class="comment">// then</span>
    <span class="call">XCTAssertEqual</span>(stubSession.<span class="property">lastURL</span>, <span class="type">URL</span>(string: <span class="string">"http://example.com/user"</span>))
    <span class="call">XCTAssertEqual</span>(result, <span class="type">User</span>(name: <span class="string">"dasdom"</span>))
  }
</code></pre><h2>Step 5: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> APIClient: <span class="type">NSObject</span> {
  
  <span class="keyword">lazy var</span> session: <span class="type">DDHURLSessionProtocol</span>? = <span class="type">URLSession</span>.<span class="property">shared</span>
  
  <span class="keyword">func</span> loadUser(completionBlock: <span class="keyword">@escaping</span> (<span class="type">User</span>?, <span class="type">Error</span>?) -&gt; <span class="type">Void</span>) {
    <span class="keyword">guard let</span> url = <span class="type">URL</span>(string: <span class="string">"http://example.com/user"</span>) <span class="keyword">else</span> {
      <span class="call">fatalError</span>()
    }
    
    session?.<span class="call">dataTask</span>(
    with: url) { data, response, error <span class="keyword">in
      
      if let</span> unwrappedError = error {
        <span class="call">completionBlock</span>(<span class="keyword">nil</span>, unwrappedError)
      }
      
      <span class="keyword">guard let</span> data = data <span class="keyword">else</span> { <span class="keyword">return</span> }
      <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">async</span> {
        <span class="keyword">do</span> {
          <span class="keyword">let</span> json = <span class="keyword">try</span> <span class="type">JSONSerialization</span>.<span class="call">jsonObject</span>(with: data, options: [])
          <span class="keyword">if let</span> userData = json <span class="keyword">as</span>? [<span class="type">String</span>:<span class="type">String</span>], <span class="keyword">let</span> userName = userData[<span class="string">"name"</span>] {
            
            <span class="keyword">let</span> user = <span class="type">User</span>(name: userName)
            <span class="call">completionBlock</span>(user, error)
          }
        } <span class="keyword">catch</span> {
          <span class="call">completionBlock</span>(<span class="keyword">nil</span>, error)
        }
      }
      
      }.<span class="call">resume</span>()
  }
}

<span class="keyword">struct</span> User: <span class="type">Equatable</span> {
  <span class="keyword">let</span> name: <span class="type">String</span>
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://your-website-url.com/networking/chapter096</guid><title>Mocking and Stubbing with URLProtocol</title><description>Test wheather the method `loadUser` fetches data and calls completion closure.</description><link>https://your-website-url.com/networking/chapter096</link><pubDate>Fri, 16 Oct 2020 01:36:00 +0200</pubDate><content:encoded><![CDATA[<h1>Mocking and Stubbing with URLProtocol</h1><p>Test wheather the method <code>loadUser</code> fetches data and calls completion closure</p><h2>Step 0: Prerequisites</h2><p>Network calls use <code>URLSession.shared</code> or it's possible to inject it as a dependency (see <strong>Dependency Injection</strong>)</p><h2>Step 1: URLProtocol Subclass</h2><pre><code><span class="keyword">class</span> StubURLProtocol: <span class="type">URLProtocol</span> {
  <span class="keyword">private static var</span> dataToBeReturned: [<span class="type">URL</span>:<span class="type">Data</span>] = [:]
  <span class="keyword">private static var</span> errorToBeReturned: <span class="type">Error</span>?
  <span class="keyword">private static var</span> lastRequest: <span class="type">URLRequest</span>?
  <span class="comment">// Test case for expectation management</span>
  <span class="keyword">private static weak var</span> testCase: <span class="type">XCTestCase</span>?
  <span class="comment">// Expectation to wait for asyc call</span>
  <span class="keyword">private static var</span> expectation: <span class="type">XCTestExpectation</span>?
  
  <span class="keyword">class func</span> register(for url: <span class="type">URL</span>, with data: <span class="type">Data</span>? = <span class="keyword">nil</span>, error: <span class="type">Error</span>? = <span class="keyword">nil</span>, in testCase: <span class="type">XCTestCase</span>) {
    
    <span class="keyword">if let</span> unwrappedData = data {
      dataToBeReturned[url] = unwrappedData
    }
    
    <span class="keyword">self</span>.<span class="property">errorToBeReturned</span> = error
    
    <span class="type">StubURLProtocol</span>.<span class="property">testCase</span> = testCase
    <span class="comment">// Create expectation</span>
    <span class="keyword">self</span>.<span class="property">expectation</span> = testCase.<span class="call">expectation</span>(description: <span class="string">"Async"</span>)
    
    <span class="type">URLProtocol</span>.<span class="call">registerClass</span>(<span class="keyword">self</span>.<span class="keyword">self</span>)
  }
  
  <span class="keyword">static var</span> lastURL: <span class="type">URL</span>? {
    <span class="comment">// Wait for the expectation to be</span>
    testCase?.<span class="call">waitForExpectations</span>(timeout: <span class="number">5</span>)
    
    <span class="comment">// Return url of last request</span>
    <span class="keyword">return</span> lastRequest?.<span class="property">url</span>
  }
  
  <span class="keyword">override class func</span> canInit(
    with request: <span class="type">URLRequest</span>) -&gt; <span class="type">Bool</span> {
    
    <span class="comment">// Store last request</span>
    <span class="type">StubURLProtocol</span>.<span class="property">lastRequest</span> = request
    <span class="keyword">return true</span>
  }
  
  <span class="keyword">override class func</span> canonicalRequest(
    for request: <span class="type">URLRequest</span>) -&gt; <span class="type">URLRequest</span> {
    <span class="comment">// Minimal code</span>
    <span class="keyword">return</span> request
  }
  
  <span class="keyword">static func</span> waitForAsync() {
    <span class="comment">// Wait for the expectation</span>
    testCase?.<span class="call">waitForExpectations</span>(timeout: <span class="number">5</span>)
  }
  
  <span class="keyword">override func</span> startLoading() {
    <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">async</span> {
      <span class="comment">// In case of error != nil, return it</span>
      <span class="keyword">if let</span> error =
        <span class="type">StubURLProtocol</span>.<span class="call">errorToBeReturned</span> {
          <span class="keyword">self</span>.<span class="property">client</span>?.<span class="call">urlProtocol</span>(<span class="keyword">self</span>, didFailWithError: error)
      } <span class="keyword">else</span> {
        <span class="comment">// Return the data</span>
        <span class="keyword">let</span> data = <span class="type">StubURLProtocol</span>.<span class="property">dataToBeReturned</span>[<span class="keyword">self</span>.<span class="property">request</span>.<span class="property">url</span>!]!
        <span class="keyword">self</span>.<span class="property">client</span>?.<span class="call">urlProtocol</span>(<span class="keyword">self</span>, didLoad: data)
        <span class="keyword">self</span>.<span class="property">client</span>?.<span class="call">urlProtocolDidFinishLoading</span>(<span class="keyword">self</span>)
      }
      <span class="comment">// Fulfill expectation after a delay</span>
      <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">asyncAfter</span>(deadline: <span class="type">DispatchTime</span>.<span class="call">now</span>() + <span class="number">0.1</span>, execute: {
        <span class="type">StubURLProtocol</span>.<span class="property">expectation</span>?.<span class="call">fulfill</span>()
      })
    }
  }
  
  <span class="keyword">override func</span> stopLoading() {
    <span class="comment">// Minimal code</span>
  }
}
</code></pre><blockquote><p><strong>Note</strong>: There is an <code>XCTestExpectation</code> hidden in <code>StubURLProtocol</code>. Therefore in your test, you need to call <code>StubURLProtocol.lastURL</code> or <code>StubURLProtocol.waitForAsync()</code> <strong>before</strong> you inspect the result.</p></blockquote><h2>Step 2: Test Error Case - URLRequest Returns An Error</h2><pre><code>   <span class="keyword">func</span> test_loadUser_errorInCompletionBlock() {
    <span class="comment">// given</span>
    <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"http://example.com/user"</span>)!
    <span class="keyword">let</span> error = <span class="type">NSError</span>(domain: <span class="string">"FooError"</span>, code: <span class="number">42</span>, userInfo: <span class="keyword">nil</span>)
    
    <span class="type">StubURLProtocol</span>.<span class="call">register</span>(for: url, error: error, in: <span class="keyword">self</span>)
 
    <span class="comment">// when</span>
    <span class="keyword">var</span> result: <span class="type">NSError</span>? = <span class="keyword">nil</span>
    sut.<span class="call">loadUser</span> { <span class="keyword">_</span>, error <span class="keyword">in</span>
      result = error <span class="keyword">as</span> <span class="type">NSError</span>?
    }
 
    <span class="comment">// then</span>
    <span class="call">XCTAssertEqual</span>(<span class="type">StubURLProtocol</span>.<span class="property">lastURL</span>, url)
    <span class="call">XCTAssertEqual</span>(result!, error)
  }
</code></pre><h2>Step 3: Test Error Case - Data Returned Is Not JSON</h2><pre><code>   <span class="keyword">func</span> test_loadUser_errorWhenNotJSON() {
    <span class="comment">// given</span>
    <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"http://example.com/user"</span>)!
    <span class="keyword">let</span> data = <span class="string">"1234"</span>.<span class="call">data</span>(using: .<span class="dotAccess">utf8</span>)
    <span class="type">StubURLProtocol</span>.<span class="call">register</span>(for: url, with: data, in: <span class="keyword">self</span>)
    
    <span class="comment">// when</span>
    <span class="keyword">var</span> result: <span class="type">NSError</span>! = <span class="keyword">nil</span>
    sut.<span class="call">loadUser</span> { <span class="keyword">_</span>, error <span class="keyword">in</span>
      result = error <span class="keyword">as</span> <span class="type">NSError</span>?
    }
 
    <span class="comment">// then</span>
    <span class="call">XCTAssertEqual</span>(<span class="type">StubURLProtocol</span>.<span class="property">lastURL</span>, url)
    <span class="call">XCTAssertEqual</span>(result.<span class="property">localizedDescription</span>,
                   <span class="string">"The data couldn’t be read because it isn’t in the correct format."</span>)
  }
</code></pre><h2>Step 4: Test - Happy Path</h2><pre><code>   <span class="keyword">func</span> test_loadUser_userInBlock() {
    <span class="comment">// given</span>
    <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"http://example.com/user"</span>)!
    <span class="keyword">let</span> data = <span class="keyword">try</span>! <span class="type">JSONSerialization</span>.<span class="call">data</span>(withJSONObject: [<span class="string">"name"</span>:<span class="string">"dasdom"</span>], options: [])
    <span class="type">StubURLProtocol</span>.<span class="call">register</span>(for: url, with: data, in: <span class="keyword">self</span>)
    
    <span class="comment">// when</span>
    <span class="keyword">var</span> result: <span class="type">User</span>? = <span class="keyword">nil</span>
    sut.<span class="call">loadUser</span> { user, <span class="keyword">_ in</span>
      result = user
    }
    
    <span class="comment">// then</span>
    <span class="call">XCTAssertEqual</span>(<span class="type">StubURLProtocol</span>.<span class="property">lastURL</span>, url)
    <span class="call">XCTAssertEqual</span>(result, <span class="type">User</span>(name: <span class="string">"dasdom"</span>))
  }
</code></pre><h2>Step 5: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> APIClient: <span class="type">NSObject</span> {
  
  <span class="keyword">func</span> loadUser(completionBlock: <span class="keyword">@escaping</span> (<span class="type">User</span>?, <span class="type">Error</span>?) -&gt; <span class="type">Void</span>) {
    
    <span class="keyword">guard let</span> url = <span class="type">URL</span>(string: <span class="string">"http://example.com/user"</span>) <span class="keyword">else</span> {
      <span class="call">fatalError</span>()
    }
    
    <span class="type">URLSession</span>.<span class="property">shared</span>.<span class="call">dataTask</span>(
    with: url) { data, response, error <span class="keyword">in
      
      if let</span> unwrappedError = error {
        <span class="call">completionBlock</span>(<span class="keyword">nil</span>, unwrappedError)
      }
      
      <span class="keyword">guard let</span> data = data <span class="keyword">else</span> { <span class="keyword">return</span> }
      <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">async</span> {
        <span class="keyword">do</span> {
          <span class="keyword">let</span> json = <span class="keyword">try</span> <span class="type">JSONSerialization</span>.<span class="call">jsonObject</span>(with: data, options: [])
          <span class="keyword">if let</span> userData = json <span class="keyword">as</span>? [<span class="type">String</span>:<span class="type">String</span>], <span class="keyword">let</span> userName = userData[<span class="string">"name"</span>] {
            
            <span class="keyword">let</span> user = <span class="type">User</span>(name: userName)
            <span class="call">completionBlock</span>(user, error)
          }
        } <span class="keyword">catch</span> {
          <span class="call">completionBlock</span>(<span class="keyword">nil</span>, error)
        }
      }
      }.<span class="call">resume</span>()
  }
}

<span class="keyword">struct</span> User: <span class="type">Equatable</span> {
  <span class="keyword">let</span> name: <span class="type">String</span>
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://your-website-url.com/mocks/chapter020</guid><title>Stubs</title><description>Stubs are used when you need to test whether the system under test reacts to data it gets from another class or module in an expected way. Common examples are UserDefaults and network requests.</description><link>https://your-website-url.com/mocks/chapter020</link><pubDate>Fri, 16 Oct 2020 00:20:00 +0200</pubDate><content:encoded><![CDATA[<h1>Stubs</h1><p>Stubs are used when you need to test whether the system under test reacts to data it gets from another class or module in an expected way. Common examples are UserDefaults and network requests.</p><h2>Example Stub</h2><pre><code><span class="keyword">class</span> UserDefaultsStub : <span class="type">UserDefaults</span> {
  
  <span class="keyword">private let</span> boolToReturn: <span class="type">Bool</span>
  <span class="keyword">var</span> defaultName: <span class="type">String</span>? = <span class="keyword">nil
  
  init</span>(boolToReturn: <span class="type">Bool</span>) {
    <span class="keyword">self</span>.<span class="property">boolToReturn</span> = boolToReturn
    
    <span class="keyword">super</span>.<span class="keyword">init</span>(suiteName: <span class="keyword">nil</span>)!
  }
  
  <span class="keyword">override func</span> bool(forKey defaultName: <span class="type">String</span>)
    -&gt; <span class="type">Bool</span> {
      
      <span class="keyword">self</span>.<span class="property">defaultName</span> = defaultName
      <span class="keyword">return</span> boolToReturn
  }
}
</code></pre><h2>Usage</h2><pre><code>   <span class="keyword">func</span> test_appearance_whenFirstStart_showsOnboarding() {
    <span class="comment">// given</span>
    <span class="keyword">let</span> stubUserDefaults = <span class="type">UserDefaultsStub</span>(
      boolToReturn: <span class="keyword">false</span>)
    sut.<span class="property">userDefaults</span> = stubUserDefaults
    
    <span class="comment">// when</span>
    sut.<span class="call">beginAppearanceTransition</span>(
      <span class="keyword">true</span>, animated: <span class="keyword">false</span>)
    sut.<span class="call">endAppearanceTransition</span>()
    
    <span class="comment">// then</span>
    <span class="call">XCTAssertTrue</span>(sut.<span class="property">presentedViewController</span>
      <span class="keyword">is</span> <span class="type">OnboardingViewController</span>)
    <span class="call">XCTAssertEqual</span>(stubUserDefaults.<span class="property">defaultName</span>,
                   <span class="string">"AlreadyStartedKey"</span>)
  }
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://your-website-url.com/mocks/chapter019</guid><title>Mocks</title><description>Mocks are used when you need to verify that your system under test interacts with another class in an expeced way. It's often a good idea to define the interaction of the system under test and the class to be mocked with a protocol.</description><link>https://your-website-url.com/mocks/chapter019</link><pubDate>Fri, 16 Oct 2020 00:19:00 +0200</pubDate><content:encoded><![CDATA[<h1>Mocks</h1><p>Mocks are used when you need to verify that your system under test interacts with another class in an expeced way. It's often a good idea to define the interaction of the system under test and the class to be mocked with a protocol.</p><h2>Protocol</h2><pre><code><span class="keyword">protocol</span> UserUpdateable {
  <span class="keyword">func</span> update(with: <span class="type">User</span>)
}
</code></pre><h2>Example Mock</h2><pre><code><span class="keyword">class</span> ViewMock : <span class="type">UIView</span>, <span class="type">UserUpdateable</span> {

  <span class="keyword">var</span> updateUser: <span class="type">User</span>? = <span class="keyword">nil
  
  func</span> update(with user: <span class="type">User</span>) {
    updateUser = user
  }
}
</code></pre><h2>Usage</h2><pre><code>   <span class="keyword">func</span> test_settingUser_callsUpdate() {
    <span class="comment">// given</span>
    <span class="keyword">let</span> viewMock = <span class="type">ViewMock</span>()
    sut.<span class="property">view</span> = viewMock
    <span class="keyword">let</span> user = <span class="type">User</span>(name: <span class="string">"Foo"</span>, lastname: <span class="string">"Bar"</span>)
    
    <span class="comment">// when</span>
    sut.<span class="property">user</span> = user
    
    <span class="comment">// then</span>
    <span class="call">XCTAssertEqual</span>(viewMock.<span class="property">updateUser</span>, user)
  }
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://your-website-url.com/depenency_injection/chapter017</guid><title>Interface Injection</title><description></description><link>https://your-website-url.com/depenency_injection/chapter017</link><pubDate>Fri, 16 Oct 2020 00:17:00 +0200</pubDate><content:encoded><![CDATA[<h1>Interface Injection</h1><p>Inject dependency via interface</p><h2>Step 1: Protocols</h2><pre><code><span class="keyword">import</span> Foundation

<span class="keyword">protocol</span> DefaultsProtocol {
  <span class="keyword">func</span> bool(forKey: <span class="type">String</span>) -&gt; <span class="type">Bool</span>
}

<span class="keyword">extension</span> <span class="type">UserDefaults</span> : <span class="type">DefaultsProtocol</span> {}

<span class="keyword">protocol</span> InjectDependencyProtocol {
  <span class="keyword">mutating func</span> inject(defaults: <span class="type">DefaultsProtocol</span>)
}
</code></pre><h2>Step 2: Injection Point</h2><pre><code><span class="keyword">struct</span> User : <span class="type">InjectDependencyProtocol</span> {
  <span class="keyword">private lazy var</span> defaults: <span class="type">DefaultsProtocol</span> = <span class="type">UserDefaults</span>.<span class="property">standard</span>
  
  <span class="keyword">mutating func</span> inject(defaults: <span class="type">DefaultsProtocol</span>) {
    <span class="keyword">self</span>.<span class="property">defaults</span> = defaults
  }
}
</code></pre><h2>Step 3: Fake Object</h2><pre><code><span class="keyword">struct</span> DefaultsMock : <span class="type">DefaultsProtocol</span> {
  <span class="keyword">let</span> boolToReturn: <span class="type">Bool</span>
  
  <span class="keyword">func</span> bool(forKey: <span class="type">String</span>) -&gt; <span class="type">Bool</span> {
    <span class="keyword">return</span> boolToReturn
  }
}
</code></pre><h2>Step 4: Injection</h2><pre><code><span class="keyword">let</span> defaultsMock = <span class="type">DefaultsMock</span>(boolToReturn: <span class="keyword">false</span>)
<span class="keyword">var</span> user = <span class="type">User</span>()
user.<span class="call">inject</span>(defaults: defaultsMock)
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://your-website-url.com/depenency_injection/chapter016</guid><title>Setter Injection</title><description></description><link>https://your-website-url.com/depenency_injection/chapter016</link><pubDate>Fri, 16 Oct 2020 00:16:00 +0200</pubDate><content:encoded><![CDATA[<h1>Setter Injection</h1><p>Inject dependency via setter</p><h2>Step 1: Protocol</h2><pre><code><span class="keyword">import</span> Foundation

<span class="keyword">protocol</span> DefaultsProtocol {
  <span class="keyword">func</span> bool(forKey: <span class="type">String</span>) -&gt; <span class="type">Bool</span>
}

<span class="keyword">extension</span> <span class="type">UserDefaults</span> : <span class="type">DefaultsProtocol</span> {}
</code></pre><h2>Step 2: Injection Point</h2><pre><code><span class="keyword">struct</span> User {
  <span class="keyword">lazy var</span> defaults: <span class="type">DefaultsProtocol</span> = <span class="type">UserDefaults</span>.<span class="property">standard</span>
}
</code></pre><h2>Step 3: Fake Object</h2><pre><code><span class="keyword">struct</span> DefaultsStub : <span class="type">DefaultsProtocol</span> {
  <span class="keyword">let</span> boolToReturn: <span class="type">Bool</span>
  
  <span class="keyword">func</span> bool(forKey: <span class="type">String</span>) -&gt; <span class="type">Bool</span> {
    <span class="keyword">return</span> boolToReturn
  }
}
</code></pre><h2>Step 4: Injection</h2><pre><code><span class="keyword">let</span> defaultsStub = <span class="type">DefaultsStub</span>(boolToReturn: <span class="keyword">false</span>)
<span class="keyword">var</span> user = <span class="type">User</span>()
user.<span class="property">defaults</span> = defaultsStub
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://your-website-url.com/depenency_injection/chapter015</guid><title>Constructor Injection</title><description></description><link>https://your-website-url.com/depenency_injection/chapter015</link><pubDate>Fri, 16 Oct 2020 00:15:00 +0200</pubDate><content:encoded><![CDATA[<h1>Constructor Injection</h1><p>Inject dependency in constructor</p><h2>Step 1: Protocol</h2><pre><code><span class="keyword">import</span> Foundation

<span class="keyword">protocol</span> DefaultsProtocol {
  <span class="keyword">func</span> bool(forKey: <span class="type">String</span>) -&gt; <span class="type">Bool</span>
}

<span class="keyword">extension</span> <span class="type">UserDefaults</span> : <span class="type">DefaultsProtocol</span> {}
</code></pre><h2>Step 2: The Injection Point</h2><pre><code><span class="keyword">struct</span> User {
  <span class="keyword">let</span> defaults: <span class="type">DefaultsProtocol</span>
  
  <span class="keyword">init</span>(defaults: <span class="type">DefaultsProtocol</span> = <span class="type">UserDefaults</span>.<span class="property">standard</span>) {
    <span class="keyword">self</span>.<span class="property">defaults</span> = defaults
  }
}
</code></pre><h2>Step 3: Fake Object</h2><pre><code><span class="keyword">struct</span> DefaultsStub : <span class="type">DefaultsProtocol</span> {
  <span class="keyword">let</span> boolToReturn: <span class="type">Bool</span>
  
  <span class="keyword">func</span> bool(forKey: <span class="type">String</span>) -&gt; <span class="type">Bool</span> {
    <span class="keyword">return</span> boolToReturn
  }
}
</code></pre><h2>Step 4: Injection</h2><pre><code><span class="keyword">let</span> defaultsStub = <span class="type">DefaultsStub</span>(boolToReturn: <span class="keyword">false</span>)
<span class="keyword">let</span> user = <span class="type">User</span>(defaults: defaultsStub)
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://your-website-url.com/depenency_injection/chapter014</guid><title>Dependency Injection</title><description></description><link>https://your-website-url.com/depenency_injection/chapter014</link><pubDate>Fri, 16 Oct 2020 00:14:00 +0200</pubDate><content:encoded><![CDATA[<h1>Dependency Injection</h1><p>The different components in your code base depend on each other and on other frameworks (Apple and 3rd party). An example:</p><pre><code><span class="keyword">import</span> Foundation

<span class="keyword">func</span> loadBooks() {
  <span class="keyword">guard let</span> url = <span class="type">URL</span>(string: <span class="string">"http://example.com/books"</span>) <span class="keyword">else</span> {
    <span class="call">fatalError</span>()
  }
  
  <span class="type">URLSession</span>.<span class="property">shared</span>.<span class="call">dataTask</span>(with: url) { data, response, error <span class="keyword">in</span>
    
    <span class="comment">// do stuff</span>
    
    }.<span class="call">resume</span>()
}
</code></pre><p>This code depends on <code>URLSession</code> and its implementation of <code>dataTask(with:completionHandler:)</code>. In a test you often like to exchange such dependencies to make the tests faster and to make testing different scenarios easier. You'd like to 'inject the dependency'. This is sometimes also called 'inversion of control'.</p><h2>Advantages of Dependency Injection</h2><ol><li>In unit tests you need to control the behaviour of the dependencies to be able to test all relevant scenarios (error handling, edge cases, happy path).</li><li>In unit tests you need to replace long running computations (like network calls, data base access, complicated computations) with instant return of fake data.</li><li>You'd like to decouple the different parts of your code from each other and control how they interact from the outside. This also improves readability of your code.</li></ol><h2>How to inject dependencies</h2><p>There are three main ways to inject dependencies.</p><ol><li>Constructor injection</li><li>Setter injection</li><li>Interface injection</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://your-website-url.com/general/chapter013</guid><title>func addTeardownBlock( block:)</title><description></description><link>https://your-website-url.com/general/chapter013</link><pubDate>Fri, 16 Oct 2020 00:13:00 +0200</pubDate><content:encoded><![CDATA[<h1>func addTeardownBlock(_ block:)</h1><blockquote><p><strong>Apple docs:</strong> &gt; &gt; Call addTeardownBlock(_:) during a test method's execution to register a block of code to be called when the test method ends. &gt; Example is from the Apple docs.</p></blockquote><pre><code><span class="keyword">class</span> ReadAndWriteTests: <span class="type">XCTestCase</span> {
  
  <span class="keyword">func</span> temporaryFileURL() -&gt; <span class="type">URL</span> {
    
    <span class="keyword">let</span> directory = <span class="type">NSTemporaryDirectory</span>()
    <span class="keyword">let</span> filename = <span class="type">UUID</span>().<span class="property">uuidString</span>
    <span class="keyword">let</span> fileURL = <span class="type">URL</span>(fileURLWithPath: directory).<span class="call">appendingPathComponent</span>(filename)
    
    <span class="comment">// Add a teardown block to delete any file
    // at `fileURL`.</span>
    <span class="call">addTeardownBlock</span> {
      <span class="keyword">do</span> {
        <span class="keyword">let</span> fileManager = <span class="type">FileManager</span>.<span class="property">default</span>
        
        <span class="keyword">if</span> fileManager.<span class="call">fileExists</span>(atPath: fileURL.<span class="property">path</span>) {
          
          <span class="keyword">try</span> fileManager.<span class="call">removeItem</span>(at: fileURL)
          
          <span class="call">XCTAssertFalse</span>(fileManager.<span class="call">fileExists</span>(atPath: fileURL.<span class="property">path</span>))
        }
      } <span class="keyword">catch</span> {
        <span class="type">XCTFail</span>(<span class="string">"Error:</span> \(error)<span class="string">"</span>)
      }
    }
    <span class="keyword">return</span> fileURL
  }
  
  <span class="keyword">func</span> testReadAndWriteDataToTemporaryFile() {
    
    <span class="keyword">let</span> fileURL = <span class="call">temporaryFileURL</span>()
    
    <span class="keyword">let</span> originalString = <span class="string">"Hello there"</span>
    
    <span class="keyword">do</span> {
      <span class="keyword">try</span> originalString.<span class="call">write</span>(to: fileURL, atomically: <span class="keyword">true</span>, encoding: .<span class="dotAccess">utf8</span>)

      <span class="keyword">let</span> readString = <span class="keyword">try</span> <span class="type">String</span>(contentsOf: fileURL, encoding: .<span class="dotAccess">utf8</span>)

      <span class="call">XCTAssertEqual</span>(readString, originalString)
    } <span class="keyword">catch</span> {
      <span class="type">XCTFail</span>(<span class="string">"Error:</span> \(error)<span class="string">"</span>)
    }
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://your-website-url.com/general/chapter012</guid><title>func setUpWithError() and func tearDownWithError()</title><description></description><link>https://your-website-url.com/general/chapter012</link><pubDate>Fri, 16 Oct 2020 00:12:00 +0200</pubDate><content:encoded><![CDATA[<h1><code>func setUpWithError()</code> and <code>func tearDownWithError()</code></h1><blockquote><p><strong>Apple docs:</strong> &gt; &gt; Before each test begins, XCTest calls setUpWithError(), followed by setUp(). If state preparation might throw errors, override setUpWithError(). XCTest marks the test failed when when it catches errors, or skipped when it catches XCTSkip. &gt; &gt; ... &gt; &gt; After each test completes, XCTest calls tearDown(), followed by tearDownWithError(). If state cleanup might throw errors, override tearDownWithError(). XCTest marks the test failed when when it catches errors, or skipped when it catches XCTSkip.</p></blockquote><pre><code><span class="keyword">class</span> ViewTests : <span class="type">XCTestCase</span> {
  
  <span class="keyword">var</span> sut: <span class="type">View</span>!
  
  <span class="keyword">override func</span> setUpWithError() <span class="keyword">throws</span> {
    sut = <span class="type">View</span>()
  }
  
  <span class="keyword">override func</span> tearDownWithError() <span class="keyword">throws</span> {
    sut = <span class="keyword">nil</span>
  }
  
  <span class="keyword">func</span> test_labelIsSubview() {
    <span class="comment">// then</span>
    <span class="call">XCTAssertTrue</span>(sut.<span class="property">label</span>.<span class="call">isDescendant</span>(of: sut))
  }
}
</code></pre><h2>Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> View : <span class="type">UIView</span> {
  
  <span class="keyword">let</span> label: <span class="type">UILabel</span>
  
  <span class="keyword">override init</span>(frame: <span class="type">CGRect</span>) {
    label = <span class="type">UILabel</span>()
    
    <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)
    
    <span class="call">addSubview</span>(label)
  }
  
  <span class="keyword">required init</span>?(coder aDecoder: <span class="type">NSCoder</span>) { <span class="call">fatalError</span>() }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://your-website-url.com/general/chapter011</guid><title>func setUp() and func tearDown()</title><description></description><link>https://your-website-url.com/general/chapter011</link><pubDate>Fri, 16 Oct 2020 00:11:00 +0200</pubDate><content:encoded><![CDATA[<h1><code>func setUp()</code> and <code>func tearDown()</code></h1><blockquote><p><strong>Apple docs:</strong> &gt; &gt; Before each test begins, XCTest calls setUpWithError(), followed by setUp(). Override this method to reset state for each test method. If state preparation might throw errors, override setUpWithError(). &gt; &gt; ... &gt; &gt; After each test completes, XCTest calls tearDown(), followed by tearDownWithError(). Override this method to perform any per-test cleanup.</p></blockquote><pre><code><span class="keyword">class</span> ViewTests : <span class="type">XCTestCase</span> {
  
  <span class="keyword">var</span> sut: <span class="type">View</span>!
  
  <span class="keyword">override func</span> setUp() {
    sut = <span class="type">View</span>()
  }
  
  <span class="keyword">override func</span> tearDown() {
    sut = <span class="keyword">nil</span>
  }
  
  <span class="keyword">func</span> test_labelIsSubview() {
    <span class="comment">// then</span>
    <span class="call">XCTAssertTrue</span>(sut.<span class="property">label</span>.<span class="call">isDescendant</span>(of: sut))
  }
}
</code></pre><h2>Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> View : <span class="type">UIView</span> {
  
  <span class="keyword">let</span> label: <span class="type">UILabel</span>
  
  <span class="keyword">override init</span>(frame: <span class="type">CGRect</span>) {
    label = <span class="type">UILabel</span>()
    
    <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)
    
    <span class="call">addSubview</span>(label)
  }
  
  <span class="keyword">required init</span>?(coder aDecoder: <span class="type">NSCoder</span>) { <span class="call">fatalError</span>() }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://your-website-url.com/general/chapter010</guid><title>class func setUp() and class func tearDown()</title><description></description><link>https://your-website-url.com/general/chapter010</link><pubDate>Fri, 16 Oct 2020 00:10:00 +0200</pubDate><content:encoded><![CDATA[<h1><code>class func setUp()</code> and <code>class func tearDown()</code></h1><blockquote><p><strong>Apple docs:</strong> &gt; &gt; The setUp() class method is called exactly once for a test case, before its first test method is called. Override this method to customize the initial state for all tests in the test case. &gt; &gt; ... &gt; &gt; The tearDown() class method is called exactly once for a test case, after its final test method completes. Override this method to perform any cleanup after all test methods have ended.</p></blockquote><pre><code><span class="keyword">class</span> FooTests : <span class="type">XCTestCase</span> {
  
  <span class="keyword">static var</span> dateFormatter: <span class="type">DateFormatter</span>!
  
  <span class="keyword">override class func</span> setUp() {
    dateFormatter = <span class="type">DateFormatter</span>()
    dateFormatter.<span class="property">dateFormat</span> = <span class="string">"yyyy-MM-dd"</span>
  }
  
  <span class="keyword">override class func</span> tearDown() {
    dateFormatter = <span class="keyword">nil</span>
  }
  
  <span class="keyword">func</span> test_date() {
    <span class="comment">// given</span>
    <span class="keyword">let</span> dateString = <span class="string">"2019-03-01"</span>
    <span class="keyword">let</span> date = <span class="type">FooTests</span>.<span class="property">dateFormatter</span>.<span class="call">date</span>(from: dateString)!
    
    <span class="comment">// when</span>
    <span class="keyword">let</span> result = <span class="type">Foo</span>(date: date)
    
    <span class="comment">// then</span>
    <span class="call">XCTAssertEqual</span>(result.<span class="property">dateString</span>, dateString)
  }
}
</code></pre><h2>Example code that makes the test pass</h2><pre><code><span class="keyword">struct</span> Foo {
  <span class="keyword">let</span> dateString: <span class="type">String</span>
  
  <span class="keyword">init</span>(date: <span class="type">Date</span>) {
    <span class="keyword">let</span> dateFormatter = <span class="type">DateFormatter</span>()
    dateFormatter.<span class="property">dateFormat</span> = <span class="string">"yyyy-MM-dd"</span>
    
    dateString = dateFormatter.<span class="call">string</span>(from: date)
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://your-website-url.com/general/chapter008</guid><title>Custom Test Assertions</title><description>You can define your own custom assertions. Let's say we have a test that compares two dictionaries.</description><link>https://your-website-url.com/general/chapter008</link><pubDate>Fri, 16 Oct 2020 00:08:00 +0200</pubDate><content:encoded><![CDATA[<h1>Custom Test Assertions</h1><p>You can define your own custom assertions. Let's say we have a test that compares two dictionaries.</p><pre><code>   <span class="keyword">func</span> test_dictsAreQual() {
    <span class="keyword">let</span> dict1 = [<span class="string">"id"</span>: <span class="string">"2"</span>, <span class="string">"name"</span>: <span class="string">"foo"</span>]
    <span class="keyword">let</span> dict2 = [<span class="string">"id"</span>: <span class="string">"2"</span>, <span class="string">"name"</span>: <span class="string">"fo"</span>]
    
    <span class="call">XCTAssertEqual</span>(dict1, dict2)
  }
</code></pre><p>In this case, the test output is this:</p><pre><code>XCTAssertEqual failed: (<span class="string">"["id": "2", "name": "foo"]"</span>) <span class="keyword">is</span> not equal to (<span class="string">"["id": "2", "name": "fo"]"</span>) -
</code></pre><p>In this case it's easy see, what is different in the two dictionaries but what if you try to compare two dictionaries with hundreds of entries? Won't work. To improve the output, we can define a custom assertion method.</p><pre><code><span class="keyword">extension</span> <span class="type">Dictionary</span> <span class="keyword">where</span> <span class="type">Key</span>: <span class="type">Hashable</span>, <span class="type">Value</span>: <span class="type">Equatable</span> {
  
  <span class="keyword">func</span> assertEqual(to otherDict: [<span class="type">Key</span> : <span class="type">Value</span>], file: <span class="type">StaticString</span> = file, line: <span class="type">UInt</span> = <span class="keyword">#line</span>) {
    
    <span class="keyword">for</span> key <span class="keyword">in</span> keys {
      
      <span class="keyword">let</span> value1 = <span class="type">String</span>(describing: <span class="keyword">self</span>[key])
      <span class="keyword">let</span> value2 = <span class="type">String</span>(describing: otherDict[key])
      <span class="keyword">let</span> keyValue1 = <span class="string">"\"</span>\(key)<span class="string">\":</span> \(value1)<span class="string">"</span>
      <span class="keyword">let</span> keyValue2 = <span class="string">"\"</span>\(key)<span class="string">\":</span> \(value2)<span class="string">"</span>
      <span class="keyword">let</span> message = <span class="string">"""</span>
      \(keyValue1<span class="string">) is not equal to</span> \(keyValue2)
      <span class="string">"""</span>
      
      <span class="call">XCTAssertTrue</span>(<span class="keyword">self</span>[key] == otherDict[key], message, file: file, line: line)
    }
  }
}
</code></pre><p>With this extension, the test becomes:</p><pre><code>   <span class="keyword">func</span> test_dictsAreQual2() {
    <span class="keyword">let</span> dict1 = [<span class="string">"id"</span>: <span class="string">"2"</span>, <span class="string">"name"</span>: <span class="string">"foo"</span>]
    <span class="keyword">let</span> dict2 = [<span class="string">"id"</span>: <span class="string">"2"</span>, <span class="string">"name"</span>: <span class="string">"fo"</span>]
    
    dict1.<span class="call">assertEqual</span>(to: dict2)
  }
</code></pre><p>And the output becomes:</p><pre><code>XCTAssertTrue failed - <span class="string">"name"</span>: <span class="type">Optional</span>(<span class="string">"foo"</span>) <span class="keyword">is</span> not equal to <span class="string">"name"</span>: <span class="type">Optional</span>(<span class="string">"fo"</span>)
</code></pre><h3><code>#file</code> and <code>#line</code></h3><p>With the help of the parameter <code>file</code> and <code>line</code> in the custom assertions and the default values <code>#file</code> and <code>#line</code>, Xcode prints the assertion at the line where the assertion method is called. When we ommit those parameter the failure is reported in the line where the actual XCTAssert... call is located. That would not be helpful.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://your-website-url.com/general/chapter007</guid><title>XCTAssert Functions</title><description>There are many different assert methods to be used in a test. When in doubt always choose the one with the most helpful output. To be able to choose wise, you need to learn what all the assert methods do.</description><link>https://your-website-url.com/general/chapter007</link><pubDate>Fri, 16 Oct 2020 00:07:00 +0200</pubDate><content:encoded><![CDATA[<h1>XCTAssert Functions</h1><p>There are many different assert methods to be used in a test. When in doubt always choose the one with the most helpful output. To be able to choose wise, you need to learn what all the assert methods do.</p><h2>XCTAssert(_:)</h2><pre><code>   <span class="call">XCTAssert</span>(<span class="number">1</span>==<span class="number">2</span>)
</code></pre><p>Assert that an expression is true. Output:</p><pre><code>XCTAssertTrue failed -
</code></pre><h3>Declaration</h3><pre><code><span class="keyword">public func</span> XCTAssert(<span class="keyword">_</span> expression: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">Bool</span>,
                      <span class="keyword">_</span> message: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span> = <span class="keyword">default</span>,
                      file: <span class="type">StaticString</span> = <span class="keyword">#file</span>,
                      line: <span class="type">UInt</span> = <span class="keyword">#line</span>)
</code></pre><h2>XCTAssertEqual(_:_:)</h2><pre><code>   <span class="call">XCTAssertEqual</span>(<span class="number">1</span>, <span class="number">2</span>)
</code></pre><p>Assert that two expressions are equal. Both expressions need to be of the same type and this type needs to confom to <code>Equatable</code>. One or both expressions can return optional values. The method uses the <code>==</code> operator to check for equality. You should not use this method to check floating point values (<code>Float</code>, <code>Double</code>, ...) for equality. For floating point values use <a href="#xctassertequal_with_accuracy">XCTAssertEqual(_:_:accuracy:)</a>. Output:</p><pre><code>XCTAssertEqual failed: (<span class="string">"1"</span>) <span class="keyword">is</span> not equal to (<span class="string">"2"</span>) -
</code></pre><h3>Declaration</h3><pre><code><span class="keyword">public func</span> XCTAssertEqual&lt;T&gt;(<span class="keyword">_</span> expression1: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                              <span class="keyword">_</span> expression2: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                              <span class="keyword">_</span> message: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span> = <span class="keyword">default</span>,
                              file: <span class="type">StaticString</span> = <span class="keyword">#file</span>,
                              line: <span class="type">UInt</span> = <span class="keyword">#line</span>) <span class="keyword">where</span> <span class="type">T</span> : <span class="type">Equatable</span>
</code></pre><h2>XCTAssertEqual(_:_:accuracy:) {#xctassertequal<em>with</em>accuracy}</h2><pre><code>   <span class="call">XCTAssertEqual</span>(<span class="number">1.01</span>, <span class="number">1.03</span>, accuracy: <span class="number">0.01</span>)
</code></pre><p>Assert that two expressions are equal within the accuracy. Both expressions and the value for accuracy need to be of the same type and this type needs to confom to <code>FloatingPoint</code>. Use this method to check floating point values (<code>Float</code>, <code>Double</code>, ...) for equality. Output:</p><pre><code>XCTAssertEqualWithAccuracy failed: (<span class="string">"1.01"</span>) <span class="keyword">is</span> not equal to (<span class="string">"1.03"</span>) +/- (<span class="string">"0.01"</span>) -
</code></pre><h3>Declaration</h3><pre><code><span class="keyword">public func</span> XCTAssertEqual&lt;T&gt;(<span class="keyword">_</span> expression1: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                              <span class="keyword">_</span> expression2: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                              accuracy: <span class="type">T</span>,
                              <span class="keyword">_</span> message: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span> = <span class="keyword">default</span>,
                              file: <span class="type">StaticString</span> = <span class="keyword">#file</span>,
                              line: <span class="type">UInt</span> = <span class="keyword">#line</span>) <span class="keyword">where</span> <span class="type">T</span> : <span class="type">FloatingPoint</span>
</code></pre><h2>XCTAssertNotEqual(_:_:)</h2><pre><code>   <span class="call">XCTAssertNotEqual</span>(<span class="number">1</span>, <span class="number">1</span>)
</code></pre><p>Assert that two expressions are not equal. Both expressions need to be of the same type and this type needs to confom to <code>Equatable</code>. One or both expressions can return optional values. The method uses the <code>==</code> operator to check for equality. You should not use this method to check floating point values (<code>Float</code>, <code>Double</code>, ...) for equality. For floating point values use <a href="#xctassertnotequal_with_accuracy">XCTAssertNotEqual(_:_:accuracy:)</a>. Output:</p><pre><code>XCTAssertNotEqual failed: (<span class="string">"1"</span>) <span class="keyword">is</span> equal to (<span class="string">"1"</span>) -
</code></pre><h3>Declaration</h3><pre><code><span class="keyword">public func</span> XCTAssertNotEqual&lt;T&gt;(<span class="keyword">_</span> expression1: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                                 <span class="keyword">_</span> expression2: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                                 <span class="keyword">_</span> message: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span> = <span class="keyword">default</span>,
                                 file: <span class="type">StaticString</span> = <span class="keyword">#file</span>,
                                 line: <span class="type">UInt</span> = <span class="keyword">#line</span>) <span class="keyword">where</span> <span class="type">T</span> : <span class="type">Equatable</span>
</code></pre><h2>XCTAssertNotEqual(_:_:accuracy:) {#xctassertnotequal<em>with</em>accuracy}</h2><pre><code>   <span class="call">XCTAssertNotEqual</span>(<span class="number">1.01</span>, <span class="number">1.02</span>, accuracy: <span class="number">0.02</span>)
</code></pre><p>Assert that two expressions are not equal within the accuracy. Both expressions and the value for accuracy need to be of the same type and this type needs to confom to <code>FloatingPoint</code>. Use this method to check floating point values (<code>Float</code>, <code>Double</code>, ...) for equality. Output: <code></code>`swift XCTAssertNotEqualWithAccuracy failed: ("1.01") is equal to ("1.02") +/- ("0.02") - <code></code>`</p><h3>Declaration</h3><pre><code><span class="keyword">public func</span> XCTAssertNotEqual&lt;T&gt;(<span class="keyword">_</span> expression1: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                                 <span class="keyword">_</span> expression2: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                                 accuracy: <span class="type">T</span>,
                                 <span class="keyword">_</span> message: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span> = <span class="keyword">default</span>,
                                 file: <span class="type">StaticString</span> =<span class="keyword">#file</span>,
                                 line: <span class="type">UInt</span> =<span class="keyword">#line</span>) <span class="keyword">where</span> <span class="type">T</span> : <span class="type">FloatingPoint</span>
</code></pre><h2>XCTAssertGreaterThan(_:_:)</h2><pre><code>   <span class="call">XCTAssertGreaterThan</span>(<span class="number">1</span>, <span class="number">1</span>)
</code></pre><p>Assert that an expression is greater than an other expression. Both expressions need to be of the same type and this type needs to confom to <code>Comparable</code>. Output:</p><pre><code>XCTAssertGreaterThan failed: (<span class="string">"1"</span>) <span class="keyword">is</span> not greater than (<span class="string">"1"</span>) -
</code></pre><h3>Declaration</h3><pre><code><span class="keyword">public func</span> XCTAssertGreaterThan&lt;T&gt;(<span class="keyword">_</span> expression1: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                                    <span class="keyword">_</span> expression2: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                                    <span class="keyword">_</span> message: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span> = <span class="keyword">default</span>,
                                    file: <span class="type">StaticString</span> = <span class="keyword">#file</span>,
                                    line: <span class="type">UInt</span> = <span class="keyword">#line</span>) <span class="keyword">where</span> <span class="type">T</span> : <span class="type">Comparable</span>
</code></pre><h2>XCTAssertGreaterThanOrEqual(_:_:)</h2><pre><code>   <span class="call">XCTAssertGreaterThanOrEqual</span>(<span class="number">1</span>, <span class="number">1.01</span>)
</code></pre><p>Assert that an expression is greater than or equal to an other expression. Both expressions need to be of the same type and this type needs to confom to <code>Comparable</code>. Output:</p><pre><code>XCTAssertGreaterThanOrEqual failed: (<span class="string">"1.0"</span>) <span class="keyword">is</span> less than (<span class="string">"1.01"</span>) -
</code></pre><h3>Declaration</h3><pre><code><span class="keyword">public func</span> XCTAssertGreaterThanOrEqual&lt;T&gt;(<span class="keyword">_</span> expression1: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                                           <span class="keyword">_</span> expression2: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                                           <span class="keyword">_</span> message: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span> = <span class="keyword">default</span>,
                                           file: <span class="type">StaticString</span> = <span class="keyword">#file</span>,
                                           line: <span class="type">UInt</span> = <span class="keyword">#line</span>) <span class="keyword">where</span> <span class="type">T</span> : <span class="type">Comparable</span>
</code></pre><h2>XCTAssertLessThan(_:_:)</h2><pre><code>   <span class="call">XCTAssertLessThan</span>(<span class="number">1</span>,<span class="number">1</span>)
</code></pre><p>Assert that an expression is less than an other expression. Both expressions need to be of the same type and this type needs to confom to <code>Comparable</code>. Output:</p><pre><code>XCTAssertLessThan failed: (<span class="string">"1"</span>) <span class="keyword">is</span> not less than (<span class="string">"1"</span>) -
</code></pre><h3>Declaration</h3><pre><code><span class="keyword">public func</span> XCTAssertLessThan&lt;T&gt;(<span class="keyword">_</span> expression1: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                                 <span class="keyword">_</span> expression2: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                                 <span class="keyword">_</span> message: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span> = <span class="keyword">default</span>,
                                 file: <span class="type">StaticString</span> = <span class="keyword">#file</span>,
                                 line: <span class="type">UInt</span> = <span class="keyword">#line</span>) <span class="keyword">where</span> <span class="type">T</span> : <span class="type">Comparable</span>
</code></pre><h2>XCTAssertLessThanOrEqual(_:_:)</h2><pre><code>   <span class="call">XCTAssertLessThanOrEqual</span>(<span class="number">1.01</span>,<span class="number">1</span>)
</code></pre><p>Assert that an expression is less than or equal to an other expression. Both expressions need to be of the same type and this type needs to confom to <code>Comparable</code>. Output:</p><pre><code>XCTAssertLessThanOrEqual failed: (<span class="string">"1.01"</span>) <span class="keyword">is</span> greater than (<span class="string">"1.0"</span>) -
</code></pre><h3>Declaration</h3><pre><code><span class="keyword">public func</span> XCTAssertLessThanOrEqual&lt;T&gt;(<span class="keyword">_</span> expression1: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                                        <span class="keyword">_</span> expression2: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                                        <span class="keyword">_</span> message: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span> = <span class="keyword">default</span>,
                                        file: <span class="type">StaticString</span> = <span class="keyword">#file</span>,
                                        line: <span class="type">UInt</span> = <span class="keyword">#line</span>) <span class="keyword">where</span> <span class="type">T</span> : <span class="type">Comparable</span>
</code></pre><h2>XCTAssertNil(_:)</h2><pre><code>   <span class="call">XCTAssertNil</span>(<span class="number">1</span>)
</code></pre><p>Assert that an expression is nil. Output:</p><pre><code>XCTAssertNil failed: <span class="string">"1"</span> -
</code></pre><h3>Declaration</h3><pre><code><span class="keyword">public func</span> XCTAssertNil(<span class="keyword">_</span> expression: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">Any</span>?,
                         <span class="keyword">_</span> message: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span> = <span class="keyword">default</span>,
                         file: <span class="type">StaticString</span> = <span class="keyword">#file</span>,
                         line: <span class="type">UInt</span> = <span class="keyword">#line</span>)
</code></pre><h2>XCTAssertNotNil(_:)</h2><pre><code>   <span class="call">XCTAssertNotNil</span>(<span class="keyword">nil</span>)
</code></pre><p>Assert that an expression is not nil. Output:</p><pre><code>XCTAssertNotNil failed -
</code></pre><h3>Declaration</h3><pre><code><span class="keyword">public func</span> XCTAssertNotNil(<span class="keyword">_</span> expression: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">Any</span>?,
                            <span class="keyword">_</span> message: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span> = <span class="keyword">default</span>,
                            file: <span class="type">StaticString</span> = <span class="keyword">#file</span>,
                            line: <span class="type">UInt</span> = <span class="keyword">#line</span>)
</code></pre><h2>XCTAssertThrowsError(_:)</h2><pre><code>   <span class="call">XCTAssertThrowsError</span>(<span class="keyword">try</span> <span class="call">notThrowing</span>())
</code></pre><p>Assert that an expression does throw an error. Output:</p><pre><code>XCTAssertThrowsError failed: did not <span class="keyword">throw</span> an error -
</code></pre><h3>Declaration</h3><pre><code><span class="keyword">public func</span> XCTAssertThrowsError&lt;T&gt;(<span class="keyword">_</span> expression: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                                    <span class="keyword">_</span> message: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span> = <span class="keyword">default</span>,
                                    file: <span class="type">StaticString</span> = <span class="keyword">#file</span>,
                                    line: <span class="type">UInt</span> = <span class="keyword">#line</span>,
                                    <span class="keyword">_</span> errorHandler: (<span class="type">Error</span>) -&gt; <span class="type">Void</span> = <span class="keyword">default</span>)
</code></pre><h2>XCTAssertNoThrow(_:)</h2><pre><code>   <span class="call">XCTAssertNoThrow</span>(<span class="keyword">try</span> <span class="call">throwing</span>())
</code></pre><p>Assert that an expression does not throw an error. Output:</p><pre><code>XCTAssertNoThrow failed: threw error <span class="string">"Error Domain=Dummy error Code=42 "</span>(null)<span class="string">""</span> -
</code></pre><h3>Declaration</h3><pre><code><span class="keyword">public func</span> XCTAssertNoThrow&lt;T&gt;(<span class="keyword">_</span> expression: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                                <span class="keyword">_</span> message: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span> = <span class="keyword">default</span>,
                                file: <span class="type">StaticString</span> = <span class="keyword">#file</span>,
                                line: <span class="type">UInt</span> = <span class="keyword">#line</span>)
</code></pre><h2>XCTAssertTrue(_:)</h2><pre><code>   <span class="call">XCTAssertTrue</span>(<span class="number">1</span>==<span class="number">2</span>)
</code></pre><p>Assert that an expression is true. Output:</p><pre><code>XCTAssertTrue failed -
</code></pre><h3>Declaration</h3><pre><code><span class="keyword">public func</span> XCTAssertTrue(<span class="keyword">_</span> expression: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">Bool</span>,
                          <span class="keyword">_</span> message: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span> = <span class="keyword">default</span>,
                          file: <span class="type">StaticString</span> = <span class="keyword">#file</span>,
                          line: <span class="type">UInt</span> = <span class="keyword">#line</span>)
</code></pre><h2>XCTAssertFalse(_:)</h2><pre><code>   <span class="call">XCTAssertFalse</span>(<span class="number">1</span>==<span class="number">1</span>)
</code></pre><p>Assert that an expression is false. Output:</p><pre><code>XCTAssertFalse failed -
</code></pre><h3>Declaration</h3><pre><code><span class="keyword">public func</span> XCTAssertFalse(<span class="keyword">_</span> expression: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">Bool</span>,
                           <span class="keyword">_</span> message: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span> = <span class="keyword">default</span>,
                           file: <span class="type">StaticString</span> = <span class="keyword">#file</span>,
                           line: <span class="type">UInt</span> = <span class="keyword">#line</span>)
</code></pre><h2>XCTFail()</h2><pre><code>   <span class="type">XCTFail</span>()
</code></pre><p>Fails the test. Output:</p><pre><code>failed -
</code></pre><h3>Declaration</h3><pre><code><span class="keyword">public func</span> XCTFail(<span class="keyword">_</span> message: <span class="type">String</span> = <span class="keyword">default</span>,
                   file: <span class="type">StaticString</span> = <span class="keyword">#file</span>,
                   line: <span class="type">UInt</span> = <span class="keyword">#line</span>)
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://your-website-url.com/general/chapter006</guid><title>Xcode Behaviors</title><description>With behaviors you can tell Xcode what to do when things happen.</description><link>https://your-website-url.com/general/chapter006</link><pubDate>Fri, 16 Oct 2020 00:06:00 +0200</pubDate><content:encoded><![CDATA[<h1>Xcode Behaviors</h1><p>With behaviors you can tell Xcode what to do when things happen. <img src="../../images/xcode_behaviors_1.png" alt="Behavior window with my behavior for when testing starts"/> On the left side you can activate various different triggers like 'Build Starts', 'Test Fails', and 'Search Completes with result'. The behaviors are roughly devided in three parts. 1. Attention (like 'Play sound') 1. Navigation (like 'Show tab named') 1. Run a script As inspiration, here is the behavior I set up for when the test fails: <img src="../../images/xcode_behaviors_2.png"/> Play a sound 'Funk' : Often compiling and running the tests takes to long to keep watching and waiting. So most of the times I do something different in that time like grap three balls and do some juggling or read again the ticket I'm working on. So I need to be notified when the test finishes. This behavior does exalty that. I have different sounds for succeeding and failing tests. Notify using bezel or system notification : Same as above. I like to have a visual notification when the tests are finished and what the result is. Show tab named 🤓 : The tab with the 'name' 🤓 is my programming tab. In TDD a failing test means I need to write code to make the test pass. So I switch to the programming tab. Show test navigator : When the test fails I'd like to see an overview over all tests to see which tests failed.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://your-website-url.com/general/chapter005</guid><title>Xcode Menu Items For Testing</title><description></description><link>https://your-website-url.com/general/chapter005</link><pubDate>Fri, 16 Oct 2020 00:05:00 +0200</pubDate><content:encoded><![CDATA[<h1>Xcode Menu Items For Testing</h1><h2>Test (⌘U)</h2><p>Runs all active tests for the currently selected scheme.</p><p><strong>Menu item:</strong> <code>Product &gt; Test</code></p><p><strong>Shortcut:</strong> ⌘U</p><h2>Show Test Navigator (⌘6)</h2><p>The test navigator shows an overview of all test in the project.</p><p><strong>Menu item:</strong> <code>View &gt; Navigator &gt; Show Test Navigator</code></p><p><strong>Shortcut:</strong> ⌘6</p><img src="../../images/test_navigator.png"/><p>On the right is a symbol that shows the result of the test. If you hover over that symbol it changes to a play icon. This means if you click that icon, Xcode runs jurst this one test. The same way you can run all tests in one test case when you click at that possition next to the test case name.</p><h2>Build For Testing (⇧⌘U)</h2><p><strong>Menu item:</strong> <code>Product &gt; Build For &gt; Testing</code></p><p><strong>Shortcut:</strong> ⇧⌘U</p><h2>Test Without Building (⌃⌘U)</h2><p><strong>Menu item:</strong> <code>Product &gt; Perform Action &gt; Test Without Building</code></p><p><strong>Shortcut:</strong> ⌃⌘U</p><h2>Run Current Test (⌃⌥⌘U)</h2><p>Runs the test method, in which the cursor is currently located.</p><p><strong>Menu item:</strong> <code>Product &gt; Perform Action &gt; Test</code></p><p><strong>Shortcut:</strong> ⌃⌥⌘U</p><h2>Test Again (⌃⌥⌘G)</h2><p>Runs the last tests that have been run.</p><p><strong>Menu item:</strong> <code>Product &gt; Perform Action &gt; Test Again</code></p><p><strong>Shortcut:</strong> ⌃⌥⌘G</p><h2>Create Test Failure Breakpoint</h2><p><strong>Menu item:</strong> <code>Debug &gt; Breakpoints &gt; Create Test Failure Breakpoint</code></p>]]></content:encoded></item><item><guid isPermaLink="true">https://your-website-url.com/general/chapter003</guid><title>General</title><description>This book is not intended for beginners in Test-Driven Development. But if you are the kind of person who skips the text in blog posts to just read the important stuff (== the code) you might get enough information from this book to start writing valuable tests. This chapter sums up the essential information in case you are just starting with TDD.</description><link>https://your-website-url.com/general/chapter003</link><pubDate>Fri, 16 Oct 2020 00:03:00 +0200</pubDate><content:encoded><![CDATA[<h1>General</h1><p>This book is not intended for beginners in Test-Driven Development. But if you are the kind of person who skips the text in blog posts to just read the important stuff (== the code) you might get enough information from this book to start writing valuable tests. This chapter sums up the essential information in case you are just starting with TDD.</p><h2>Add Test Target</h2><p>For the tests, you need at least one testing target in Xcode. In this target all the tests are collected. You can have more than one testing target but at the beginning one is enough. When you create a new project check the option 'Include Unit Tests' to add a testing target to your project. <img src="../../images/new_project_testing_target.png" alt="New project with testing target"/> To add a testing target to an existing target open the targets screen in Xcode and click the plus sign at the bottom of the screen. <img src="../../images/add_target.png" alt="Add target to existing project"/> <img src="../../images/add_testing_target.png" alt="Make the new target a testing target"/> When you add tests to the project, you need to add them to the testing target.</p><h2>Red-Green-Refactor</h2><h3>Red</h3><p>In Test-Driven Development you always start with a failing test. This means you write the test code before you write the code to be tested. As there is no code to be tested, this test will definitely fail. A failing test is often shown by some red information. In Xcode it's a red diamond with a white x. That's why this step is called Red.</p><h3>Green</h3><p>Next you write the code that is needed to make the test pass. Usually this information is shown in combination with the color green. In Xcode this is a green diamond with a white checkmark. This step is called Green. Following these steps you have shown that the code you have written is tested by the test code. Otherwise the test would not have changed from failing (red) to passing (green). This is one value of starting with the test. If you first write the code and then the test, a green test tells you nothing. It could be that the test is always green. Only by switching from red to green you know that the test can fail.</p><h3>Refactor</h3><p>The last step in the cycle is refactoring. Now that you have the test that is testing something you can refactor the code. This step is very important. Always check the code if it can be improved. The test is there to make sure you don't break anything while improving.</p><h2>Test Structure</h2><p>Usually a test case looks like this:</p><pre><code><span class="keyword">import</span> XCTest                   <span class="comment">// 1</span>
<span class="keyword">@testable import</span> MyModule       <span class="comment">// 2</span>
 
<span class="keyword">class</span> SomeTests : <span class="type">XCTestCase</span> {  <span class="comment">// 3</span>

  <span class="keyword">var</span> sut: <span class="type">SomeClass</span>!           <span class="comment">// 4</span>

  <span class="keyword">override func</span> setUpWithError() <span class="keyword">throws</span> {       <span class="comment">// 5</span>
    sut = <span class="type">SomeClass</span>()
  }

  <span class="keyword">override func</span> tearDownWithError() <span class="keyword">throws</span> {    <span class="comment">// 6</span>
    sut = <span class="keyword">nil</span>
  }

  <span class="keyword">func</span> test_name_property() {   <span class="comment">// 7
    // The test code</span>
  }
}
</code></pre><ol><li>Import XCTest: This is the testing framework provided by Apple<ol start="2"><li>Import the module (= target) you'd like to test: Using <code>@testable</code> the module is imported in a way that you can access the public and the internal properties and methods. Without this keyword you can only access the public information.</li><li>The test class is a subclass of <code>XCTestCase</code>.</li><li>Usually you have one 'thing' (class, struct, enum) to test per test class. This is often called <code>sut</code> which stands for system under test (see next section).</li><li>The instance method <code>setUpWithError()</code> is called before each test. Usually you put there the setup code needed for each test, like setting up the instance you'd like to test.</li><li>Use <code>tearDownWithError()</code> to clean up if needed. Usually you destroy the instance under test.</li><li>Test methods need to start with the prefix <code>test</code>. Otherwise the test runner doesn't find the test.</li></ol></li></ol><h2>sut: System Under Test</h2><p>When you read test code from other developers you'll often encounter the term 'sut'. 'sut' is short for 'system under test'. This is the name usually used as the name for the instance that is tested in a test case. There are several reasons why it's a good idea to use this name in tests: 1. Easier copy and paste 2. It's obvious what is tested and what is setup to be able to test 3. Easier to read than <code>loginViewController</code> and <code>networkingClient</code>.</p><h2>You Might Repeat yourself</h2><p>It's OK to not do DRY (Don't Repeat Yourself) in tests. The most important quality of a test is to be as readable and as quickly scannable as possible. This means if a test is easier to read when you copy and paste code from somewhere else, do it. Imagine you have 300k lines of code and more than 2000 tests and suddenly a test you wrote six month ago fails. You don't want to spent an hour on why the test fails. You don’t want to run the debugger to figure out what belongs to the test. Always try to write the test in a way that it is immediately clean what the test does. But this doesn't mean you should write bad code when writing tests. It's often a good idea to put code you use several times into a helper method. But keep in mind that the tests schould be readable first.</p><h2>Force-Unwrapping in Tests</h2><p>In good Swift code you seldom see values that are forcefully unwrapped. Each forced unwrapping is a potential crash. It's good practice to use the possibilities Swift provides to avoid potential crashes like <code>if let</code> and <code>guard let</code>. Test code is different. As mentioned above, test code has to be easy to read before everything else. That's why it's OK to use force unwrapping in test code. If the test crashes, it's just a test failure. A test failure tells you what did go wrong and what you have to do to fix it. Keep in mind that this is my opinion on this topic. There are many other opinios out there. You should try to use force-unwrapping in tests for a few days and then use <code>if let</code> and <code>guard let</code> for a few days and then figure out for youself what feels best for you.</p><h2>What To Test</h2><p>The easy and most useless answer is: &gt; Test everything that needs to work properly. If you strictly follow the rules of Test-Driven Development you are only allowed to write production code if you have a failing test. And you have to stop writing production code as soon as all tests pass. This way, in theory you have tests for all the code you write. In practice it's not that easy. And it becomes more difficult when you write some of the tests after you have written the code to be tested. So, what should be tested? The tests should give you confidence in the code and they should make refactoring easier. If you are in doubt, ask yourself if the test you are going to write would increase you confidence in the code. And always try to write the tests in a way that they are unlikely to break during refactoring of the code.</p><h2>What If Something Is Really Hard To Test</h2><p>Sometimes, especially when you try to add tests to code you wrote a few weeks ago, it's not obvious how to write tests. Often the reason is that the different parts of the code are too tightly coupled to each other. Sometimes the class you want to test does to much. Some people say, code that is not easy to test, is bad code. So how do you transform it to testable (good) code? There is not a general answer to this question. But it won't hurt to proceed in small steps. Maybe you can add a few UI tests that help to make sure that you don't break something while you refactor the code to make it testable via unit tests. If it's not possible to use UI tests, only change parts of the code that can be verified by hand in a few minutes. An example: Let's say we have an app that shows an info box at the first start after an update of the app. To distinguish the first start of the app from all the other starts the first view controller checks the version stored in the UserDefaults. If it's the first start, the version is updates in the UserDefaults. To test this, you need to be able to control the UserDefaults in your test. This is <em>the</em> standard use case for dependency injection. But this means you need to change the code to allow to inject that dependency. The changes needed to allow injecting the dependency could break this functionality. So you need to be extra careful in checking if this feature still works after you changed the code. This could mean to delete and reinstall the app several times until you get it right. But the effort pays off. After you have changed the code, you are able to control the circumstances of the start from the test. It could even happen, that this helps further down the live cycle of the app when requirements change and you need make changes to that part of the code. First you now have tests to ensure the feature does not break. Second injecting the dependency into that part of the code makes the code easier to change.</p><h2>Code That Is Easy To Test</h2><p>The easiest thing to test are pure functions. Pure functions are functions without any side effect. For example this function is a pure function:</p><pre><code><span class="keyword">func</span> add(a: <span class="type">Int</span>, b: <span class="type">Int</span>) -&gt; <span class="type">Int</span> {
  <span class="keyword">return</span> a + b
}
</code></pre><p>Often this results in the impression that one should only test model objects because it's easy to write pure functions when dealing with the model objects of an app. But you can and should test each and every aspect of you app. Sure, testing the behaviour of a view controller is not as straight forward as testing pure functions. But with a bit of practice you'll be able to write tests for each and every corner of you app. In general, code that's easy to test is: - focused (does only one thing) - can be controlled from outside (dependency injection) - is explicit (it's obvious what the code does; clever code isn't clever) - uses descriptive names But don't trust my words on this. There are many books about how to write good code. And good code is testable. :)</p>]]></content:encoded></item><item><guid isPermaLink="true">https://your-website-url.com/introduction/chapter002</guid><title>Introduction</title><description>In Jazz music, Fake Books help performers to learn and perform new songs. They contain the bare minimum needed to play the songs. They are not intended for beginners.</description><link>https://your-website-url.com/introduction/chapter002</link><pubDate>Fri, 16 Oct 2020 00:02:00 +0200</pubDate><content:encoded><![CDATA[<h1>Introduction</h1><p>In Jazz music, Fake Books help performers to learn and perform new songs. They contain the bare minimum needed to play the songs. They are not intended for beginners.</p><p>This book is a Fake Book for iOS developers about Test-Driven Development. You cannot learn Test-Driven Development from this book. Use it to look up how to implement many test cases encountered in iOS development.</p><p>To make this as quick as possible, this book mainly contains the code you need to write the tests. You won't find any explanations why it is done this way in this book. If you want to know the why behind tests, search for other books, search the internet, and read blog posts.</p><h1>The Structure Of The Book</h1><p>This book is structured into three parts. The first part, 'Testing in Xcode', contains informations about testing in general and testing in Xcode.</p><p>The second part, 'Unit Tests', contains common unit tests in Test-Driven iOS Development.</p><p>The third part, 'UI Tests', describes common UI tests.</p><h1>This Book Is For You</h1><p>This book is for you if you</p><ul><li>already have a little bit experience with Test-Driven iOS Development</li><li>are the kind of person who skips the text in blog posts when searching for a solution of a problem</li><li>are looking for code examples for the most common testing scenarios in iOS development</li><li>know how to search the internet in case you need to know why the code in this book makes sense (or why it doesn't)</li></ul><h1>This Book Is Not For You</h1><p>This book is <strong>not</strong> for you if you are looking for</p><ul><li>an introduction to Unit-Tests</li><li>an introduction to Test-Driven iOS Development</li><li>an in depth discussion <strong>why</strong> tests are written like this</li></ul><h1>Storyboards vs Code</h1><p>It doesn't matter if you use Storyboards for you user interface or if you type it all in code. But user interfaces defined in code are a bit easier to test. The main difference is how you get an instance of the view controller you'd like to run your tests on. This section describes theses differences.</p><h2>Storyboards</h2><p>If your user interface is defined in a Storyboard, you first need to set a storyboard id for the scene you want to write tests for. Then in the test case you setup the system under test (which is the view controller connected to the scene) like this:</p><pre><code><span class="keyword">import</span> UIKit
<span class="keyword">import</span> XCTest

<span class="keyword">class</span> ProfileViewControllerTests : <span class="type">XCTestCase</span> {

  <span class="keyword">var</span> sut: <span class="type">ProfileViewController</span>!

  <span class="keyword">override func</span> setUpWithError() <span class="keyword">throws</span> {
    <span class="keyword">let</span> storyboard = <span class="type">UIStoryboard</span>(name: <span class="string">"Main"</span>, bundle: <span class="keyword">nil</span>)
    sut = storyboard.<span class="call">instantiateViewController</span>(withIdentifier: <span class="string">"ProfileViewController"</span>) <span class="keyword">as</span>! <span class="type">ProfileViewController</span>
  }

  <span class="keyword">override func</span> tearDownWithError() <span class="keyword">throws</span> {
    sut = <span class="keyword">nil</span>
  }
}
</code></pre><h2>User Interface In Code</h2><p>In case you've defined you user interface in code. You just need to call the initialiser of the view controller unter test.</p><pre><code><span class="keyword">import</span> UIKit
<span class="keyword">import</span> XCTest

<span class="keyword">class</span> ProfileViewControllerTests : <span class="type">XCTestCase</span> {

  <span class="keyword">var</span> sut: <span class="type">ProfileViewController</span>!

  <span class="keyword">override func</span> setUpWithError() <span class="keyword">throws</span> {
    sut = <span class="type">ProfileViewController</span>()
  }

  <span class="keyword">override func</span> tearDownWithError() <span class="keyword">throws</span> {
    sut = <span class="keyword">nil</span>
  }
}
</code></pre><h1>Thank You</h1><p>This book would have not been possible without the awesome iOS community. I have the privilege to be part of this community since 2009. Thank you all for sharing your knowledge and help each other to grow.</p><p>I'd like to thank especially a few people who helped me to do my first steps in Test Driven iOS Development:</p><ul><li><a href="https://twitter.com/iwasleeg">Graham Lee</a> for his awesome book about Test Driven iOS Development</li><li><a href="https://twitter.com/qcoding">Jon Reid</a> for helping me understand key concepts and giving me new input through his awesome blog</li><li><a href="https://twitter.com/joemasilotti">Joe Masilotti</a> for his UI Testing Cheat Sheet that helped me getting into UI Testing<ul></ul></li></ul><p>I hope this book helps some (or better many) people to get into TDD for iOS apps. I'd love to hear from you if you find this book helpful.</p>]]></content:encoded></item></channel></rss>