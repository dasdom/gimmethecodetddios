<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>GimmeTheCodeTddIos</title><description>A description of GimmeTheCodeTddIos</description><link>https://your-website-url.com</link><language>en</language><lastBuildDate>Fri, 16 Oct 2020 14:43:54 +0200</lastBuildDate><pubDate>Fri, 16 Oct 2020 14:43:54 +0200</pubDate><ttl>250</ttl><atom:link href="https://your-website-url.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://your-website-url.com/introduction/chapter002</guid><title>Introduction</title><description>In Jazz music, Fake Books help performers to learn and perform new songs. They contain the bare minimum needed to play the songs. They are not intended for beginners.</description><link>https://your-website-url.com/introduction/chapter002</link><pubDate>Fri, 16 Oct 2020 10:44:00 +0200</pubDate><content:encoded><![CDATA[<h1>Introduction</h1><p>In Jazz music, Fake Books help performers to learn and perform new songs. They contain the bare minimum needed to play the songs. They are not intended for beginners. This book is a Fake Book for iOS developers about Test-Driven Development. You cannot learn Test-Driven Development from this book. Use it to look up how to implement many test cases encountered in iOS development. To make this as quick as possible, this book mainly contains the code you need to write the tests. You won't find any explanations why it is done this way in this book. If you want to know the why behind tests, search for other books, search the internet, and read blog posts.</p><h1>The Structure Of The Book</h1><p>This book is structured into three parts. The first part, 'Testing in Xcode', contains informations about testing in general and testing in Xcode. The second part, 'Unit Tests', contains common unit tests in Test-Driven iOS Development. The third part, 'UI Tests', describes common UI tests.</p><h1>This Book Is For You</h1><p>This book is for you if you - already have a little bit experience with Test-Driven iOS Development - are the kind of person who skips the text in blog posts when searching for a solution of a problem - are looking for code examples for the most common testing scenarios in iOS development - know how to search the internet in case you need to know why the code in this book makes sense (or why it doesn't)</p><h1>This Book Is Not For You</h1><p>This book is <strong>not</strong> for you if you are looking for - an introduction to Unit-Tests - an introduction to Test-Driven iOS Development - an in depth discussion <strong>why</strong> tests are written like this</p><h1>Code Structure</h1><p>The line breaks in the code snippets in this book might seem to be wrong at some places. The reason is that it’s not easy to get it right for all screen sizes (in EPUB format). I tried to make it readable even on small screen sizes (iPhone SE). But my guess is that you are reading this on an iPad. This book is not what you read while you wait in a queue. It’s a book that sits on your desk while you are writing tests. <strong>The line breaks are optimised for the iPad Books-App when scrolling is enabled.</strong></p><h1>Storyboards vs Code</h1><p>It doesn't matter if you use Storyboards for you user interface or if you type it all in code. But user interfaces defined in code are a bit easier to test. The main difference is how you get an instance of the view controller you'd like to run your tests on. This section describes theses differences.</p><h2>Storyboards</h2><p>If your user interface is defined in a Storyboard, you first need to set a storyboard id for the scene you want to write tests for. Then in the test case you setup the system under test (which is the view controller connected to the scene) like this: <code></code>`swift import UIKit import XCTest class ProfileViewControllerTests : XCTestCase { var sut: ProfileViewController! override func setUpWithError() throws { let storyboard = UIStoryboard(name: "Main", bundle: nil) sut = storyboard .instantiateViewController( withIdentifier: "ProfileViewController") as! ProfileViewController } override func tearDownWithError() throws { sut = nil } } <code></code>`</p><h2>User Interface In Code</h2><p>In case you've defined you user interface in code. You just need to call the initialiser of the view controller unter test. <code></code>`swift import UIKit import XCTest class ProfileViewControllerTests : XCTestCase { var sut: ProfileViewController! override func setUpWithError() throws { sut = ProfileViewController() } override func tearDownWithError() throws { sut = nil } } <code></code>`</p><h1>Thank You</h1><p>This book would have not been possible without the awesome iOS community. I have the privilege to be part of this community since 2009. Thank you all for sharing your knowledge and help each other to grow. I'd like to thank especially a few people who helped me to do my forst steps in Test Driven iOS Development: - <a href="https://twitter.com/iwasleeg">Graham Lee</a> for his awesome book about Test Driven iOS Development - <a href="https://twitter.com/qcoding">Jon Reid</a> for helping me understand key concepts and giving me new input through his awesome blog - <a href="https://twitter.com/joemasilotti">Joe Masilotti</a> for his UI Testing Cheat Sheet that helped me getting into UI Testing I hope this book helps some (or better many) people to get into TDD for iOS apps. I'd love to hear from you if you find this book helpful.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://your-website-url.com/introduction/chapter003</guid><title>General</title><description>This book is not intended for beginners in Test-Driven Development. But if you are the kind of person who skips the text in blog posts to just read the important stuff (== the code) you might get enough information from this book to start writing valuable tests. This chapter sums up the essential information in case you are just starting with TDD.</description><link>https://your-website-url.com/introduction/chapter003</link><pubDate>Fri, 16 Oct 2020 10:44:00 +0200</pubDate><content:encoded><![CDATA[<h1>General</h1><p>This book is not intended for beginners in Test-Driven Development. But if you are the kind of person who skips the text in blog posts to just read the important stuff (== the code) you might get enough information from this book to start writing valuable tests. This chapter sums up the essential information in case you are just starting with TDD.</p><h2>Add Test Target</h2><p>For the tests, you need at least one testing target in Xcode. In this target all the tests are collected. You can have more than one testing target but at the beginning one is enough. When you create a new project check the option 'Include Unit Tests' to add a testing target to your project. <img src="images/new_project_testing_target.png" alt="New project with testing target"/> To add a testing target to an existing target open the targets screen in Xcode and click the plus sign at the bottom of the screen. <img src="images/add_target.png" alt="Add target to existing project"/> <img src="images/add_testing_target.png" alt="Make the new target a testing target"/> When you add tests to the project, you need to add them to the testing target.</p><h2>Red-Green-Refactor</h2><h3>Red</h3><p>In Test-Driven Development you always start with a failing test. This means you write the test code before you write the code to be tested. As there is no code to be tested, this test will definitely fail. A failing test is often shown by some red information. In Xcode it's a red diamond with a white x. That's why this step is called Red.</p><h3>Green</h3><p>Next you write the code that is needed to make the test pass. Usually this information is shown in combination with the color green. In Xcode this is a green diamond with a white checkmark. This step is called Green. Following these steps you have shown that the code you have written is tested by the test code. Otherwise the test would not have changed from failing (red) to passing (green). This is one value of starting with the test. If you first write the code and then the test, a green test tells you nothing. It could be that the test is always green. Only by switching from red to green you know that the test can fail.</p><h3>Refactor</h3><p>The last step in the cycle is refactoring. Now that you have the test that is testing something you can refactor the code. This step is very important. Always check the code if it can be improved. The test is there to make sure you don't break anything while improving.</p><h2>Test Structure</h2><p>Usually a test case looks like this: <code></code>`swift import XCTest // 1 @testable import MyModule // 2 class SomeTests : XCTestCase { // 3 var sut: SomeClass! // 4 override func setUpWithError() throws { // 5 sut = SomeClass() } override func tearDownWithError() throws { // 6 sut = nil } func test<em>name</em>property() { // 7 // The test code } } <code></code>` 1. Import XCTest: This is the testing framework provided by Apple 2. Import the module (= target) you'd like to test: Using <code>@testable</code> the module is imported in a way that you can access the public and the internal properties and methods. Without this keyword you can only access the public information. 3. The test class is a subclass of <code>XCTestCase</code>. 4. Usually you have one 'thing' (class, struct, enum) to test per test class. This is often called <code>sut</code> which stands for system under test (see next section). 5. The instance method <code>setUpWithError()</code> is called before each test. Usually you put there the setup code needed for each test, like setting up the instance you'd like to test. 6. Use <code>tearDownWithError()</code> to clean up if needed. Usually you destroy the instance under test. 7. Test methods need to start with the prefix <code>test</code>. Otherwise the test runner doesn't find the test.</p><h2>sut: System Under Test</h2><p>When you read test code from other developers you'll often encounter the term 'sut'. 'sut' is short for 'system under test'. This is the name usually used as the name for the instance that is tested in a test case. There are several reasons why it's a good idea to use this name in tests: 1. Easier copy and paste 2. It's obvious what is tested and what is setup to be able to test 3. Easier to read than <code>loginViewController</code> and <code>networkingClient</code>.</p><h2>You Might Repeat yourself</h2><p>It's OK to not do DRY (Don't Repeat Yourself) in tests. The most important quality of a test is to be as readable and as quickly scannable as possible. This means if a test is easier to read when you copy and paste code from somewhere else, do it. Imagine you have 300k lines of code and more than 2000 tests and suddenly a test you wrote six month ago fails. You don't want to spent an hour on why the test fails. You don’t want to run the debugger to figure out what belongs to the test. Always try to write the test in a way that it is immediately clean what the test does. But this doesn't mean you should write bad code when writing tests. It's often a good idea to put code you use several times into a helper method. But keep in mind that the tests schould be readable first.</p><h2>Force-Unwrapping in Tests</h2><p>In good Swift code you seldom see values that are forcefully unwrapped. Each forced unwrapping is a potential crash. It's good practice to use the possibilities Swift provides to avoid potential crashes like <code>if let</code> and <code>guard let</code>. Test code is different. As mentioned above, test code has to be easy to read before everything else. That's why it's OK to use force unwrapping in test code. If the test crashes, it's just a test failure. A test failure tells you what did go wrong and what you have to do to fix it. Keep in mind that this is my opinion on this topic. There are many other opinios out there. You should try to use force-unwrapping in tests for a few days and then use <code>if let</code> and <code>guard let</code> for a few days and then figure out for youself what feels best for you.</p><h2>What To Test</h2><p>The easy and most useless answer is: &gt; Test everything that needs to work properly. If you strictly follow the rules of Test-Driven Development you are only allowed to write production code if you have a failing test. And you have to stop writing production code as soon as all tests pass. This way, in theory you have tests for all the code you write. In practice it's not that easy. And it becomes more difficult when you write some of the tests after you have written the code to be tested. So, what should be tested? The tests should give you confidence in the code and they should make refactoring easier. If you are in doubt, ask yourself if the test you are going to write would increase you confidence in the code. And always try to write the tests in a way that they are unlikely to break during refactoring of the code.</p><h2>What If Something Is Really Hard To Test</h2><p>Sometimes, especially when you try to add tests to code you wrote a few weeks ago, it's not obvious how to write tests. Often the reason is that the different parts of the code are too tightly coupled to each other. Sometimes the class you want to test does to much. Some people say, code that is not easy to test, is bad code. So how do you transform it to testable (good) code? There is not a general answer to this question. But it won't hurt to proceed in small steps. Maybe you can add a few UI tests that help to make sure that you don't break something while you refactor the code to make it testable via unit tests. If it's not possible to use UI tests, only change parts of the code that can be verified by hand in a few minutes. An example: Let's say we have an app that shows an info box at the first start after an update of the app. To distinguish the first start of the app from all the other starts the first view controller checks the version stored in the UserDefaults. If it's the first start, the version is updates in the UserDefaults. To test this, you need to be able to control the UserDefaults in your test. This is <em>the</em> standard use case for dependency injection. But this means you need to change the code to allow to inject that dependency. The changes needed to allow injecting the dependency could break this functionality. So you need to be extra careful in checking if this feature still works after you changed the code. This could mean to delete and reinstall the app several times until you get it right. But the effort pays off. After you have changed the code, you are able to control the circumstances of the start from the test. It could even happen, that this helps further down the live cycle of the app when requirements change and you need make changes to that part of the code. First you now have tests to ensure the feature does not break. Second injecting the dependency into that part of the code makes the code easier to change.</p><h2>Code That Is Easy To Test</h2><p>The easiest thing to test are pure functions. Pure functions are functions without any side effect. For example this function is a pure function: <code></code>`swift func add(a: Int, b: Int) -&gt; Int { return a + b } <code></code>` Often this results in the impression that one should only test model objects because it's easy to write pure functions when dealing with the model objects of an app. But you can and should test each and every aspect of you app. Sure, testing the behaviour of a view controller is not as straight forward as testing pure functions. But with a bit of practice you'll be able to write tests for each and every corner of you app. In general, code that's easy to test is: - focused (does only one thing) - can be controlled from outside (dependency injection) - is explicit (it's obvious what the code does; clever code isn't clever) - uses descriptive names But don't trust my words on this. There are many books about how to write good code. And good code is testable. :)</p>]]></content:encoded></item></channel></rss>