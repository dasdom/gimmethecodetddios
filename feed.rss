<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>Gimme The Code: TDD iOS</title><description>How to test iOS apps.</description><link>https://gimmetheco.de</link><language>en</language><lastBuildDate>Sat, 24 Oct 2020 10:47:43 +0200</lastBuildDate><pubDate>Sat, 24 Oct 2020 10:47:43 +0200</pubDate><ttl>250</ttl><atom:link href="https://gimmetheco.de/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://gimmetheco.de/networking/chapter098</guid><title>Mocking and Stubbing an Upload Task with URLSession</title><description>Test wheather the method `loadUser` fetches data and calls completion closure.</description><link>https://gimmetheco.de/networking/chapter098</link><pubDate>Fri, 16 Oct 2020 01:38:00 +0200</pubDate><content:encoded><![CDATA[<h1>Mocking and Stubbing an Upload Task with URLSession</h1><p>Test wheather the method <code>loadUser</code> fetches data and calls completion closure</p><h2>Step 0: Prerequisites</h2><p>Possibility to inject the url session as a dependency (see <strong>Dependency Injection</strong>)</p><h2>Step 0: Protocol</h2><pre><code><span class="keyword">protocol</span> DDHURLSessionProtocol {
  
  <span class="keyword">func</span> uploadTask(with request: <span class="type">URLRequest</span>, from bodyData: <span class="type">Data</span>?, completionHandler: <span class="keyword">@escaping</span> (<span class="type">Data</span>?, <span class="type">URLResponse</span>?, <span class="type">Error</span>?) -&gt; <span class="type">Void</span>) -&gt; <span class="type">URLSessionUploadTask</span>
}

<span class="keyword">extension</span> <span class="type">URLSession</span>: <span class="type">DDHURLSessionProtocol</span> {}
</code></pre><h2>Step 1.1: URLSession Stub</h2><pre><code><span class="keyword">class</span> StubURLSession: <span class="type">DDHURLSessionProtocol</span> {
  
  <span class="keyword">private var</span> urlRequest: <span class="type">URLRequest</span>?
  <span class="keyword">private var</span> uploadData: <span class="type">Data</span>?
  <span class="keyword">private let</span> uploadTask: <span class="type">StubURLSessionUploadTask</span>
  
  <span class="keyword">init</span>(data: <span class="type">Data</span>?, urlResponse: <span class="type">URLResponse</span>?, error: <span class="type">Error</span>?, testCase: <span class="type">XCTestCase</span>) {
    
    uploadTask = <span class="type">StubURLSessionUploadTask</span>(data: data, urlResponse: urlResponse, error: error, testCase: testCase)
  }
  
  <span class="keyword">func</span> waitForAsync() {
    uploadTask.<span class="property">testCase</span>.<span class="call">waitForExpectations</span>(timeout: <span class="number">5</span>)
  }
  
  <span class="keyword">var</span> lastURLRequest: <span class="type">URLRequest</span>? {
    uploadTask.<span class="property">testCase</span>.<span class="call">waitForExpectations</span>(timeout: <span class="number">5</span>)
    
    <span class="keyword">return</span> urlRequest
  }
  
  <span class="keyword">func</span> uploadTask(with request: <span class="type">URLRequest</span>, from bodyData: <span class="type">Data</span>?, completionHandler: <span class="keyword">@escaping</span> (<span class="type">Data</span>?, <span class="type">URLResponse</span>?, <span class="type">Error</span>?) -&gt; <span class="type">Void</span>) -&gt; <span class="type">URLSessionUploadTask</span> {
    
    <span class="keyword">self</span>.<span class="property">urlRequest</span> = request
    uploadTask.<span class="property">completionHandler</span> = completionHandler
    <span class="keyword">return</span> uploadTask
  }
}
</code></pre><h2>Step 1.2: URLSessionUploadTask Stub</h2><pre><code><span class="keyword">class</span> StubURLSessionUploadTask: <span class="type">URLSessionUploadTask</span> {
  
  <span class="keyword">private let</span> data: <span class="type">Data</span>?
  <span class="keyword">private let</span> urlResponse: <span class="type">URLResponse</span>?
  <span class="keyword">private let</span> responseError: <span class="type">Error</span>?
  <span class="keyword">let</span> testCase: <span class="type">XCTestCase</span>
  <span class="keyword">private let</span> expectation: <span class="type">XCTestExpectation</span>
  
  <span class="keyword">typealias</span> CompletionHandler = (<span class="type">Data</span>?, <span class="type">URLResponse</span>?, <span class="type">Error</span>?) -&gt; <span class="type">Void</span>
  <span class="keyword">var</span> completionHandler: <span class="type">CompletionHandler</span>?
  
  <span class="keyword">init</span>(data: <span class="type">Data</span>?, urlResponse: <span class="type">URLResponse</span>?, error: <span class="type">Error</span>?, testCase: <span class="type">XCTestCase</span>) {
    
    <span class="keyword">self</span>.<span class="property">data</span> = data
    <span class="keyword">self</span>.<span class="property">urlResponse</span> = urlResponse
    <span class="keyword">self</span>.<span class="property">responseError</span> = error
    <span class="keyword">self</span>.<span class="property">testCase</span> = testCase
    <span class="keyword">self</span>.<span class="property">expectation</span> = testCase.<span class="call">expectation</span>(description: <span class="string">"Async"</span>)
  }
  
  <span class="keyword">override func</span> resume() {
    <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">async</span> {
      <span class="keyword">self</span>.<span class="property">completionHandler</span>?(<span class="keyword">self</span>.<span class="property">data</span>, <span class="keyword">self</span>.<span class="property">urlResponse</span>, <span class="keyword">self</span>.<span class="property">responseError</span>)
      
      <span class="comment">// Fulfill expectation after a delay</span>
      <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">asyncAfter</span>(deadline: <span class="type">DispatchTime</span>.<span class="call">now</span>() + <span class="number">0.1</span>, execute: {
        <span class="keyword">self</span>.<span class="property">expectation</span>.<span class="call">fulfill</span>()
      })
    }
  }
}
</code></pre><h2>Step 2: Test Error Case - URLRequest Returns An Error</h2><pre><code>   <span class="keyword">func</span> test_loadUser_errorInCompletionBlock() {
    <span class="comment">// given</span>
    <span class="keyword">let</span> error = <span class="type">NSError</span>(domain: <span class="string">"FooError"</span>, code: <span class="number">42</span>, userInfo: <span class="keyword">nil</span>)
    <span class="keyword">let</span> stubSession = <span class="type">StubURLSession</span>(data: <span class="keyword">nil</span>, urlResponse: <span class="keyword">nil</span>, error: error, testCase: <span class="keyword">self</span>)
    sut.<span class="property">session</span> = stubSession
    
    <span class="comment">// when</span>
    <span class="keyword">var</span> result: <span class="type">NSError</span>? = <span class="keyword">nil</span>
    sut.<span class="call">upload</span>(
    user: <span class="type">User</span>(name: <span class="string">"Foo"</span>)) { error <span class="keyword">in</span>
      
      result = error <span class="keyword">as</span> <span class="type">NSError</span>?
    }
    
    <span class="comment">// then</span>
    <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"http://example.com/user"</span>)!
    <span class="call">XCTAssertEqual</span>(stubSession.<span class="property">lastURLRequest</span>, <span class="type">URLRequest</span>(url: url))
    <span class="call">XCTAssertEqual</span>(result!, error)
  }
</code></pre><h2>Step 3: Test Error Case - Data Returned Is Not JSON</h2><pre><code>   <span class="keyword">func</span> test_loadUser_errorWhenNotJSON() {
    <span class="comment">// given</span>
    <span class="keyword">let</span> data = <span class="string">"1234"</span>.<span class="call">data</span>(using: .<span class="dotAccess">utf8</span>)
    <span class="keyword">let</span> stubSession = <span class="type">StubURLSession</span>(data: data, urlResponse: <span class="keyword">nil</span>, error: <span class="keyword">nil</span>, testCase: <span class="keyword">self</span>)
    sut.<span class="property">session</span> = stubSession
    
    <span class="comment">// when</span>
    <span class="keyword">var</span> result: <span class="type">NSError</span>! = <span class="keyword">nil</span>
    sut.<span class="call">upload</span>(
    user: <span class="type">User</span>(name: <span class="string">"Foo"</span>)) { error <span class="keyword">in</span>
      
      result = error <span class="keyword">as</span> <span class="type">NSError</span>?
    }
    
    <span class="comment">// then</span>
    <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"http://example.com/user"</span>)!
    <span class="call">XCTAssertEqual</span>(stubSession.<span class="property">lastURLRequest</span>, <span class="type">URLRequest</span>(url: url))
    <span class="call">XCTAssertEqual</span>(result.<span class="property">localizedDescription</span>,
                   <span class="string">"The data couldn’t be read because it isn’t in the correct format."</span>)
  }
</code></pre><h2>Step 4: Test The Happy Path</h2><pre><code>   <span class="keyword">func</span> test_uploadUser_success() {
    <span class="comment">// given</span>
    <span class="keyword">let</span> data = <span class="keyword">try</span>! <span class="type">JSONSerialization</span>.<span class="call">data</span>(withJSONObject: [<span class="string">"success"</span>:<span class="keyword">true</span>], options: [])
    <span class="keyword">let</span> stubSession = <span class="type">StubURLSession</span>(data: data, urlResponse: <span class="keyword">nil</span>, error: <span class="keyword">nil</span>, testCase: <span class="keyword">self</span>)
    sut.<span class="property">session</span> = stubSession
    
    <span class="comment">// when</span>
    <span class="keyword">var</span> result: <span class="type">Error</span>? = <span class="type">NSError</span>(domain: <span class="string">"Foo"</span>, code: <span class="number">1234</span>, userInfo: <span class="keyword">nil</span>)
    sut.<span class="call">upload</span>(user: <span class="type">User</span>(name: <span class="string">"Foo"</span>)) { error <span class="keyword">in</span>
      result = error
    }
    
    <span class="comment">// then</span>
    <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"http://example.com/user"</span>)!
    <span class="call">XCTAssertEqual</span>(stubSession.<span class="property">lastURLRequest</span>, <span class="type">URLRequest</span>(url: url))
    <span class="call">XCTAssertNil</span>(result)
  }
</code></pre><h2>Step 5: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> APIClient: <span class="type">NSObject</span> {
  
  <span class="keyword">lazy var</span> session: <span class="type">DDHURLSessionProtocol</span>? = <span class="type">URLSession</span>.<span class="property">shared</span>
  
  <span class="keyword">func</span> upload(
    user: <span class="type">User</span>,
    completion: <span class="keyword">@escaping</span> ((<span class="type">Error</span>?) -&gt; <span class="type">Void</span>)) {
    
    <span class="keyword">guard let</span> url = <span class="type">URL</span>(string: <span class="string">"http://example.com/user"</span>) <span class="keyword">else</span> {
      <span class="call">fatalError</span>()
    }
    
    <span class="keyword">let</span> request = <span class="type">URLRequest</span>(url: url)
    
    <span class="keyword">let</span> userData = <span class="keyword">try</span>? <span class="type">JSONEncoder</span>().<span class="call">encode</span>(user)
    
    session?.<span class="call">uploadTask</span>(with: request, from: userData) { data, response, error <span class="keyword">in
      
      if let</span> unwrappedError = error {
        <span class="call">completion</span>(unwrappedError)
        <span class="keyword">return</span>
      }
      
      <span class="keyword">guard let</span> unwrappedData = data <span class="keyword">else</span> {
        <span class="keyword">return</span>
      }
      
      <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">async</span> {
        
        <span class="keyword">do</span> {
          <span class="keyword">let</span> json = <span class="keyword">try</span> <span class="type">JSONSerialization</span>.<span class="call">jsonObject</span>(with: unwrappedData, options: [])
          <span class="keyword">if let</span> responseData = json <span class="keyword">as</span>? [<span class="type">String</span>:<span class="type">Any</span>],
             <span class="keyword">let</span> success = responseData[<span class="string">"success"</span>] <span class="keyword">as</span>? <span class="type">Bool</span>, <span class="call">success</span> {
            
            <span class="call">completion</span>(<span class="keyword">nil</span>)
          }
        } <span class="keyword">catch</span> {
          <span class="call">completion</span>(error)
        }
      }
    }.<span class="call">resume</span>()  
  }
}

<span class="keyword">struct</span> User: <span class="type">Equatable</span>, <span class="type">Codable</span> {
  <span class="keyword">let</span> name: <span class="type">String</span>
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/networking/chapter097</guid><title>Mocking and Stubbing a Data Task with URLSession</title><description>Test wheather the method `loadUser` fetches data and calls completion closure.</description><link>https://gimmetheco.de/networking/chapter097</link><pubDate>Fri, 16 Oct 2020 01:37:00 +0200</pubDate><content:encoded><![CDATA[<h1>Mocking and Stubbing a Data Task with URLSession</h1><p>Test wheather the method <code>loadUser</code> fetches data and calls completion closure</p><h2>Step 0: Prerequisites</h2><p>Possibility to inject the url session as a dependency (see <strong>Dependency Injection</strong>)</p><h2>Step 0: Protocol</h2><pre><code><span class="keyword">protocol</span> DDHURLSessionProtocol {
  <span class="keyword">func</span> dataTask(with url: <span class="type">URL</span>, completionHandler: <span class="keyword">@escaping</span> (<span class="type">Data</span>?, <span class="type">URLResponse</span>?, <span class="type">Error</span>?) -&gt; <span class="type">Void</span>) -&gt; <span class="type">URLSessionDataTask</span>
}

<span class="keyword">extension</span> <span class="type">URLSession</span>: <span class="type">DDHURLSessionProtocol</span> {}
</code></pre><h2>Step 1.1: URLSession Stub</h2><pre><code><span class="keyword">class</span> StubURLSession: <span class="type">DDHURLSessionProtocol</span> {
  
  <span class="keyword">private var</span> url: <span class="type">URL</span>?
  <span class="keyword">private let</span> dataTask: <span class="type">StubURLSessionDataTask</span>
  
  <span class="keyword">init</span>(data: <span class="type">Data</span>?, urlResponse: <span class="type">URLResponse</span>?, error: <span class="type">Error</span>?, testCase: <span class="type">XCTestCase</span>) {
    
    dataTask = <span class="type">StubURLSessionDataTask</span>(data: data, urlResponse: urlResponse, error: error, testCase: testCase)
  }
  
  <span class="keyword">func</span> waitForAsync() {
    dataTask.<span class="property">testCase</span>.<span class="call">waitForExpectations</span>(timeout: <span class="number">5</span>)
  }
  
  <span class="keyword">var</span> lastURL: <span class="type">URL</span>? {
    dataTask.<span class="property">testCase</span>.<span class="call">waitForExpectations</span>(timeout: <span class="number">5</span>)
    
    <span class="keyword">return</span> url
  }
  
  <span class="keyword">func</span> dataTask(with url: <span class="type">URL</span>, completionHandler: <span class="keyword">@escaping</span> (<span class="type">Data</span>?, <span class="type">URLResponse</span>?, <span class="type">Error</span>?) -&gt; <span class="type">Void</span>) -&gt; <span class="type">URLSessionDataTask</span> {
    
    <span class="keyword">self</span>.<span class="property">url</span> = url
    dataTask.<span class="property">completionHandler</span> = completionHandler
    <span class="keyword">return</span> dataTask
  }
}
</code></pre><h2>Step 1.2: URLSessionDataTask Stub</h2><pre><code><span class="keyword">class</span> StubURLSessionDataTask: <span class="type">URLSessionDataTask</span> {
  
  <span class="keyword">private let</span> data: <span class="type">Data</span>?
  <span class="keyword">private let</span> urlResponse: <span class="type">URLResponse</span>?
  <span class="keyword">private let</span> responseError: <span class="type">Error</span>?
  <span class="keyword">let</span> testCase: <span class="type">XCTestCase</span>
  <span class="keyword">private let</span> expectation: <span class="type">XCTestExpectation</span>
  
  <span class="keyword">typealias</span> CompletionHandler = (<span class="type">Data</span>?, <span class="type">URLResponse</span>?, <span class="type">Error</span>?) -&gt; <span class="type">Void</span>
  <span class="keyword">var</span> completionHandler: <span class="type">CompletionHandler</span>?
  
  <span class="keyword">init</span>(data: <span class="type">Data</span>?, urlResponse: <span class="type">URLResponse</span>?, error: <span class="type">Error</span>?, testCase: <span class="type">XCTestCase</span>) {
    
    <span class="keyword">self</span>.<span class="property">data</span> = data
    <span class="keyword">self</span>.<span class="property">urlResponse</span> = urlResponse
    <span class="keyword">self</span>.<span class="property">responseError</span> = error
    <span class="keyword">self</span>.<span class="property">testCase</span> = testCase
    <span class="keyword">self</span>.<span class="property">expectation</span> = testCase.<span class="call">expectation</span>(description: <span class="string">"Async"</span>)
  }
  
  <span class="keyword">override func</span> resume() {
    <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">async</span> {
      <span class="keyword">self</span>.<span class="property">completionHandler</span>?(<span class="keyword">self</span>.<span class="property">data</span>, <span class="keyword">self</span>.<span class="property">urlResponse</span>, <span class="keyword">self</span>.<span class="property">responseError</span>)
      
      <span class="comment">// Fulfill expectation after a delay</span>
      <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">asyncAfter</span>(deadline: <span class="type">DispatchTime</span>.<span class="call">now</span>() + <span class="number">0.1</span>, execute: {
        <span class="keyword">self</span>.<span class="property">expectation</span>.<span class="call">fulfill</span>()
      })
    }
  }
}
</code></pre><h2>Step 2: Test Error Case - URLRequest Returns An Error</h2><pre><code>   <span class="keyword">func</span> test_loadUser_errorInCompletionBlock() {
    <span class="comment">// given</span>
    <span class="keyword">let</span> error = <span class="type">NSError</span>(domain: <span class="string">"FooError"</span>, code: <span class="number">42</span>, userInfo: <span class="keyword">nil</span>)
    <span class="keyword">let</span> stubSession = <span class="type">StubURLSession</span>(data: <span class="keyword">nil</span>, urlResponse: <span class="keyword">nil</span>, error: error, testCase: <span class="keyword">self</span>)
    sut.<span class="property">session</span> = stubSession
    
    <span class="comment">// when</span>
    <span class="keyword">var</span> result: <span class="type">NSError</span>? = <span class="keyword">nil</span>
    sut.<span class="call">loadUser</span> { <span class="keyword">_</span>, error <span class="keyword">in</span>
      result = error <span class="keyword">as</span> <span class="type">NSError</span>?
    }
    
    <span class="comment">// then</span>
    <span class="call">XCTAssertEqual</span>(stubSession.<span class="property">lastURL</span>, <span class="type">URL</span>(string: <span class="string">"http://example.com/user"</span>))
    <span class="call">XCTAssertEqual</span>(result!, error)
  }
</code></pre><h2>Step 3: Test Error Case - Data Returned Is Not JSON</h2><pre><code>   <span class="keyword">func</span> test_loadUser_errorWhenNotJSON() {
    <span class="comment">// given</span>
    <span class="keyword">let</span> data = <span class="string">"1234"</span>.<span class="call">data</span>(using: .<span class="dotAccess">utf8</span>)
    <span class="keyword">let</span> stubSession = <span class="type">StubURLSession</span>(data: data, urlResponse: <span class="keyword">nil</span>, error: <span class="keyword">nil</span>, testCase: <span class="keyword">self</span>
    )
    sut.<span class="property">session</span> = stubSession
    
    <span class="comment">// when</span>
    <span class="keyword">var</span> result: <span class="type">NSError</span>! = <span class="keyword">nil</span>
    sut.<span class="call">loadUser</span> { <span class="keyword">_</span>, error <span class="keyword">in</span>
      result = error <span class="keyword">as</span> <span class="type">NSError</span>?
    }
    
    <span class="comment">// then</span>
    <span class="call">XCTAssertEqual</span>(stubSession.<span class="property">lastURL</span>, <span class="type">URL</span>(string: <span class="string">"http://example.com/user"</span>))
    <span class="call">XCTAssertEqual</span>(result.<span class="property">localizedDescription</span>,
                   <span class="string">"The data couldn’t be read because it isn’t in the correct format."</span>)
  }
</code></pre><h2>Step 4: Test The Happy Path</h2><pre><code>   <span class="keyword">func</span> test_loadUser_userInBlock() {
    <span class="comment">// given</span>
    <span class="keyword">let</span> data = <span class="keyword">try</span>! <span class="type">JSONSerialization</span>.<span class="call">data</span>(withJSONObject: [<span class="string">"name"</span>:<span class="string">"dasdom"</span>], options: [])
    <span class="keyword">let</span> stubSession = <span class="type">StubURLSession</span>(data: data, urlResponse: <span class="keyword">nil</span>, error: <span class="keyword">nil</span>, testCase: <span class="keyword">self</span>)
    sut.<span class="property">session</span> = stubSession
    
    <span class="comment">// when</span>
    <span class="keyword">var</span> result: <span class="type">User</span>? = <span class="keyword">nil</span>
    sut.<span class="call">loadUser</span> { user, <span class="keyword">_ in</span>
      result = user
    }
    
    <span class="comment">// then</span>
    <span class="call">XCTAssertEqual</span>(stubSession.<span class="property">lastURL</span>, <span class="type">URL</span>(string: <span class="string">"http://example.com/user"</span>))
    <span class="call">XCTAssertEqual</span>(result, <span class="type">User</span>(name: <span class="string">"dasdom"</span>))
  }
</code></pre><h2>Step 5: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> APIClient: <span class="type">NSObject</span> {
  
  <span class="keyword">lazy var</span> session: <span class="type">DDHURLSessionProtocol</span>? = <span class="type">URLSession</span>.<span class="property">shared</span>
  
  <span class="keyword">func</span> loadUser(completionBlock: <span class="keyword">@escaping</span> (<span class="type">User</span>?, <span class="type">Error</span>?) -&gt; <span class="type">Void</span>) {
    <span class="keyword">guard let</span> url = <span class="type">URL</span>(string: <span class="string">"http://example.com/user"</span>) <span class="keyword">else</span> {
      <span class="call">fatalError</span>()
    }
    
    session?.<span class="call">dataTask</span>(
    with: url) { data, response, error <span class="keyword">in
      
      if let</span> unwrappedError = error {
        <span class="call">completionBlock</span>(<span class="keyword">nil</span>, unwrappedError)
      }
      
      <span class="keyword">guard let</span> data = data <span class="keyword">else</span> { <span class="keyword">return</span> }
      <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">async</span> {
        <span class="keyword">do</span> {
          <span class="keyword">let</span> json = <span class="keyword">try</span> <span class="type">JSONSerialization</span>.<span class="call">jsonObject</span>(with: data, options: [])
          <span class="keyword">if let</span> userData = json <span class="keyword">as</span>? [<span class="type">String</span>:<span class="type">String</span>], <span class="keyword">let</span> userName = userData[<span class="string">"name"</span>] {
            
            <span class="keyword">let</span> user = <span class="type">User</span>(name: userName)
            <span class="call">completionBlock</span>(user, error)
          }
        } <span class="keyword">catch</span> {
          <span class="call">completionBlock</span>(<span class="keyword">nil</span>, error)
        }
      }
      
      }.<span class="call">resume</span>()
  }
}

<span class="keyword">struct</span> User: <span class="type">Equatable</span> {
  <span class="keyword">let</span> name: <span class="type">String</span>
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/networking/chapter096</guid><title>Mocking and Stubbing with URLProtocol</title><description>Test wheather the method `loadUser` fetches data and calls completion closure.</description><link>https://gimmetheco.de/networking/chapter096</link><pubDate>Fri, 16 Oct 2020 01:36:00 +0200</pubDate><content:encoded><![CDATA[<h1>Mocking and Stubbing with URLProtocol</h1><p>Test wheather the method <code>loadUser</code> fetches data and calls completion closure</p><h2>Step 0: Prerequisites</h2><p>Network calls use <code>URLSession.shared</code> or it's possible to inject it as a dependency (see <strong>Dependency Injection</strong>)</p><h2>Step 1: URLProtocol Subclass</h2><pre><code><span class="keyword">class</span> StubURLProtocol: <span class="type">URLProtocol</span> {
  <span class="keyword">private static var</span> dataToBeReturned: [<span class="type">URL</span>:<span class="type">Data</span>] = [:]
  <span class="keyword">private static var</span> errorToBeReturned: <span class="type">Error</span>?
  <span class="keyword">private static var</span> lastRequest: <span class="type">URLRequest</span>?
  <span class="comment">// Test case for expectation management</span>
  <span class="keyword">private static weak var</span> testCase: <span class="type">XCTestCase</span>?
  <span class="comment">// Expectation to wait for asyc call</span>
  <span class="keyword">private static var</span> expectation: <span class="type">XCTestExpectation</span>?
  
  <span class="keyword">class func</span> register(for url: <span class="type">URL</span>, with data: <span class="type">Data</span>? = <span class="keyword">nil</span>, error: <span class="type">Error</span>? = <span class="keyword">nil</span>, in testCase: <span class="type">XCTestCase</span>) {
    
    <span class="keyword">if let</span> unwrappedData = data {
      dataToBeReturned[url] = unwrappedData
    }
    
    <span class="keyword">self</span>.<span class="property">errorToBeReturned</span> = error
    
    <span class="type">StubURLProtocol</span>.<span class="property">testCase</span> = testCase
    <span class="comment">// Create expectation</span>
    <span class="keyword">self</span>.<span class="property">expectation</span> = testCase.<span class="call">expectation</span>(description: <span class="string">"Async"</span>)
    
    <span class="type">URLProtocol</span>.<span class="call">registerClass</span>(<span class="keyword">self</span>.<span class="keyword">self</span>)
  }
  
  <span class="keyword">static var</span> lastURL: <span class="type">URL</span>? {
    <span class="comment">// Wait for the expectation to be</span>
    testCase?.<span class="call">waitForExpectations</span>(timeout: <span class="number">5</span>)
    
    <span class="comment">// Return url of last request</span>
    <span class="keyword">return</span> lastRequest?.<span class="property">url</span>
  }
  
  <span class="keyword">override class func</span> canInit(
    with request: <span class="type">URLRequest</span>) -&gt; <span class="type">Bool</span> {
    
    <span class="comment">// Store last request</span>
    <span class="type">StubURLProtocol</span>.<span class="property">lastRequest</span> = request
    <span class="keyword">return true</span>
  }
  
  <span class="keyword">override class func</span> canonicalRequest(
    for request: <span class="type">URLRequest</span>) -&gt; <span class="type">URLRequest</span> {
    <span class="comment">// Minimal code</span>
    <span class="keyword">return</span> request
  }
  
  <span class="keyword">static func</span> waitForAsync() {
    <span class="comment">// Wait for the expectation</span>
    testCase?.<span class="call">waitForExpectations</span>(timeout: <span class="number">5</span>)
  }
  
  <span class="keyword">override func</span> startLoading() {
    <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">async</span> {
      <span class="comment">// In case of error != nil, return it</span>
      <span class="keyword">if let</span> error =
        <span class="type">StubURLProtocol</span>.<span class="call">errorToBeReturned</span> {
          <span class="keyword">self</span>.<span class="property">client</span>?.<span class="call">urlProtocol</span>(<span class="keyword">self</span>, didFailWithError: error)
      } <span class="keyword">else</span> {
        <span class="comment">// Return the data</span>
        <span class="keyword">let</span> data = <span class="type">StubURLProtocol</span>.<span class="property">dataToBeReturned</span>[<span class="keyword">self</span>.<span class="property">request</span>.<span class="property">url</span>!]!
        <span class="keyword">self</span>.<span class="property">client</span>?.<span class="call">urlProtocol</span>(<span class="keyword">self</span>, didLoad: data)
        <span class="keyword">self</span>.<span class="property">client</span>?.<span class="call">urlProtocolDidFinishLoading</span>(<span class="keyword">self</span>)
      }
      <span class="comment">// Fulfill expectation after a delay</span>
      <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">asyncAfter</span>(deadline: <span class="type">DispatchTime</span>.<span class="call">now</span>() + <span class="number">0.1</span>, execute: {
        <span class="type">StubURLProtocol</span>.<span class="property">expectation</span>?.<span class="call">fulfill</span>()
      })
    }
  }
  
  <span class="keyword">override func</span> stopLoading() {
    <span class="comment">// Minimal code</span>
  }
}
</code></pre><blockquote><p><strong>Note</strong>: There is an <code>XCTestExpectation</code> hidden in <code>StubURLProtocol</code>. Therefore in your test, you need to call <code>StubURLProtocol.lastURL</code> or <code>StubURLProtocol.waitForAsync()</code> <strong>before</strong> you inspect the result.</p></blockquote><h2>Step 2: Test Error Case - URLRequest Returns An Error</h2><pre><code>   <span class="keyword">func</span> test_loadUser_errorInCompletionBlock() {
    <span class="comment">// given</span>
    <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"http://example.com/user"</span>)!
    <span class="keyword">let</span> error = <span class="type">NSError</span>(domain: <span class="string">"FooError"</span>, code: <span class="number">42</span>, userInfo: <span class="keyword">nil</span>)
    
    <span class="type">StubURLProtocol</span>.<span class="call">register</span>(for: url, error: error, in: <span class="keyword">self</span>)
 
    <span class="comment">// when</span>
    <span class="keyword">var</span> result: <span class="type">NSError</span>? = <span class="keyword">nil</span>
    sut.<span class="call">loadUser</span> { <span class="keyword">_</span>, error <span class="keyword">in</span>
      result = error <span class="keyword">as</span> <span class="type">NSError</span>?
    }
 
    <span class="comment">// then</span>
    <span class="call">XCTAssertEqual</span>(<span class="type">StubURLProtocol</span>.<span class="property">lastURL</span>, url)
    <span class="call">XCTAssertEqual</span>(result!, error)
  }
</code></pre><h2>Step 3: Test Error Case - Data Returned Is Not JSON</h2><pre><code>   <span class="keyword">func</span> test_loadUser_errorWhenNotJSON() {
    <span class="comment">// given</span>
    <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"http://example.com/user"</span>)!
    <span class="keyword">let</span> data = <span class="string">"1234"</span>.<span class="call">data</span>(using: .<span class="dotAccess">utf8</span>)
    <span class="type">StubURLProtocol</span>.<span class="call">register</span>(for: url, with: data, in: <span class="keyword">self</span>)
    
    <span class="comment">// when</span>
    <span class="keyword">var</span> result: <span class="type">NSError</span>! = <span class="keyword">nil</span>
    sut.<span class="call">loadUser</span> { <span class="keyword">_</span>, error <span class="keyword">in</span>
      result = error <span class="keyword">as</span> <span class="type">NSError</span>?
    }
 
    <span class="comment">// then</span>
    <span class="call">XCTAssertEqual</span>(<span class="type">StubURLProtocol</span>.<span class="property">lastURL</span>, url)
    <span class="call">XCTAssertEqual</span>(result.<span class="property">localizedDescription</span>,
                   <span class="string">"The data couldn’t be read because it isn’t in the correct format."</span>)
  }
</code></pre><h2>Step 4: Test - Happy Path</h2><pre><code>   <span class="keyword">func</span> test_loadUser_userInBlock() {
    <span class="comment">// given</span>
    <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"http://example.com/user"</span>)!
    <span class="keyword">let</span> data = <span class="keyword">try</span>! <span class="type">JSONSerialization</span>.<span class="call">data</span>(withJSONObject: [<span class="string">"name"</span>:<span class="string">"dasdom"</span>], options: [])
    <span class="type">StubURLProtocol</span>.<span class="call">register</span>(for: url, with: data, in: <span class="keyword">self</span>)
    
    <span class="comment">// when</span>
    <span class="keyword">var</span> result: <span class="type">User</span>? = <span class="keyword">nil</span>
    sut.<span class="call">loadUser</span> { user, <span class="keyword">_ in</span>
      result = user
    }
    
    <span class="comment">// then</span>
    <span class="call">XCTAssertEqual</span>(<span class="type">StubURLProtocol</span>.<span class="property">lastURL</span>, url)
    <span class="call">XCTAssertEqual</span>(result, <span class="type">User</span>(name: <span class="string">"dasdom"</span>))
  }
</code></pre><h2>Step 5: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> APIClient: <span class="type">NSObject</span> {
  
  <span class="keyword">func</span> loadUser(completionBlock: <span class="keyword">@escaping</span> (<span class="type">User</span>?, <span class="type">Error</span>?) -&gt; <span class="type">Void</span>) {
    
    <span class="keyword">guard let</span> url = <span class="type">URL</span>(string: <span class="string">"http://example.com/user"</span>) <span class="keyword">else</span> {
      <span class="call">fatalError</span>()
    }
    
    <span class="type">URLSession</span>.<span class="property">shared</span>.<span class="call">dataTask</span>(
    with: url) { data, response, error <span class="keyword">in
      
      if let</span> unwrappedError = error {
        <span class="call">completionBlock</span>(<span class="keyword">nil</span>, unwrappedError)
      }
      
      <span class="keyword">guard let</span> data = data <span class="keyword">else</span> { <span class="keyword">return</span> }
      <span class="type">DispatchQueue</span>.<span class="property">main</span>.<span class="call">async</span> {
        <span class="keyword">do</span> {
          <span class="keyword">let</span> json = <span class="keyword">try</span> <span class="type">JSONSerialization</span>.<span class="call">jsonObject</span>(with: data, options: [])
          <span class="keyword">if let</span> userData = json <span class="keyword">as</span>? [<span class="type">String</span>:<span class="type">String</span>], <span class="keyword">let</span> userName = userData[<span class="string">"name"</span>] {
            
            <span class="keyword">let</span> user = <span class="type">User</span>(name: userName)
            <span class="call">completionBlock</span>(user, error)
          }
        } <span class="keyword">catch</span> {
          <span class="call">completionBlock</span>(<span class="keyword">nil</span>, error)
        }
      }
      }.<span class="call">resume</span>()
  }
}

<span class="keyword">struct</span> User: <span class="type">Equatable</span> {
  <span class="keyword">let</span> name: <span class="type">String</span>
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uicollectionviewcomposionallayout/chapter082</guid><title>Populate a Custom Collection View Compositional Layout List Cell</title><description>Test whether a list cell in the collection view compositional list layout is populated with data.</description><link>https://gimmetheco.de/uicollectionviewcomposionallayout/chapter082</link><pubDate>Fri, 16 Oct 2020 01:22:00 +0200</pubDate><content:encoded><![CDATA[<h1>Populate a Custom Collection View Compositional Layout List Cell</h1><p>Test whether a custom list cell in the collection view compositional list layout is populated with data</p><h2>Step 1: Test</h2><pre><code><span class="keyword">func</span> test_cellForItem_returnsConfiguresCell() {
  <span class="comment">// given</span>
  <span class="keyword">let</span> item = <span class="type">Item</span>(category: .<span class="dotAccess">music</span>, title: <span class="string">"Foo"</span>, description: <span class="string">"Bar"</span>)
  sut.<span class="property">items</span> = [item]
  sut.<span class="call">loadViewIfNeeded</span>()
  
  <span class="comment">// when</span>
  <span class="keyword">let</span> indexPath = <span class="type">IndexPath</span>(item: <span class="number">0</span>, section: <span class="number">0</span>)
  <span class="keyword">let</span> cell = sut.<span class="property">collectionView</span>.<span class="property">dataSource</span>?.<span class="call">collectionView</span>(sut.<span class="property">collectionView</span>, cellForItemAt: indexPath) <span class="keyword">as</span>! <span class="type">CustomListCell</span>
  
  <span class="comment">// then</span>
  <span class="keyword">let</span> listContentConfiguration = cell.<span class="property">listContentView</span>.<span class="property">configuration</span> <span class="keyword">as</span>! <span class="type">UIListContentConfiguration</span>
  <span class="call">XCTAssertEqual</span>(listContentConfiguration.<span class="property">text</span>, item.<span class="property">title</span>)
}
</code></pre><h2>Step 2: Example code that lets the test pass</h2><p>This code is taken from the sample project provided by Apple for the WWDC20.</p><p>Licence:</p><blockquote><p>Apple, iPhone, iMac, iPad Pro, Apple Pencil, Apple Watch, App Store, TestFlight, Siri, and SiriKit are trademarks of Apple, Inc. The following license applies to the source code, and other elements of this package: Copyright © 2020 Apple Inc. Changes by Dominik Hauser (@dasdom). Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p></blockquote><pre><code><span class="keyword">private enum</span> Section: <span class="type">Hashable</span> {
  <span class="keyword">case</span> main
}

<span class="keyword">struct</span> Category: <span class="type">Hashable</span> {
  <span class="keyword">let</span> icon: <span class="type">UIImage</span>?
  <span class="keyword">let</span> name: <span class="type">String</span>?
  
  <span class="keyword">static let</span> music = <span class="type">Category</span>(icon: <span class="type">UIImage</span>(systemName: <span class="string">"music.mic"</span>), name: <span class="string">"Music"</span>)
  <span class="keyword">static let</span> transportation = <span class="type">Category</span>(icon: <span class="type">UIImage</span>(systemName: <span class="string">"car"</span>), name: <span class="string">"Transportation"</span>)
  <span class="keyword">static let</span> weather = <span class="type">Category</span>(icon: <span class="type">UIImage</span>(systemName: <span class="string">"cloud.rain"</span>), name: <span class="string">"Weather"</span>)
}

<span class="keyword">struct</span> Item: <span class="type">Hashable</span> {
  <span class="keyword">let</span> category: <span class="type">Category</span>
  <span class="keyword">let</span> image: <span class="type">UIImage</span>?
  <span class="keyword">let</span> title: <span class="type">String</span>?
  <span class="keyword">let</span> description: <span class="type">String</span>?
  
  <span class="keyword">init</span>(category: <span class="type">Category</span>, imageName: <span class="type">String</span>? = <span class="keyword">nil</span>, title: <span class="type">String</span>? = <span class="keyword">nil</span>, description: <span class="type">String</span>? = <span class="keyword">nil</span>) {
    <span class="keyword">self</span>.<span class="property">category</span> = category
    <span class="keyword">if let</span> systemName = imageName {
      <span class="keyword">self</span>.<span class="property">image</span> = <span class="type">UIImage</span>(systemName: systemName)
    } <span class="keyword">else</span> {
      <span class="keyword">self</span>.<span class="property">image</span> = <span class="keyword">nil</span>
    }
    <span class="keyword">self</span>.<span class="property">title</span> = title
    <span class="keyword">self</span>.<span class="property">description</span> = description
  }
}

<span class="keyword">class</span> CustomCellListViewController: <span class="type">UIViewController</span> {
  
  <span class="keyword">private var</span> dataSource: <span class="type">UICollectionViewDiffableDataSource</span>&lt;<span class="type">Section</span>, <span class="type">Item</span>&gt;!
  <span class="keyword">private(set) var</span> collectionView: <span class="type">UICollectionView</span>!
  <span class="keyword">lazy var</span> items: [<span class="type">Item</span>] = []
  
  <span class="keyword">override func</span> viewDidLoad() {
    <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
    
    navigationItem.<span class="property">title</span> = <span class="string">"List with Custom Cells"</span>
    
    <span class="call">configureHierarchy</span>()
    <span class="call">configureDataSource</span>()
  }
}

<span class="keyword">extension</span> <span class="type">CustomCellListViewController</span> {
  <span class="keyword">private func</span> createLayout() -&gt; <span class="type">UICollectionViewLayout</span> {
    <span class="keyword">let</span> config = <span class="type">UICollectionLayoutListConfiguration</span>(appearance: .<span class="dotAccess">plain</span>)
    <span class="keyword">return</span> <span class="type">UICollectionViewCompositionalLayout</span>.<span class="call">list</span>(using: config)
  }
}

<span class="keyword">extension</span> <span class="type">CustomCellListViewController</span> {
  <span class="keyword">private func</span> configureHierarchy() {
    collectionView = <span class="type">UICollectionView</span>(frame: view.<span class="property">bounds</span>, collectionViewLayout: <span class="call">createLayout</span>())
    collectionView.<span class="property">autoresizingMask</span> = [.<span class="dotAccess">flexibleWidth</span>, .<span class="dotAccess">flexibleHeight</span>]
    view.<span class="call">addSubview</span>(collectionView)
  }
  <span class="keyword">private func</span> configureDataSource() {
    
    <span class="keyword">let</span> cellRegistration = <span class="type">UICollectionView</span>.<span class="type">CellRegistration</span>&lt;<span class="type">CustomListCell</span>, <span class="type">Item</span>&gt; { (cell, indexPath, item) <span class="keyword">in</span>
      cell.<span class="call">updateWithItem</span>(item)
      cell.<span class="property">accessories</span> = [.<span class="call">disclosureIndicator</span>()]
    }
    
    dataSource = <span class="type">UICollectionViewDiffableDataSource</span>&lt;<span class="type">Section</span>, <span class="type">Item</span>&gt;(collectionView: collectionView) {
      (collectionView: <span class="type">UICollectionView</span>, indexPath: <span class="type">IndexPath</span>, item: <span class="type">Item</span>) -&gt; <span class="type">UICollectionViewCell</span>? <span class="keyword">in
      
      return</span> collectionView.<span class="call">dequeueConfiguredReusableCell</span>(using: cellRegistration, for: indexPath, item: item)
    }
    
    <span class="comment">// initial data</span>
    <span class="keyword">var</span> snapshot = <span class="type">NSDiffableDataSourceSnapshot</span>&lt;<span class="type">Section</span>, <span class="type">Item</span>&gt;()
    snapshot.<span class="call">appendSections</span>([.<span class="dotAccess">main</span>])
    snapshot.<span class="call">appendItems</span>(items)
    dataSource.<span class="call">apply</span>(snapshot, animatingDifferences: <span class="keyword">false</span>)
  }
}

<span class="comment">// Declare a custom key for a custom `item` property.</span>
<span class="keyword">fileprivate extension</span> <span class="type">UIConfigurationStateCustomKey</span> {
  <span class="keyword">static let</span> item = <span class="type">UIConfigurationStateCustomKey</span>(<span class="string">"com.apple.ItemListCell.item"</span>)
}

<span class="comment">// Declare an extension on the cell state struct to provide a typed property for this custom state.</span>
<span class="keyword">private extension</span> <span class="type">UICellConfigurationState</span> {
  <span class="keyword">var</span> item: <span class="type">Item</span>? {
    <span class="keyword">set</span> { <span class="keyword">self</span>[.<span class="dotAccess">item</span>] = newValue }
    <span class="keyword">get</span> { <span class="keyword">return self</span>[.<span class="dotAccess">item</span>] <span class="keyword">as</span>? <span class="type">Item</span> }
  }
}

<span class="comment">// This list cell subclass is an abstract class with a property that holds the item the cell is displaying,
// which is added to the cell's configuration state for subclasses to use when updating their configuration.</span>
<span class="keyword">private class</span> ItemListCell: <span class="type">UICollectionViewListCell</span> {
  <span class="keyword">private var</span> item: <span class="type">Item</span>? = <span class="keyword">nil
  
  func</span> updateWithItem(<span class="keyword">_</span> newItem: <span class="type">Item</span>) {
    <span class="keyword">guard</span> item != newItem <span class="keyword">else</span> { <span class="keyword">return</span> }
    item = newItem
    <span class="call">setNeedsUpdateConfiguration</span>()
  }
  
  <span class="keyword">override var</span> configurationState: <span class="type">UICellConfigurationState</span> {
    <span class="keyword">var</span> state = <span class="keyword">super</span>.<span class="property">configurationState</span>
    state.<span class="property">item</span> = <span class="keyword">self</span>.<span class="property">item</span>
    <span class="keyword">return</span> state
  }
}

<span class="keyword">private class</span> CustomListCell: <span class="type">ItemListCell</span> {
  
  <span class="keyword">private func</span> defaultListContentConfiguration() -&gt; <span class="type">UIListContentConfiguration</span> {
    <span class="keyword">return</span> .<span class="call">subtitleCell</span>()
  }
  <span class="keyword">private(set) lazy var</span> listContentView = <span class="type">UIListContentView</span>(configuration: <span class="call">defaultListContentConfiguration</span>())
  
  <span class="keyword">private let</span> categoryIconView = <span class="type">UIImageView</span>()
  <span class="keyword">private let</span> categoryLabel = <span class="type">UILabel</span>()
  <span class="keyword">private var</span> customViewConstraints: (categoryLabelLeading: <span class="type">NSLayoutConstraint</span>,
                                      categoryLabelTrailing: <span class="type">NSLayoutConstraint</span>,
                                      categoryIconTrailing: <span class="type">NSLayoutConstraint</span>)?
  
  <span class="keyword">private func</span> setupViewsIfNeeded() {
    <span class="comment">// We only need to do anything if we haven't already setup the views and created constraints.</span>
    <span class="keyword">guard</span> customViewConstraints == <span class="keyword">nil else</span> { <span class="keyword">return</span> }
    
    contentView.<span class="call">addSubview</span>(listContentView)
    contentView.<span class="call">addSubview</span>(categoryLabel)
    contentView.<span class="call">addSubview</span>(categoryIconView)
    listContentView.<span class="property">translatesAutoresizingMaskIntoConstraints</span> = <span class="keyword">false</span>
    categoryLabel.<span class="property">translatesAutoresizingMaskIntoConstraints</span> = <span class="keyword">false</span>
    categoryIconView.<span class="property">translatesAutoresizingMaskIntoConstraints</span> = <span class="keyword">false
    let</span> constraints = (
      categoryLabelLeading: categoryLabel.<span class="property">leadingAnchor</span>.<span class="call">constraint</span>(equalTo: listContentView.<span class="property">trailingAnchor</span>),
      categoryLabelTrailing: categoryIconView.<span class="property">leadingAnchor</span>.<span class="call">constraint</span>(equalTo: categoryLabel.<span class="property">trailingAnchor</span>),
      categoryIconTrailing: contentView.<span class="property">trailingAnchor</span>.<span class="call">constraint</span>(equalTo: categoryIconView.<span class="property">trailingAnchor</span>)
    )
    <span class="type">NSLayoutConstraint</span>.<span class="call">activate</span>([
      listContentView.<span class="property">topAnchor</span>.<span class="call">constraint</span>(equalTo: contentView.<span class="property">topAnchor</span>),
      listContentView.<span class="property">bottomAnchor</span>.<span class="call">constraint</span>(equalTo: contentView.<span class="property">bottomAnchor</span>),
      listContentView.<span class="property">leadingAnchor</span>.<span class="call">constraint</span>(equalTo: contentView.<span class="property">leadingAnchor</span>),
      categoryLabel.<span class="property">centerYAnchor</span>.<span class="call">constraint</span>(equalTo: contentView.<span class="property">centerYAnchor</span>),
      categoryIconView.<span class="property">centerYAnchor</span>.<span class="call">constraint</span>(equalTo: contentView.<span class="property">centerYAnchor</span>),
      constraints.<span class="property">categoryLabelLeading</span>,
      constraints.<span class="property">categoryLabelTrailing</span>,
      constraints.<span class="property">categoryIconTrailing</span>
    ])
    customViewConstraints = constraints
  }
  
  <span class="keyword">override func</span> updateConfiguration(using state: <span class="type">UICellConfigurationState</span>) {
    <span class="call">setupViewsIfNeeded</span>()
    
    <span class="comment">// Configure the list content configuration and apply that to the list content view.</span>
    <span class="keyword">var</span> content = <span class="call">defaultListContentConfiguration</span>().<span class="call">updated</span>(for: state)
    content.<span class="property">imageProperties</span>.<span class="property">preferredSymbolConfiguration</span> = .<span class="keyword">init</span>(font: content.<span class="property">textProperties</span>.<span class="property">font</span>, scale: .<span class="dotAccess">large</span>)
    content.<span class="property">image</span> = state.<span class="property">item</span>?.<span class="property">image</span>
    content.<span class="property">text</span> = state.<span class="property">item</span>?.<span class="property">title</span>
    content.<span class="property">secondaryText</span> = state.<span class="property">item</span>?.<span class="property">description</span>
    content.<span class="property">axesPreservingSuperviewLayoutMargins</span> = []
    listContentView.<span class="property">configuration</span> = content
    
    <span class="comment">// Get the list value cell configuration for the current state, which we'll use to obtain the system default
    // styling and metrics to copy to our custom views.</span>
    <span class="keyword">let</span> valueConfiguration = <span class="type">UIListContentConfiguration</span>.<span class="call">valueCell</span>().<span class="call">updated</span>(for: state)
    
    <span class="comment">// Configure custom image view for the category icon, copying some of the styling from the value cell configuration.</span>
    categoryIconView.<span class="property">image</span> = state.<span class="property">item</span>?.<span class="property">category</span>.<span class="property">icon</span>
    categoryIconView.<span class="property">tintColor</span> = valueConfiguration.<span class="property">imageProperties</span>.<span class="call">resolvedTintColor</span>(for: tintColor)
    categoryIconView.<span class="property">preferredSymbolConfiguration</span> = .<span class="keyword">init</span>(font: valueConfiguration.<span class="property">secondaryTextProperties</span>.<span class="property">font</span>, scale: .<span class="dotAccess">small</span>)
    
    <span class="comment">// Configure custom label for the category name, copying some of the styling from the value cell configuration.</span>
    categoryLabel.<span class="property">text</span> = state.<span class="property">item</span>?.<span class="property">category</span>.<span class="property">name</span>
    categoryLabel.<span class="property">textColor</span> = valueConfiguration.<span class="property">secondaryTextProperties</span>.<span class="call">resolvedColor</span>()
    categoryLabel.<span class="property">font</span> = valueConfiguration.<span class="property">secondaryTextProperties</span>.<span class="property">font</span>
    categoryLabel.<span class="property">adjustsFontForContentSizeCategory</span> = valueConfiguration.<span class="property">secondaryTextProperties</span>.<span class="property">adjustsFontForContentSizeCategory</span>
    
    <span class="comment">// Update some of the constraints for our custom views using the system default metrics from the configurations.</span>
    customViewConstraints?.<span class="property">categoryLabelLeading</span>.<span class="property">constant</span> = content.<span class="property">directionalLayoutMargins</span>.<span class="property">trailing</span>
    customViewConstraints?.<span class="property">categoryLabelTrailing</span>.<span class="property">constant</span> = valueConfiguration.<span class="property">textToSecondaryTextHorizontalPadding</span>
    customViewConstraints?.<span class="property">categoryIconTrailing</span>.<span class="property">constant</span> = content.<span class="property">directionalLayoutMargins</span>.<span class="property">trailing</span>
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uicollectionviewcomposionallayout/chapter081</guid><title>Populate a Collection View Compositional Layout List Cell</title><description>Test whether a list cell in the collection view compositional list layout is populated with data.</description><link>https://gimmetheco.de/uicollectionviewcomposionallayout/chapter081</link><pubDate>Fri, 16 Oct 2020 01:21:00 +0200</pubDate><content:encoded><![CDATA[<h1>Populate a Collection View Compositional Layout List Cell</h1><p>Test whether a list cell in the collection view compositional list layout is populated with data</p><h2>Step 1: Test</h2><pre><code><span class="keyword">func</span> test_cellForItem_returnsPopulatedCell() {
  <span class="comment">// given</span>
  sut.<span class="property">names</span> = [<span class="string">"foobar"</span>]
  <span class="keyword">let</span> window = <span class="type">UIWindow</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">200</span>, height: <span class="number">200</span>))
  window.<span class="property">rootViewController</span> = sut
  window.<span class="call">makeKeyAndVisible</span>()
  
  <span class="comment">// when</span>
  <span class="keyword">let</span> indexPath = <span class="type">IndexPath</span>(item: <span class="number">0</span>, section: <span class="number">0</span>)
  <span class="keyword">let</span> cell = sut.<span class="property">collectionView</span>.<span class="property">dataSource</span>?.<span class="call">collectionView</span>(sut.<span class="property">collectionView</span>, cellForItemAt: indexPath) <span class="keyword">as</span>! <span class="type">UICollectionViewListCell</span>

  <span class="comment">// then</span>
  <span class="keyword">let</span> contentConfiguration = cell.<span class="property">contentConfiguration</span> <span class="keyword">as</span>! <span class="type">UIListContentConfiguration</span>
  <span class="call">XCTAssertEqual</span>(contentConfiguration.<span class="property">text</span>, sut.<span class="property">names</span>.<span class="property">first</span>)
}
</code></pre><h2>Step 2: Example code that makes the test pass</h2><p>This code is taken from the sample project provided by Apple for the WWDC20.</p><p>Licence:</p><blockquote><p>Apple, iPhone, iMac, iPad Pro, Apple Pencil, Apple Watch, App Store, TestFlight, Siri, and SiriKit are trademarks of Apple, Inc. The following license applies to the source code, and other elements of this package: Copyright © 2020 Apple Inc. Changes by Dominik Hauser (@dasdom). Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p></blockquote><pre><code><span class="keyword">class</span> SimpleListViewController: <span class="type">UIViewController</span> {
  
  <span class="keyword">enum</span> Section {
    <span class="keyword">case</span> main
  }
  
  <span class="keyword">var</span> dataSource: <span class="type">UICollectionViewDiffableDataSource</span>&lt;<span class="type">Section</span>, <span class="type">String</span>&gt;! = <span class="keyword">nil
  var</span> collectionView: <span class="type">UICollectionView</span>! = <span class="keyword">nil
  var</span> names: [<span class="type">String</span>] = []
  
  <span class="keyword">override func</span> viewDidLoad() {
    <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
    
    navigationItem.<span class="property">title</span> = <span class="string">"List"</span>
    
    <span class="call">configureHierarchy</span>()
    <span class="call">configureDataSource</span>()
  }
}

<span class="keyword">extension</span> <span class="type">SimpleListViewController</span> {
  <span class="keyword">private func</span> createLayout() -&gt; <span class="type">UICollectionViewLayout</span> {
    <span class="keyword">let</span> config = <span class="type">UICollectionLayoutListConfiguration</span>(appearance: .<span class="dotAccess">insetGrouped</span>)
    <span class="keyword">return</span> <span class="type">UICollectionViewCompositionalLayout</span>.<span class="call">list</span>(using: config)
  }
}

<span class="keyword">extension</span> <span class="type">SimpleListViewController</span> {
  <span class="keyword">private func</span> configureHierarchy() {
    collectionView = <span class="type">UICollectionView</span>(frame: view.<span class="property">bounds</span>, collectionViewLayout: <span class="call">createLayout</span>())
    collectionView.<span class="property">autoresizingMask</span> = [.<span class="dotAccess">flexibleWidth</span>, .<span class="dotAccess">flexibleHeight</span>]
    view.<span class="call">addSubview</span>(collectionView)
  }
  
  <span class="keyword">private func</span> configureDataSource() {
    
    <span class="keyword">let</span> cellRegistration = <span class="type">UICollectionView</span>.<span class="type">CellRegistration</span>&lt;<span class="type">UICollectionViewListCell</span>, <span class="type">String</span>&gt; { (cell, indexPath, item) <span class="keyword">in
      var</span> content = cell.<span class="call">defaultContentConfiguration</span>()
      content.<span class="property">text</span> = item
      cell.<span class="property">contentConfiguration</span> = content
      }
    
    dataSource = <span class="type">UICollectionViewDiffableDataSource</span>&lt;<span class="type">Section</span>, <span class="type">String</span>&gt;(collectionView: collectionView) { (collectionView: <span class="type">UICollectionView</span>, indexPath: <span class="type">IndexPath</span>, name: <span class="type">String</span>) -&gt; <span class="type">UICollectionViewCell</span>? <span class="keyword">in
      
      return</span> collectionView.<span class="call">dequeueConfiguredReusableCell</span>(using: cellRegistration, for: indexPath, item: name)
    }
    
    <span class="comment">// initial data</span>
    <span class="keyword">var</span> snapshot = <span class="type">NSDiffableDataSourceSnapshot</span>&lt;<span class="type">Section</span>, <span class="type">String</span>&gt;()
    snapshot.<span class="call">appendSections</span>([.<span class="dotAccess">main</span>])
    snapshot.<span class="call">appendItems</span>(names)
    dataSource.<span class="call">apply</span>(snapshot, animatingDifferences: <span class="keyword">false</span>)
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uicollectionviewdelegate/chapter079</guid><title>Flow Layout Minimum Line Spacing</title><description>Test the value of minimumLineSpacing of a flow layout.</description><link>https://gimmetheco.de/uicollectionviewdelegate/chapter079</link><pubDate>Fri, 16 Oct 2020 01:19:00 +0200</pubDate><content:encoded><![CDATA[<h1>Flow Layout Minimum Line Spacing</h1><p>Test the value of minimumLineSpacing of a flow layout</p><h2>Step 1: Test</h2><pre><code><span class="keyword">func</span> test_layout_hasMinimalLineSpacing() {
  <span class="comment">// when</span>
  <span class="keyword">let</span> minimumLineSpacing = sut.<span class="property">minimumLineSpacing</span>
  
  <span class="comment">// then</span>
  <span class="call">XCTAssertEqual</span>(minimumLineSpacing, <span class="number">23</span>)
}
</code></pre><h2>Step 2: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> CollectionCoordinator : <span class="type">NSObject</span> {
  
  <span class="keyword">let</span> navController : <span class="type">UINavigationController</span>
  
  <span class="keyword">init</span>(navController: <span class="type">UINavigationController</span>) {
    <span class="keyword">self</span>.<span class="property">navController</span> = navController
    <span class="keyword">super</span>.<span class="keyword">init</span>()
  }
  
  <span class="keyword">func</span> start() {
    
    <span class="keyword">let</span> layout = <span class="type">UICollectionViewFlowLayout</span>()
    layout.<span class="property">minimumLineSpacing</span> = <span class="number">23</span>
    <span class="keyword">let</span> collectionViewController = <span class="type">UICollectionViewController</span>(collectionViewLayout: layout)
    
    <span class="keyword">self</span>.<span class="property">navController</span>.<span class="call">pushViewController</span>(collectionViewController, animated: <span class="keyword">false</span>)
  }
}
</code></pre><blockquote><p>In the same way you can test the properties <code>minimumInteritemSpacing</code>, <code>itemSize</code>, <code>estimatedItemSize</code>, <code>sectionInset</code>, <code>sectionInsetReference</code>, <code>headerReferenceSize</code>, <code>footerReferenceSize</code>, <code>sectionHeadersPinToVisibleBounds</code> and <code>sectionFootersPinToVisibleBounds</code>.</p></blockquote>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uicollectionviewdelegate/chapter078</guid><title>Selection Of Cells</title><description>Test whether selection of a cell results in a controller being pushed onto the navigation stack.</description><link>https://gimmetheco.de/uicollectionviewdelegate/chapter078</link><pubDate>Fri, 16 Oct 2020 01:18:00 +0200</pubDate><content:encoded><![CDATA[<h1>Selection Of Cells</h1><p>Test whether selection of a cell results in a controller being pushed onto the navigation stack</p><h2>Step 1: Navigation Controller Mock</h2><pre><code><span class="keyword">class</span> NavigationControllerMock: <span class="type">UINavigationController</span> {
  
  <span class="keyword">var</span> lastPushedVC: <span class="type">UIViewController</span>?
  
  <span class="keyword">override func</span> pushViewController(<span class="keyword">_</span> viewController: <span class="type">UIViewController</span>, animated: <span class="type">Bool</span>) {
    lastPushedVC = viewController
    <span class="keyword">super</span>.<span class="call">pushViewController</span>(viewController, animated: animated)
  }
}
</code></pre><h2>Step 2: Test</h2><pre><code><span class="keyword">func</span> test_selectingCell_pushesController() {
  <span class="comment">// given</span>
  <span class="keyword">let</span> user = <span class="type">User</span>(name: <span class="string">"Foo"</span>)
  sut.<span class="property">users</span> = [user]
  <span class="keyword">let</span> navController = <span class="type">NavigationControllerMock</span>(rootViewController: sut)
  
  <span class="comment">// when</span>
  <span class="keyword">let</span> indexPath = <span class="type">IndexPath</span>(row: <span class="number">0</span>, section: <span class="number">0</span>)
  sut.<span class="call">collectionView</span>(sut.<span class="property">collectionView</span>, didSelectItemAt: indexPath)
  
  <span class="comment">// then</span>
  <span class="keyword">let</span> pushedVC = navController.<span class="property">lastPushedVC</span> <span class="keyword">as</span>? <span class="type">DetailViewController</span>
  <span class="call">XCTAssertNotNil</span>(pushedVC)
  <span class="call">XCTAssertEqual</span>(pushedVC?.<span class="property">user</span>, user)
}
</code></pre><h2>Step 3: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> CollectionViewController: <span class="type">UICollectionViewController</span> {
  
  <span class="keyword">var</span> users : [<span class="type">User</span>] = []
  
  <span class="keyword">override func</span> collectionView(<span class="keyword">_</span> collectionView: <span class="type">UICollectionView</span>, didSelectItemAt indexPath: <span class="type">IndexPath</span>) {
    
    <span class="keyword">let</span> user = users[indexPath.<span class="property">item</span>]
    <span class="keyword">let</span> detailViewController = <span class="type">DetailViewController</span>(user: user)
    
    navigationController?.<span class="call">pushViewController</span>(detailViewController, animated: <span class="keyword">true</span>)
  }
}

<span class="keyword">class</span> DetailViewController: <span class="type">UIViewController</span> {
  
  <span class="keyword">let</span> user: <span class="type">User</span>
  
  <span class="keyword">init</span>(user: <span class="type">User</span>) {
    
    <span class="keyword">self</span>.<span class="property">user</span> = user
    
    <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="keyword">nil</span>, bundle: <span class="keyword">nil</span>)
  }
  
  <span class="keyword">required init</span>?(coder aDecoder: <span class="type">NSCoder</span>) {
    <span class="call">fatalError</span>(<span class="string">"not been implemented"</span>)
  }
}

<span class="keyword">struct</span> User: <span class="type">Equatable</span> {
  <span class="keyword">let</span> name: <span class="type">String</span>
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uicollectionviewdelegate/chapter077</guid><title>Should Select Item</title><description>Test whether shouldSelectItemAt returns expected value.</description><link>https://gimmetheco.de/uicollectionviewdelegate/chapter077</link><pubDate>Fri, 16 Oct 2020 01:17:00 +0200</pubDate><content:encoded><![CDATA[<h1>Should Select Item</h1><p>Test whether shouldSelectItemAt returns expected value</p><h2>Step 1: Test</h2><pre><code><span class="keyword">func</span> test_shouldSelectItem_even() {
  <span class="comment">// when</span>
  <span class="keyword">let</span> collectionView = <span class="type">UICollectionView</span>(frame: .<span class="dotAccess">zero</span>, collectionViewLayout: <span class="type">UICollectionViewFlowLayout</span>())
  <span class="keyword">let</span> indexPath = <span class="type">IndexPath</span>(item: <span class="number">2</span>, section: <span class="number">0</span>)
  <span class="keyword">let</span> result = sut.<span class="call">collectionView</span>(collectionView, shouldSelectItemAt: indexPath)
  
  <span class="comment">// then</span>
  <span class="call">XCTAssertEqual</span>(result, <span class="keyword">false</span>)
}
</code></pre><h2>Step 2: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> CollectionViewDelegate: <span class="type">NSObject</span>, <span class="type">UICollectionViewDelegate</span> {
  
  <span class="keyword">func</span> collectionView(<span class="keyword">_</span> collectionView: <span class="type">UICollectionView</span>, shouldSelectItemAt indexPath: <span class="type">IndexPath</span>) -&gt; <span class="type">Bool</span> {
    <span class="keyword">let</span> itemEven = indexPath.<span class="property">item</span> % <span class="number">2</span> == <span class="number">0</span>
    <span class="keyword">return</span> itemEven ? false : <span class="keyword">true</span>
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uicollectionviewdatasource/chapter075</guid><title>Setup Supplementary View</title><description>Test wheather a setup method of a supplementary view is called.</description><link>https://gimmetheco.de/uicollectionviewdatasource/chapter075</link><pubDate>Fri, 16 Oct 2020 01:15:00 +0200</pubDate><content:encoded><![CDATA[<h1>Setup Supplementary View</h1><p>Test wheather a setup method of a supplementary view is called</p><h2>Step 1: Protocol</h2><pre><code><span class="keyword">protocol</span> SupplementaryViewProtocol {
  <span class="keyword">func</span> setup(with: <span class="type">Group</span>)
}
</code></pre><h2>Step 2: Supplementary View Mock</h2><pre><code><span class="keyword">class</span> MockSupplementaryView: <span class="type">UICollectionReusableView</span>, <span class="type">SupplementaryViewProtocol</span> {
  
  <span class="keyword">var</span> lastSetupGroup: <span class="type">Group</span>?
  
  <span class="keyword">func</span> setup(with group: <span class="type">Group</span>) {
    lastSetupGroup = group
  }
}
</code></pre><h2>Step 3: Test</h2><pre><code><span class="keyword">func</span> test_viewForSupplementary_setsUpView() {
  <span class="comment">// given</span>
  collectionView.<span class="call">register</span>(<span class="type">MockSupplementaryView</span>.<span class="keyword">self</span>, forSupplementaryViewOfKind: <span class="type">UICollectionView</span>.<span class="property">elementKindSectionHeader</span>, withReuseIdentifier: <span class="string">"Header"</span>)
  <span class="keyword">let</span> group = <span class="type">Group</span>(name: <span class="string">"Friends"</span>)
  sut.<span class="property">groups</span> = [group]
  
  <span class="comment">// when</span>
  <span class="keyword">let</span> indexPath = <span class="type">IndexPath</span>(item: <span class="number">0</span>, section: <span class="number">0</span>)
  <span class="keyword">let</span> supplView = collectionView.<span class="property">dataSource</span>?.<span class="property">collectionView</span>?(collectionView, viewForSupplementaryElementOfKind: <span class="type">UICollectionView</span>.<span class="property">elementKindSectionHeader</span>, at: indexPath) <span class="keyword">as</span>! <span class="type">MockSupplementaryView</span>
  
  <span class="comment">// then</span>
  <span class="call">XCTAssertEqual</span>(supplView.<span class="property">lastSetupGroup</span>, group)
}
</code></pre><h2>Step 4: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> CollectionViewDataSource: <span class="type">NSObject</span>, <span class="type">UICollectionViewDataSource</span> {
  
  <span class="keyword">var</span> groups: [<span class="type">Group</span>] = []
  
  <span class="keyword">func</span> collectionView(<span class="keyword">_</span> collectionView: <span class="type">UICollectionView</span>, numberOfItemsInSection section: <span class="type">Int</span>) -&gt; <span class="type">Int</span> {
    <span class="keyword">return</span> <span class="number">0</span>
  }
  
  <span class="keyword">func</span> collectionView(<span class="keyword">_</span> collectionView: <span class="type">UICollectionView</span>, cellForItemAt indexPath: <span class="type">IndexPath</span>) -&gt; <span class="type">UICollectionViewCell</span> {
    <span class="keyword">return</span> <span class="type">UICollectionViewCell</span>()
  }
}

<span class="keyword">struct</span> Group : <span class="type">Equatable</span> {
  <span class="keyword">let</span> name: <span class="type">String</span>
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uicollectionviewdatasource/chapter074</guid><title>Setup Cell</title><description>Test wheather a setup method of a cell is called.</description><link>https://gimmetheco.de/uicollectionviewdatasource/chapter074</link><pubDate>Fri, 16 Oct 2020 01:14:00 +0200</pubDate><content:encoded><![CDATA[<h1>Setup Cell</h1><p>Test wheather a setup method of a cell is called</p><h2>Step 1: Protocol</h2><pre><code><span class="keyword">protocol</span> CollectionViewCellProtocol {
  <span class="keyword">func</span> setup(with: <span class="type">User</span>)
}
</code></pre><h2>Step 2: Collection View Cell Mock</h2><pre><code><span class="keyword">class</span> MockCollectionViewCell: <span class="type">UICollectionViewCell</span>, <span class="type">CollectionViewCellProtocol</span> {
  
  <span class="keyword">var</span> lastSetupUser: <span class="type">User</span>?
  
  <span class="keyword">func</span> setup(with user: <span class="type">User</span>) {
    lastSetupUser = user
  }
}
</code></pre><h2>Step 3: Test</h2><pre><code><span class="keyword">func</span> test_cellForItem_setsUpTheCell() {
  <span class="comment">// given</span>
  collectionView.<span class="call">register</span>(<span class="type">MockCollectionViewCell</span>.<span class="keyword">self</span>, forCellWithReuseIdentifier: <span class="string">"Cell"</span>)
  <span class="keyword">let</span> user = <span class="type">User</span>(name: <span class="string">"Foo"</span>)
  sut.<span class="property">users</span> = [user]
  
  <span class="comment">// when</span>
  <span class="keyword">let</span> indexPath = <span class="type">IndexPath</span>(item: <span class="number">0</span>, section: <span class="number">0</span>)
  <span class="keyword">let</span> cell = collectionView.<span class="property">dataSource</span>?.<span class="call">collectionView</span>(collectionView, cellForItemAt: indexPath) <span class="keyword">as</span>! <span class="type">MockCollectionViewCell</span>
  
  <span class="comment">// then</span>
  <span class="call">XCTAssertEqual</span>(cell.<span class="property">lastSetupUser</span>, user)
}
</code></pre><h2>Step 4: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> CollectionViewDataSource: <span class="type">NSObject</span>, <span class="type">UICollectionViewDataSource</span> {
  
  <span class="keyword">var</span> users: [<span class="type">User</span>] = []
  
  <span class="keyword">func</span> collectionView(<span class="keyword">_</span> collectionView: <span class="type">UICollectionView</span>, numberOfItemsInSection section: <span class="type">Int</span>) -&gt; <span class="type">Int</span> {
    <span class="keyword">return</span> <span class="number">0</span>
  }
  
  <span class="keyword">func</span> collectionView(<span class="keyword">_</span> collectionView: <span class="type">UICollectionView</span>, cellForItemAt indexPath: <span class="type">IndexPath</span>) -&gt; <span class="type">UICollectionViewCell</span> {
    <span class="keyword">let</span> cell = collectionView.<span class="call">dequeueReusableCell</span>(withReuseIdentifier: <span class="string">"Cell"</span>, for: indexPath)
    
    <span class="keyword">if let</span> setupCell = cell <span class="keyword">as</span>? <span class="type">CollectionViewCellProtocol</span> {
      setupCell.<span class="call">setup</span>(with: users[indexPath.<span class="property">item</span>])
    }
    
    <span class="keyword">return</span> cell
  }
}

<span class="keyword">struct</span> User : <span class="type">Equatable</span> {
  <span class="keyword">let</span> name: <span class="type">String</span>
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uicollectionviewdatasource/chapter073</guid><title>Populate A Cell</title><description>Test wheather a cell is populated with the expected data.</description><link>https://gimmetheco.de/uicollectionviewdatasource/chapter073</link><pubDate>Fri, 16 Oct 2020 01:13:00 +0200</pubDate><content:encoded><![CDATA[<h1>Populate A Cell</h1><p>Test wheather a cell is populated with the expected data</p><h2>Step 1: Test</h2><pre><code><span class="keyword">func</span> test_cellForItem_populatesCell() {
  <span class="comment">// given</span>
  sut.<span class="property">names</span> = [<span class="string">"foo"</span>]
  
  <span class="comment">// when</span>
  <span class="keyword">let</span> indexPath = <span class="type">IndexPath</span>(item: <span class="number">0</span>, section: <span class="number">0</span>)
  <span class="keyword">let</span> cell = collectionView.<span class="property">dataSource</span>?.<span class="call">collectionView</span>(collectionView, cellForItemAt: indexPath) <span class="keyword">as</span>! <span class="type">NameCell</span>
  
  <span class="comment">// then</span>
  <span class="call">XCTAssertEqual</span>(cell.<span class="property">label</span>.<span class="property">text</span>, sut.<span class="property">names</span>.<span class="property">first</span>)
}
</code></pre><h2>Step 2: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> CollectionViewDataSource: <span class="type">NSObject</span>, <span class="type">UICollectionViewDataSource</span> {
  
  <span class="keyword">var</span> names: [<span class="type">String</span>] = []
  
  <span class="keyword">func</span> registerCell(for collectionView: <span class="type">UICollectionView</span>) {
    collectionView.<span class="call">register</span>(<span class="type">NameCell</span>.<span class="keyword">self</span>, forCellWithReuseIdentifier: <span class="string">"Cell"</span>)
  }
  
  <span class="keyword">func</span> collectionView(<span class="keyword">_</span> collectionView: <span class="type">UICollectionView</span>, numberOfItemsInSection section: <span class="type">Int</span>) -&gt; <span class="type">Int</span> {
    <span class="keyword">return</span> names.<span class="property">count</span>
  }
  
  <span class="keyword">func</span> collectionView(<span class="keyword">_</span> collectionView: <span class="type">UICollectionView</span>, cellForItemAt indexPath: <span class="type">IndexPath</span>) -&gt; <span class="type">UICollectionViewCell</span> {
    
    <span class="keyword">let</span> cell = collectionView.<span class="call">dequeueReusableCell</span>(withReuseIdentifier: <span class="string">"Cell"</span>, for: indexPath) <span class="keyword">as</span>! <span class="type">NameCell</span>
    
    <span class="keyword">let</span> name = names[indexPath.<span class="property">row</span>]
    cell.<span class="property">label</span>.<span class="property">text</span> = name
    
    <span class="keyword">return</span> cell
  }
}

<span class="keyword">class</span> NameCell: <span class="type">UICollectionViewCell</span> {
  
  <span class="keyword">let</span> label = <span class="type">UILabel</span>()
  
  <span class="keyword">override init</span>(frame: <span class="type">CGRect</span>) {
    
    <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)
    
    contentView.<span class="call">addSubview</span>(label)
  }
  
  <span class="keyword">required init</span>?(coder: <span class="type">NSCoder</span>) { <span class="call">fatalError</span>() }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uicollectionviewdatasource/chapter072</guid><title>Number Of Sections And Items</title><description>Test number of sections and rows.</description><link>https://gimmetheco.de/uicollectionviewdatasource/chapter072</link><pubDate>Fri, 16 Oct 2020 01:12:00 +0200</pubDate><content:encoded><![CDATA[<h1>Number Of Sections And Items</h1><p>Test number of sections and rows</p><h2>Step 1: Test</h2><pre><code><span class="keyword">func</span> test_loadingView_numberOfSections() {
  <span class="comment">// given</span>
  sut.<span class="property">users</span> = [[<span class="type">User</span>(name: <span class="string">"dasdom"</span>),
                <span class="type">User</span>(name: <span class="string">"foo"</span>)],
                [<span class="type">User</span>(name: <span class="string">"bar"</span>)]]
  
  <span class="comment">// then</span>
  <span class="keyword">let</span> sections = collectionView.<span class="property">numberOfSections</span>
  <span class="call">XCTAssertEqual</span>(sections, <span class="number">2</span>)
}

<span class="keyword">func</span> test_loadingView_numberOfItems() {
  <span class="comment">// given</span>
  sut.<span class="property">users</span> = [[<span class="type">User</span>(name: <span class="string">"dasdom"</span>),
                <span class="type">User</span>(name: <span class="string">"foo"</span>)],
                [<span class="type">User</span>(name: <span class="string">"bar"</span>)]]
  
  <span class="comment">// then</span>
  <span class="keyword">let</span> sections = collectionView.<span class="call">numberOfItems</span>(inSection: <span class="number">0</span>)
  <span class="call">XCTAssertEqual</span>(sections, <span class="number">2</span>)
}
</code></pre><h2>Step 2: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> CollectionViewDataSource: <span class="type">NSObject</span>, <span class="type">UICollectionViewDataSource</span> {
  
  <span class="keyword">var</span> users: [[<span class="type">User</span>]] = []

  <span class="keyword">func</span> numberOfSections(in collectionView: <span class="type">UICollectionView</span>)-&gt; <span class="type">Int</span> {
    <span class="keyword">return</span> users.<span class="property">count</span>
  }
  
  <span class="keyword">func</span> collectionView(<span class="keyword">_</span> collectionView: <span class="type">UICollectionView</span>, numberOfItemsInSection section: <span class="type">Int</span>) -&gt; <span class="type">Int</span> {
    <span class="keyword">return</span> users[section].count
  }
  
  <span class="keyword">func</span> collectionView(<span class="keyword">_</span> collectionView: <span class="type">UICollectionView</span>, cellForItemAt indexPath: <span class="type">IndexPath</span>) -&gt; <span class="type">UICollectionViewCell</span> {
    <span class="keyword">return</span> <span class="type">UICollectionViewCell</span>()
  }
}

<span class="keyword">struct</span> User {
  <span class="keyword">let</span> name: <span class="type">String</span>
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uicollectionview/chapter070</guid><title>Delete Items</title><description>Test whether a row is deleted.</description><link>https://gimmetheco.de/uicollectionview/chapter070</link><pubDate>Fri, 16 Oct 2020 01:10:00 +0200</pubDate><content:encoded><![CDATA[<h1>Delete Items</h1><p>Test whether a row is deleted</p><h2>Step 1: Collection View Hock</h2><pre><code><span class="keyword">class</span> CollectionViewMock: <span class="type">UICollectionView</span> {
  
  <span class="keyword">var</span> indexPathsOfDeletedRows: [<span class="type">IndexPath</span>] = []

  <span class="keyword">override func</span> deleteItems(at indexPaths: [<span class="type">IndexPath</span>]) {
    indexPathsOfDeletedRows = indexPaths
  }
}
</code></pre><h2>Step 2: Test</h2><pre><code><span class="keyword">func</span> test_deleteUser_deletesItem() {
  <span class="comment">// given</span>
  <span class="keyword">let</span> mockCollView = <span class="type">CollectionViewMock</span>(frame: .<span class="dotAccess">zero</span>, collectionViewLayout: layout)
  sut.<span class="property">collectionView</span> = mockCollView
  
  <span class="comment">// when</span>
  sut.<span class="call">deleteUser</span>(at: <span class="number">1</span>)
  
  <span class="comment">// then</span>
  <span class="keyword">let</span> expectedIndexPaths = [<span class="type">IndexPath</span>(row: <span class="number">1</span>, section: <span class="number">0</span>)]
  <span class="call">XCTAssertEqual</span>(mockCollView.<span class="property">indexPathsOfDeletedRows</span>, expectedIndexPaths)
}
</code></pre><h2>Step 3: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> CollectionViewController: <span class="type">UICollectionViewController</span> {

  <span class="keyword">func</span> deleteUser(at index: <span class="type">Int</span>) {
    <span class="keyword">let</span> indexPath = <span class="type">IndexPath</span>(row: <span class="number">1</span>, section: <span class="number">0</span>)
    
    collectionView.<span class="call">deleteItems</span>(at: [indexPath])
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uicollectionview/chapter069</guid><title>Insert Row</title><description>Test wheather a row is inserted.</description><link>https://gimmetheco.de/uicollectionview/chapter069</link><pubDate>Fri, 16 Oct 2020 01:09:00 +0200</pubDate><content:encoded><![CDATA[<h1>Insert Row</h1><p>Test wheather a row is inserted</p><h2>Step 1: Collection View Mock</h2><pre><code><span class="keyword">class</span> CollectionViewMock: <span class="type">UICollectionView</span> {
  
  <span class="keyword">var</span> indexPathsOfAddedRows: [<span class="type">IndexPath</span>] = []

  <span class="keyword">override func</span> insertItems(at indexPaths: [<span class="type">IndexPath</span>]) {
    indexPathsOfAddedRows = indexPaths
  }
}
</code></pre><h2>Step 2: Test</h2><pre><code><span class="keyword">func</span> test_addUser_insertsItem() {
  <span class="comment">// given</span>
  <span class="keyword">let</span> mockCollView = <span class="type">CollectionViewMock</span>(frame: .<span class="dotAccess">zero</span>, collectionViewLayout: layout)
  sut.<span class="property">collectionView</span> = mockCollView
  
  <span class="comment">// when</span>
  sut.<span class="call">addUser</span>()
  
  <span class="comment">// then</span>
  <span class="keyword">let</span> expectedIndexPaths = [<span class="type">IndexPath</span>(item: <span class="number">0</span>, section: <span class="number">0</span>)]
  <span class="call">XCTAssertEqual</span>(mockCollView.<span class="property">indexPathsOfAddedRows</span>, expectedIndexPaths)
}
</code></pre><h2>Step 3: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> CollectionViewController: <span class="type">UICollectionViewController</span> {

  <span class="keyword">func</span> addUser() {
    collectionView.<span class="call">insertItems</span>(at: [<span class="type">IndexPath</span>(item: <span class="number">0</span>, section: <span class="number">0</span>)])
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uicollectionview/chapter068</guid><title>Dequeue A Supplementary View</title><description>Test wheather a supplementary view is dequeued.</description><link>https://gimmetheco.de/uicollectionview/chapter068</link><pubDate>Fri, 16 Oct 2020 01:08:00 +0200</pubDate><content:encoded><![CDATA[<h1>Dequeue A Supplementary View</h1><p>Test wheather a supplementary view is dequeued</p><h2>Step 1: Collection View Mock</h2><pre><code><span class="keyword">class</span> CollectionViewMock: <span class="type">UICollectionView</span> {
  
  <span class="keyword">var</span> dequeueReusableSupplementaryCalls = <span class="number">0</span>
  
  <span class="keyword">override func</span> dequeueReusableSupplementaryView(ofKind elementKind: <span class="type">String</span>, withReuseIdentifier identifier: <span class="type">String</span>, for indexPath: <span class="type">IndexPath</span>) -&gt; <span class="type">UICollectionReusableView</span> {
    dequeueReusableSupplementaryCalls += <span class="number">1</span>
    
    <span class="keyword">return</span> <span class="type">SupplementaryView</span>()
  }
}
</code></pre><h2>Step 2: Test</h2><pre><code><span class="keyword">func</span> test_cellForItem_dequeuesCell() {
  <span class="comment">// given</span>
  <span class="keyword">let</span> mockCollView = <span class="type">CollectionViewMock</span>(frame: .<span class="dotAccess">zero</span>, collectionViewLayout: layout)
  
  <span class="comment">// when</span>
  <span class="keyword">_</span> = sut.<span class="call">collectionView</span>(mockCollView, viewForSupplementaryElementOfKind: <span class="type">UICollectionView</span>.<span class="property">elementKindSectionHeader</span>, at: <span class="type">IndexPath</span>(item: <span class="number">0</span>, section: <span class="number">0</span>))
  
  <span class="comment">// then</span>
  <span class="call">XCTAssertEqual</span>(mockCollView.<span class="property">dequeueReusableSupplementaryCalls</span>, <span class="number">1</span>)
}
</code></pre><h2>Step 3: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> CollectionViewController: <span class="type">UICollectionViewController</span> {
  
  <span class="keyword">override func</span> viewDidLoad() {
    <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
    
    collectionView.<span class="call">register</span>(<span class="type">SupplementaryView</span>.<span class="keyword">self</span>, forSupplementaryViewOfKind: <span class="type">UICollectionView</span>.<span class="property">elementKindSectionHeader</span>, withReuseIdentifier: <span class="string">"Header"</span>)
  }
  
  <span class="keyword">override func</span> collectionView(<span class="keyword">_</span> collectionView: <span class="type">UICollectionView</span>, viewForSupplementaryElementOfKind kind: <span class="type">String</span>, at indexPath: <span class="type">IndexPath</span>) -&gt; <span class="type">UICollectionReusableView</span> {
    
    <span class="keyword">let</span> view = collectionView.<span class="call">dequeueReusableSupplementaryView</span>(ofKind: kind, withReuseIdentifier: <span class="string">"Header"</span>, for: indexPath)
    
    <span class="keyword">return</span> view
  }
}

<span class="keyword">class</span> SupplementaryView: <span class="type">UICollectionReusableView</span> {}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uicollectionview/chapter067</guid><title>Dequeue A Cell</title><description>Test wheather a cell is dequeued.</description><link>https://gimmetheco.de/uicollectionview/chapter067</link><pubDate>Fri, 16 Oct 2020 01:07:00 +0200</pubDate><content:encoded><![CDATA[<h1>Dequeue A Cell</h1><p>Test wheather a cell is dequeued</p><h2>Step 1: Collection View Mock</h2><pre><code><span class="keyword">class</span> CollectionViewMock: <span class="type">UICollectionView</span> {
  
  <span class="keyword">var</span> dequeueReusableCellCalls = <span class="number">0</span>
  
  <span class="keyword">override func</span> dequeueReusableCell(withReuseIdentifier identifier: <span class="type">String</span>, for indexPath: <span class="type">IndexPath</span>) -&gt; <span class="type">UICollectionViewCell</span> {
    dequeueReusableCellCalls += <span class="number">1</span>
    
    <span class="keyword">return</span> <span class="type">UICollectionViewCell</span>()
  }
}
</code></pre><h2>Step 2: Test</h2><pre><code><span class="keyword">func</span> test_cellForItem_dequeuesCell() {
  <span class="comment">// given</span>
  <span class="keyword">let</span> mockCollView = <span class="type">CollectionViewMock</span>(frame: .<span class="dotAccess">zero</span>, collectionViewLayout: layout)
  
  <span class="comment">// when</span>
  <span class="keyword">_</span> = sut.<span class="call">collectionView</span>(mockCollView, cellForItemAt: <span class="type">IndexPath</span>(item: <span class="number">0</span>, section: <span class="number">0</span>))
  
  <span class="comment">// then</span>
  <span class="call">XCTAssertEqual</span>(mockCollView.<span class="property">dequeueReusableCellCalls</span>, <span class="number">1</span>)
}
</code></pre><h2>Step 3: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> CollectionViewController: <span class="type">UICollectionViewController</span> {
  
  <span class="keyword">override func</span> viewDidLoad() {
    <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
    
    collectionView.<span class="call">register</span>(<span class="type">Cell</span>.<span class="keyword">self</span>, forCellWithReuseIdentifier: <span class="string">"Cell"</span>)
  }
  
  <span class="keyword">override func</span> collectionView(<span class="keyword">_</span> collectionView: <span class="type">UICollectionView</span>, cellForItemAt indexPath: <span class="type">IndexPath</span>) -&gt; <span class="type">UICollectionViewCell</span> {
    
    <span class="keyword">let</span> cell = collectionView.<span class="call">dequeueReusableCell</span>(withReuseIdentifier: <span class="string">"Cell"</span>, for: <span class="type">IndexPath</span>(item: <span class="number">0</span>, section: <span class="number">0</span>))
    
    <span class="keyword">return</span> cell
  }
}

<span class="keyword">class</span> Cell: <span class="type">UICollectionViewCell</span> {}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uicollectionview/chapter066</guid><title>Register A Supplementary View</title><description>Test wheather supplementary views are registered.</description><link>https://gimmetheco.de/uicollectionview/chapter066</link><pubDate>Fri, 16 Oct 2020 01:06:00 +0200</pubDate><content:encoded><![CDATA[<h1>Register A Supplementary View</h1><p>Test wheather supplementary views are registered</p><h2>Step 1: Test</h2><pre><code><span class="keyword">func</span> test_loadingView_registersCell() {
  <span class="comment">// when</span>
  sut.<span class="call">loadViewIfNeeded</span>()
  
  <span class="comment">// then</span>
  <span class="keyword">let</span> header = sut.<span class="property">collectionView</span>.<span class="call">dequeueReusableSupplementaryView</span>(ofKind: <span class="type">UICollectionView</span>.<span class="property">elementKindSectionHeader</span>, withReuseIdentifier: <span class="string">"Header"</span>, for: <span class="type">IndexPath</span>(item: <span class="number">0</span>, section: <span class="number">0</span>))
  <span class="call">XCTAssertNotNil</span>(header)
  <span class="call">XCTAssertTrue</span>(header <span class="keyword">is</span> <span class="type">SupplementaryView</span>)
}
</code></pre><h3>Step 2: Example code that makes the test pass</h3><pre><code><span class="keyword">class</span> CollectionViewController: <span class="type">UICollectionViewController</span> {
  
  <span class="keyword">override func</span> viewDidLoad() {
    <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
    
    collectionView.<span class="call">register</span>(<span class="type">SupplementaryView</span>.<span class="keyword">self</span>, forSupplementaryViewOfKind: <span class="type">UICollectionView</span>.<span class="property">elementKindSectionHeader</span>, withReuseIdentifier: <span class="string">"Header"</span>)
  }
}

<span class="keyword">class</span> SupplementaryView: <span class="type">UICollectionReusableView</span> {}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uicollectionview/chapter065</guid><title>Register A Cell</title><description>Test wheather cells are registered.</description><link>https://gimmetheco.de/uicollectionview/chapter065</link><pubDate>Fri, 16 Oct 2020 01:05:00 +0200</pubDate><content:encoded><![CDATA[<h1>Register A Cell</h1><p>Test wheather cells are registered</p><h2>Step 1: Test</h2><pre><code><span class="keyword">func</span> test_loadingView_registersCell() {
  <span class="comment">// when</span>
  sut.<span class="call">loadViewIfNeeded</span>()
  
  <span class="comment">// then</span>
  <span class="keyword">let</span> cell = sut.<span class="property">collectionView</span>.<span class="call">dequeueReusableCell</span>(withReuseIdentifier: <span class="string">"Cell"</span>, for: <span class="type">IndexPath</span>(item: <span class="number">0</span>, section: <span class="number">0</span>))
  <span class="call">XCTAssertNotNil</span>(cell)
  <span class="call">XCTAssertTrue</span>(cell <span class="keyword">is</span> <span class="type">Cell</span>)
}
</code></pre><h2>Step 2: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> CollectionViewController: <span class="type">UICollectionViewController</span> {
  
  <span class="keyword">override func</span> viewDidLoad() {
    <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
    
    collectionView.<span class="call">register</span>(<span class="type">Cell</span>.<span class="keyword">self</span>, forCellWithReuseIdentifier: <span class="string">"Cell"</span>)
  }
}

<span class="keyword">class</span> Cell: <span class="type">UICollectionViewCell</span> {}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uitableviewdelegate/chapter063</guid><title>Cell Height</title><description>Test wheather the cell has the correct height.</description><link>https://gimmetheco.de/uitableviewdelegate/chapter063</link><pubDate>Fri, 16 Oct 2020 01:03:00 +0200</pubDate><content:encoded><![CDATA[<h1>Cell Height</h1><p>Test wheather the cell has the correct height</p><h2>Step 1: Test</h2><pre><code><span class="keyword">func</span> test_heightForRow() {
  <span class="comment">// when</span>
  <span class="keyword">let</span> indexPath = <span class="type">IndexPath</span>(row: <span class="number">0</span>, section: <span class="number">0</span>)
  <span class="keyword">let</span> height = sut.<span class="call">tableView</span>(<span class="type">UITableView</span>(), heightForRowAt: indexPath)
  
  <span class="comment">// then</span>
  <span class="call">XCTAssertEqual</span>(height, <span class="number">42</span>)
}
</code></pre><h2>Step 2: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> TableViewDelegate: <span class="type">NSObject</span>, <span class="type">UITableViewDelegate</span> {
  
  <span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, heightForRowAt indexPath: <span class="type">IndexPath</span>) -&gt; <span class="type">CGFloat</span> {
    <span class="keyword">return</span> <span class="number">42</span>
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uitableviewdelegate/chapter062</guid><title>Selection Of Cells</title><description>Test whether selection of a cell results in a controller being pushed onto the navigation stack.</description><link>https://gimmetheco.de/uitableviewdelegate/chapter062</link><pubDate>Fri, 16 Oct 2020 01:02:00 +0200</pubDate><content:encoded><![CDATA[<h1>Selection Of Cells</h1><p>Test whether selection of a cell results in a controller being pushed onto the navigation stack</p><h2>Step 1: Navigation Controller Mock</h2><pre><code><span class="keyword">class</span> NavigationControllerMock: <span class="type">UINavigationController</span> {
  
  <span class="keyword">var</span> lastPushedVC: <span class="type">UIViewController</span>?
  
  <span class="keyword">override func</span> pushViewController(<span class="keyword">_</span> viewController: <span class="type">UIViewController</span>, animated: <span class="type">Bool</span>) {
    lastPushedVC = viewController
    <span class="keyword">super</span>.<span class="call">pushViewController</span>(viewController, animated: animated)
  }
}
</code></pre><h2>Step 2: Test</h2><pre><code><span class="keyword">func</span> test_selectingCell_pushesController() {
  <span class="comment">// given</span>
  <span class="keyword">let</span> user = <span class="type">User</span>(name: <span class="string">"Foo"</span>)
  sut.<span class="property">users</span> = [user]
  <span class="keyword">let</span> navController = <span class="type">NavigationControllerMock</span>(rootViewController: sut)

  <span class="comment">// when</span>
  <span class="keyword">let</span> indexPath = <span class="type">IndexPath</span>(row: <span class="number">0</span>, section: <span class="number">0</span>)
  sut.<span class="call">tableView</span>(sut.<span class="property">tableView</span>, didSelectRowAt: indexPath)
  
  <span class="comment">// then</span>
  <span class="keyword">let</span> pushedVC = navController.<span class="property">lastPushedVC</span> <span class="keyword">as</span>? <span class="type">DetailViewController</span>
  <span class="call">XCTAssertNotNil</span>(pushedVC)
  <span class="call">XCTAssertEqual</span>(pushedVC?.<span class="property">user</span>, user)
}
</code></pre><h2>Step 3: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> TableViewController: <span class="type">UITableViewController</span> {
  
  <span class="keyword">var</span> users : [<span class="type">User</span>] = []
  
  <span class="keyword">override func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, didSelectRowAt indexPath: <span class="type">IndexPath</span>) {
    
    <span class="keyword">let</span> user = users[indexPath.<span class="property">row</span>]
    <span class="keyword">let</span> detailViewController = <span class="type">DetailViewController</span>(user: user)
    
    navigationController?.<span class="call">pushViewController</span>(detailViewController, animated: <span class="keyword">true</span>)
  }
}

<span class="keyword">class</span> DetailViewController: <span class="type">UIViewController</span> {
  
  <span class="keyword">let</span> user: <span class="type">User</span>
  
  <span class="keyword">init</span>(user: <span class="type">User</span>) {
    
    <span class="keyword">self</span>.<span class="property">user</span> = user
    
    <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="keyword">nil</span>, bundle: <span class="keyword">nil</span>)
  }
  
  <span class="keyword">required init</span>?(coder aDecoder: <span class="type">NSCoder</span>) {
    <span class="call">fatalError</span>(<span class="string">"not been implemented"</span>)
  }
}

<span class="keyword">struct</span> User: <span class="type">Equatable</span> {
  <span class="keyword">let</span> name: <span class="type">String</span>
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uitableviewdelegate/chapter061</guid><title>Will Select Row</title><description>Test whether will select row returns the correct index path.</description><link>https://gimmetheco.de/uitableviewdelegate/chapter061</link><pubDate>Fri, 16 Oct 2020 01:01:00 +0200</pubDate><content:encoded><![CDATA[<h1>Will Select Row</h1><p>Test whether will select row returns the correct index path</p><h2>Step 1: Test</h2><pre><code><span class="keyword">func</span> test_willSelectRow_returnsIndexPath() {
  <span class="comment">// when</span>
  <span class="keyword">let</span> indexPath = <span class="type">IndexPath</span>(row: <span class="number">0</span>, section: <span class="number">0</span>)
  <span class="keyword">let</span> result = sut.<span class="call">tableView</span>(<span class="type">UITableView</span>(), willSelectRowAt: indexPath)
  
  <span class="comment">// then</span>
  <span class="keyword">let</span> expectedIndexPath = <span class="type">IndexPath</span>(row: <span class="number">1</span>, section: <span class="number">0</span>)
  <span class="call">XCTAssertEqual</span>(result, expectedIndexPath)
}
</code></pre><h2>Step 2: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> TableViewDelegate: <span class="type">NSObject</span>, <span class="type">UITableViewDelegate</span> {
  
  <span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, willSelectRowAt indexPath: <span class="type">IndexPath</span>) -&gt; <span class="type">IndexPath</span>? {
    <span class="keyword">return</span> <span class="type">IndexPath</span>(row: indexPath.<span class="property">row</span> + <span class="number">1</span>, section: <span class="number">0</span>)
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uitableviewdelegate/chapter060</guid><title>Indentation Level</title><description>Test whether the indentation level is correct.</description><link>https://gimmetheco.de/uitableviewdelegate/chapter060</link><pubDate>Fri, 16 Oct 2020 01:00:00 +0200</pubDate><content:encoded><![CDATA[<h1>Indentation Level</h1><p>Test whether the indentation level is correct</p><h2>Step 1: Test</h2><pre><code><span class="keyword">func</span> test_indentationLevel() {
  <span class="comment">// when</span>
  <span class="keyword">let</span> indexPath = <span class="type">IndexPath</span>(row: <span class="number">0</span>, section: <span class="number">0</span>)
  <span class="keyword">let</span> indetationLevel = sut.<span class="call">tableView</span>(<span class="type">UITableView</span>(), indentationLevelForRowAt: indexPath)
  
  <span class="comment">// then</span>
  <span class="call">XCTAssertEqual</span>(indetationLevel, <span class="number">2</span>)
}
</code></pre><h2>Step 2: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> TableViewDelegate: <span class="type">NSObject</span>, <span class="type">UITableViewDelegate</span> {
  
  <span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, indentationLevelForRowAt indexPath: <span class="type">IndexPath</span>) -&gt; <span class="type">Int</span> {
    <span class="keyword">return</span> <span class="number">2</span>
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uitableviewdelegate/chapter059</guid><title>Will Display</title><description>Test whether the background color of the cell is set in `willDisplay`.</description><link>https://gimmetheco.de/uitableviewdelegate/chapter059</link><pubDate>Fri, 16 Oct 2020 00:59:00 +0200</pubDate><content:encoded><![CDATA[<h1>Will Display</h1><p>Test whether the background color of the cell is set in <code>willDisplay</code>.</p><h2>Step 1: Test</h2><pre><code><span class="keyword">func</span> test_willDisplay_setsBackgroundColor() {
  <span class="comment">// given</span>
  <span class="keyword">let</span> cell = <span class="type">UITableViewCell</span>()
  
  <span class="comment">// when</span>
  <span class="keyword">let</span> indexPath = <span class="type">IndexPath</span>(row: <span class="number">0</span>, section: <span class="number">0</span>)
  sut.<span class="call">tableView</span>(<span class="type">UITableView</span>(), willDisplay: cell, forRowAt: indexPath)
  
  <span class="comment">// then</span>
  <span class="call">XCTAssertEqual</span>(cell.<span class="property">backgroundColor</span>, <span class="type">UIColor</span>.<span class="property">yellow</span>)
}
</code></pre><h2>Step 2: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> TableViewDelegate: <span class="type">NSObject</span>, <span class="type">UITableViewDelegate</span> {
  
  <span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, willDisplay cell: <span class="type">UITableViewCell</span>, forRowAt indexPath: <span class="type">IndexPath</span>) {
    cell.<span class="property">backgroundColor</span> = .<span class="dotAccess">yellow</span>
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uitableviewdatasource/chapter057</guid><title>Reorder Rows</title><description>Test wheather rows are reordered.</description><link>https://gimmetheco.de/uitableviewdatasource/chapter057</link><pubDate>Fri, 16 Oct 2020 00:57:00 +0200</pubDate><content:encoded><![CDATA[<h1>Reorder Rows</h1><p>Test wheather rows are reordered</p><h2>Step 1: Table View Mock</h2><pre><code><span class="keyword">class</span> TableViewMock: <span class="type">UITableView</span> {
  
  <span class="keyword">var</span> fromIndexPath: <span class="type">IndexPath</span>? = <span class="keyword">nil
  var</span> toIndexPath: <span class="type">IndexPath</span>? = <span class="keyword">nil
  
  override func</span> moveRow(at indexPath: <span class="type">IndexPath</span>, to newIndexPath: <span class="type">IndexPath</span>) {
    fromIndexPath = indexPath
    toIndexPath = newIndexPath
  }
}
</code></pre><h2>Step 2: Test</h2><pre><code><span class="keyword">func</span> test_movingRows() {
  <span class="comment">// given</span>
  <span class="keyword">let</span> mockTableView = <span class="type">TableViewMock</span>()
  
  <span class="comment">// when</span>
  tableView.<span class="property">dataSource</span>?.<span class="property">tableView</span>?(mockTableView, moveRowAt: <span class="type">IndexPath</span>(row: <span class="number">1</span>, section: <span class="number">0</span>), to: <span class="type">IndexPath</span>(row: <span class="number">2</span>, section: <span class="number">0</span>))
  
  <span class="comment">// then</span>
  <span class="keyword">let</span> expectedFromIndexPath = <span class="type">IndexPath</span>(row: <span class="number">1</span>, section: <span class="number">0</span>)
  <span class="keyword">let</span> expectedToIndexPath = <span class="type">IndexPath</span>(row: <span class="number">2</span>, section: <span class="number">0</span>)
  <span class="call">XCTAssertEqual</span>(mockTableView.<span class="property">fromIndexPath</span>, expectedFromIndexPath)
  <span class="call">XCTAssertEqual</span>(mockTableView.<span class="property">toIndexPath</span>, expectedToIndexPath)
}
</code></pre><h2>Step 3: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> TableViewDataSource: <span class="type">NSObject</span>, <span class="type">UITableViewDataSource</span> {
  
  <span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, numberOfRowsInSection section: <span class="type">Int</span>) -&gt; <span class="type">Int</span> {
    <span class="keyword">return</span> <span class="number">0</span>
  }
  
  <span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, cellForRowAt indexPath: <span class="type">IndexPath</span>) -&gt; <span class="type">UITableViewCell</span> {
    <span class="keyword">return</span> <span class="type">UITableViewCell</span>()
  }
  
  
  <span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, canMoveRowAt indexPath: <span class="type">IndexPath</span>) -&gt; <span class="type">Bool</span> {
    <span class="keyword">return true</span>
  }
  
  <span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, moveRowAt sourceIndexPath: <span class="type">IndexPath</span>, to destinationIndexPath: <span class="type">IndexPath</span>) {
    tableView.<span class="call">moveRow</span>(at: sourceIndexPath, to: destinationIndexPath)
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uitableviewdatasource/chapter056</guid><title>Commit Editing Style (Insert A Row)</title><description>Test whether a row is inserted.</description><link>https://gimmetheco.de/uitableviewdatasource/chapter056</link><pubDate>Fri, 16 Oct 2020 00:56:00 +0200</pubDate><content:encoded><![CDATA[<h1>Commit Editing Style (Insert A Row)</h1><p>Test whether a row is inserted</p><h2>Step 1: Table View Mock</h2><pre><code><span class="keyword">class</span> TableViewMock: <span class="type">UITableView</span> {
  
  <span class="keyword">var</span> indexPathsOfInsertedRows: [<span class="type">IndexPath</span>] = []
  
  <span class="keyword">override func</span> insertRows(at indexPaths: [<span class="type">IndexPath</span>], with animation: <span class="type">UITableView</span>.<span class="type">RowAnimation</span>) {
    indexPathsOfInsertedRows = indexPaths
  }
}
</code></pre><h2>Step 2: Test</h2><pre><code><span class="keyword">func</span> test_insert_addsRow() {
  <span class="comment">// given</span>
  <span class="keyword">let</span> mockTableView = <span class="type">TableViewMock</span>()
  
  <span class="comment">// when</span>
  tableView.<span class="property">dataSource</span>?.<span class="property">tableView</span>?(mockTableView, commit: .<span class="dotAccess">insert</span>, forRowAt: <span class="type">IndexPath</span>(row: <span class="number">1</span>, section: <span class="number">0</span>))
  
  <span class="comment">// then</span>
  <span class="keyword">let</span> expectedIndexPaths = [<span class="type">IndexPath</span>(row: <span class="number">1</span>, section: <span class="number">0</span>)]
  <span class="call">XCTAssertEqual</span>(mockTableView.<span class="property">indexPathsOfInsertedRows</span>, expectedIndexPaths)
}
</code></pre><h2>Step 3: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> TableViewDataSource: <span class="type">NSObject</span>, <span class="type">UITableViewDataSource</span> {
  
  <span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, numberOfRowsInSection section: <span class="type">Int</span>) -&gt; <span class="type">Int</span> {
    <span class="keyword">return</span> <span class="number">0</span>
  }
  
  <span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, cellForRowAt indexPath: <span class="type">IndexPath</span>) -&gt; <span class="type">UITableViewCell</span> {
    <span class="keyword">return</span> <span class="type">UITableViewCell</span>()
  }
  
  <span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, commit editingStyle: <span class="type">UITableViewCell</span>.<span class="type">EditingStyle</span>, forRowAt indexPath: <span class="type">IndexPath</span>) {
    tableView.<span class="call">insertRows</span>(at: [indexPath], with: .<span class="dotAccess">none</span>)
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uitableviewdatasource/chapter055</guid><title>Commit Editing Style (Delete A Row)</title><description>Test whether a row is deleted.</description><link>https://gimmetheco.de/uitableviewdatasource/chapter055</link><pubDate>Fri, 16 Oct 2020 00:55:00 +0200</pubDate><content:encoded><![CDATA[<h1>Commit Editing Style (Delete A Row)</h1><p>Test whether a row is deleted</p><h2>Step 1: Table View Mock</h2><pre><code><span class="keyword">class</span> TableViewMock: <span class="type">UITableView</span> {
  
  <span class="keyword">var</span> indexPathsOfDeletedRows: [<span class="type">IndexPath</span>] = []
  
  <span class="keyword">override func</span> deleteRows(at indexPaths: [<span class="type">IndexPath</span>], with animation: <span class="type">UITableView</span>.<span class="type">RowAnimation</span>) {
    indexPathsOfDeletedRows = indexPaths
  }
}
</code></pre><h2>Step 2: Test</h2><pre><code><span class="keyword">func</span> test_delete_deletesRow() {
  <span class="comment">// given</span>
  <span class="keyword">let</span> mockTableView = <span class="type">TableViewMock</span>()
  
  <span class="comment">// when</span>
  tableView.<span class="property">dataSource</span>?.<span class="property">tableView</span>?(mockTableView, commit: .<span class="dotAccess">delete</span>, forRowAt: <span class="type">IndexPath</span>(row: <span class="number">1</span>, section: <span class="number">0</span>))
  
  <span class="comment">// then</span>
  <span class="keyword">let</span> expectedIndexPaths = [<span class="type">IndexPath</span>(row: <span class="number">1</span>, section: <span class="number">0</span>)]
  <span class="call">XCTAssertEqual</span>(mockTableView.<span class="property">indexPathsOfDeletedRows</span>, expectedIndexPaths)
}
</code></pre><h2>Step 4: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> TableViewDataSource: <span class="type">NSObject</span>, <span class="type">UITableViewDataSource</span> {
  
  <span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, numberOfRowsInSection section: <span class="type">Int</span>) -&gt; <span class="type">Int</span> {
    <span class="keyword">return</span> <span class="number">0</span>
  }
  
  <span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, cellForRowAt indexPath: <span class="type">IndexPath</span>) -&gt; <span class="type">UITableViewCell</span> {
    <span class="keyword">return</span> <span class="type">UITableViewCell</span>()
  }
  
  <span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, commit editingStyle: <span class="type">UITableViewCell</span>.<span class="type">EditingStyle</span>, forRowAt indexPath: <span class="type">IndexPath</span>) {
    tableView.<span class="call">deleteRows</span>(at: [indexPath], with: .<span class="dotAccess">none</span>)
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uitableviewdatasource/chapter054</guid><title>Setup Cell</title><description>Test wheather a setup method of a cell is called.</description><link>https://gimmetheco.de/uitableviewdatasource/chapter054</link><pubDate>Fri, 16 Oct 2020 00:54:00 +0200</pubDate><content:encoded><![CDATA[<h1>Setup Cell</h1><p>Test wheather a setup method of a cell is called</p><h2>Step 1: Protocol</h2><pre><code><span class="keyword">protocol</span> TableViewCellProtocol {
  <span class="keyword">func</span> setup(with: <span class="type">User</span>)
}
</code></pre><h2>Step 2: Table View Cell Mock</h2><pre><code><span class="keyword">class</span> MockTableViewCell: <span class="type">UITableViewCell</span>, <span class="type">TableViewCellProtocol</span> {
  
  <span class="keyword">var</span> lastSetupUser: <span class="type">User</span>?
  
  <span class="keyword">func</span> setup(with user: <span class="type">User</span>) {
    lastSetupUser = user
  }
}
</code></pre><h2>Step 3: Test</h2><pre><code><span class="keyword">func</span> test_cellForRow_setsUpTheCell() {
  <span class="comment">// given</span>
  tableView.<span class="call">register</span>(<span class="type">MockTableViewCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="string">"Cell"</span>)
  <span class="keyword">let</span> user = <span class="type">User</span>(name: <span class="string">"Foo"</span>)
  sut.<span class="property">users</span> = [user]
  
  <span class="comment">// when</span>
  <span class="keyword">let</span> indexPath = <span class="type">IndexPath</span>(row: <span class="number">0</span>, section: <span class="number">0</span>)
  <span class="keyword">let</span> cell = tableView.<span class="property">dataSource</span>?.<span class="call">tableView</span>(tableView, cellForRowAt: indexPath) <span class="keyword">as</span>! <span class="type">MockTableViewCell</span>
  
  <span class="comment">// then</span>
  <span class="call">XCTAssertEqual</span>(cell.<span class="property">lastSetupUser</span>, user)
}
</code></pre><h2>Step 4: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> TableViewDataSource: <span class="type">NSObject</span>, <span class="type">UITableViewDataSource</span> {
  
  <span class="keyword">var</span> users: [<span class="type">User</span>] = []
  
  <span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, numberOfRowsInSection section: <span class="type">Int</span>) -&gt; <span class="type">Int</span> {
    <span class="keyword">return</span> <span class="number">0</span>
  }
  
  <span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, cellForRowAt indexPath: <span class="type">IndexPath</span>) -&gt; <span class="type">UITableViewCell</span> {
      
    <span class="keyword">let</span> cell = tableView.<span class="call">dequeueReusableCell</span>(withIdentifier: <span class="string">"Cell"</span>, for: indexPath)
    
    <span class="keyword">if let</span> setupCell = cell <span class="keyword">as</span>? <span class="type">TableViewCellProtocol</span> {
      setupCell.<span class="call">setup</span>(with: users[indexPath.<span class="property">row</span>])
    }
    
    <span class="keyword">return</span> cell
  }
}

<span class="keyword">struct</span> User: <span class="type">Equatable</span> {
  <span class="keyword">let</span> name: <span class="type">String</span>
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uitableviewdatasource/chapter053</guid><title>Populating A Cell</title><description>Test wheather the content of a cell (labels, image views, ...) is populated with data.</description><link>https://gimmetheco.de/uitableviewdatasource/chapter053</link><pubDate>Fri, 16 Oct 2020 00:53:00 +0200</pubDate><content:encoded><![CDATA[<h1>Populating A Cell</h1><p>Test wheather the content of a cell (labels, image views, ...) is populated with data</p><h2>Step 1: Test</h2><pre><code><span class="keyword">func</span> test_cellForRow_populatesCell() {
  <span class="comment">// given</span>
  sut.<span class="property">names</span> = [<span class="string">"foo"</span>]
  
  <span class="comment">// when</span>
  <span class="keyword">let</span> indexPath = <span class="type">IndexPath</span>(row: <span class="number">0</span>, section: <span class="number">0</span>)
  <span class="keyword">let</span> cell = tableView.<span class="property">dataSource</span>?.<span class="call">tableView</span>(tableView, cellForRowAt: indexPath)
  
  <span class="comment">// then</span>
  <span class="call">XCTAssertEqual</span>(cell?.<span class="property">textLabel</span>?.<span class="property">text</span>, sut.<span class="property">names</span>.<span class="property">first</span>)
}
</code></pre><h2>Step 2: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> TableViewDataSource: <span class="type">NSObject</span>, <span class="type">UITableViewDataSource</span> {
  
  <span class="keyword">var</span> names: [<span class="type">String</span>] = []
  
  <span class="keyword">func</span> registerCell(for tableView: <span class="type">UITableView</span>) {
    tableView.<span class="call">register</span>(<span class="type">UITableViewCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="string">"Cell"</span>)
  }
  
  <span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, numberOfRowsInSection section: <span class="type">Int</span>) -&gt; <span class="type">Int</span> {
    <span class="keyword">return</span> names.<span class="property">count</span>
  }
  
  <span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, cellForRowAt indexPath: <span class="type">IndexPath</span>) -&gt; <span class="type">UITableViewCell</span> {
    
    <span class="keyword">let</span> cell = tableView.<span class="call">dequeueReusableCell</span>(withIdentifier: <span class="string">"Cell"</span>, for: indexPath)
    
    <span class="keyword">let</span> name = names[indexPath.<span class="property">row</span>]
    cell.<span class="property">textLabel</span>?.<span class="property">text</span> = name
    
    <span class="keyword">return</span> cell
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uitableviewdatasource/chapter052</guid><title>Header Title</title><description></description><link>https://gimmetheco.de/uitableviewdatasource/chapter052</link><pubDate>Fri, 16 Oct 2020 00:52:00 +0200</pubDate><content:encoded><![CDATA[<h1>Header Title</h1><h2>Step 1: Test</h2><pre><code><span class="keyword">func</span> test_titleForHeader() {
  <span class="comment">// when</span>
  <span class="keyword">let</span> title = tableView.<span class="property">dataSource</span>?.<span class="property">tableView</span>?(tableView, titleForHeaderInSection: <span class="number">0</span>)
  
  <span class="comment">// then</span>
  <span class="call">XCTAssertEqual</span>(title, <span class="string">"foobar"</span>)
}
</code></pre><h2>Step 2: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> TableViewDataSource: <span class="type">NSObject</span>, <span class="type">UITableViewDataSource</span> {
  
  <span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, titleForHeaderInSection section: <span class="type">Int</span>) -&gt; <span class="type">String</span>? {
    <span class="keyword">return</span> <span class="string">"foobar"</span>
  }
  
  <span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, numberOfRowsInSection section: <span class="type">Int</span>) -&gt; <span class="type">Int</span> {
    <span class="keyword">return</span> <span class="number">0</span>
  }
  
  <span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, cellForRowAt indexPath: <span class="type">IndexPath</span>) -&gt; <span class="type">UITableViewCell</span> {
    <span class="keyword">return</span> <span class="type">UITableViewCell</span>()
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uitableviewdatasource/chapter051</guid><title>Number Of Sections And Rows</title><description>Test number of sections and rows.</description><link>https://gimmetheco.de/uitableviewdatasource/chapter051</link><pubDate>Fri, 16 Oct 2020 00:51:00 +0200</pubDate><content:encoded><![CDATA[<h1>Number Of Sections And Rows</h1><p>Test number of sections and rows</p><h2>Step 1: Test</h2><pre><code><span class="keyword">func</span> test_numberOfSections() {
  <span class="comment">// given</span>
  sut.<span class="property">users</span> = [[<span class="type">User</span>(name: <span class="string">"dasdom"</span>),
                <span class="type">User</span>(name: <span class="string">"foo"</span>)],
                [<span class="type">User</span>(name: <span class="string">"bar"</span>)]]

  <span class="comment">// when</span>
  <span class="keyword">let</span> sections = tableView.<span class="property">numberOfSections</span>
  
  <span class="comment">// then</span>
  <span class="call">XCTAssertEqual</span>(sections, <span class="number">2</span>)
}

<span class="keyword">func</span> test_numberOfRows() {
  <span class="comment">// given</span>
  sut.<span class="property">users</span> = [[<span class="type">User</span>(name: <span class="string">"dasdom"</span>),
                <span class="type">User</span>(name: <span class="string">"foo"</span>)],
                [<span class="type">User</span>(name: <span class="string">"bar"</span>)]]
  
  <span class="comment">// when</span>
  <span class="keyword">let</span> rows = tableView.<span class="call">numberOfRows</span>(inSection: <span class="number">0</span>)
  
  <span class="comment">// then</span>
  <span class="call">XCTAssertEqual</span>(rows, <span class="number">2</span>)
}
</code></pre><h2>Step 2: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> TableViewDataSource: <span class="type">NSObject</span>, <span class="type">UITableViewDataSource</span> {
  
  <span class="keyword">var</span> users: [[<span class="type">User</span>]] = []
  
  <span class="keyword">func</span> numberOfSections(in tableView: <span class="type">UITableView</span>) -&gt; <span class="type">Int</span> {
    <span class="keyword">return</span> users.<span class="property">count</span>
  }
  
  <span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, numberOfRowsInSection section: <span class="type">Int</span>) -&gt; <span class="type">Int</span> {
    
    <span class="keyword">return</span> users[section].count
  }

  <span class="keyword">func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, cellForRowAt indexPath: <span class="type">IndexPath</span>) -&gt; <span class="type">UITableViewCell</span> {
    <span class="keyword">return</span> <span class="type">UITableViewCell</span>()
  }
}

<span class="keyword">struct</span> User {
  <span class="keyword">let</span> name: <span class="type">String</span>
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uitableview/chapter049</guid><title>Perform Batch Updates</title><description>Test wheather batch updates are performed.</description><link>https://gimmetheco.de/uitableview/chapter049</link><pubDate>Fri, 16 Oct 2020 00:49:00 +0200</pubDate><content:encoded><![CDATA[<h1>Perform Batch Updates</h1><p>Test wheather batch updates are performed</p><h2>Step 1: Table View Mock</h2><pre><code><span class="keyword">class</span> TableViewMock: <span class="type">UITableView</span> {
  
  <span class="keyword">var</span> performBatchUpdatesCalled = <span class="keyword">false
  
  override func</span> performBatchUpdates(<span class="keyword">_</span> updates: (() -&gt; <span class="type">Void</span>)?, completion: ((<span class="type">Bool</span>) -&gt; <span class="type">Void</span>)? = <span class="keyword">nil</span>) {
    performBatchUpdatesCalled = <span class="keyword">true</span>
  }
}
</code></pre><h2>Step 2: Test</h2><pre><code><span class="keyword">func</span> test_addUser_deletesRow() {
  <span class="comment">// given</span>
  <span class="keyword">let</span> mockTableView = <span class="type">TableViewMock</span>()
  sut.<span class="property">tableView</span> = mockTableView
  
  <span class="comment">// when</span>
  sut.<span class="call">remove</span>(selected: [<span class="type">IndexPath</span>(row: <span class="number">23</span>, section: <span class="number">0</span>)])
  
  <span class="comment">// then</span>
  <span class="call">XCTAssertTrue</span>(mockTableView.<span class="property">performBatchUpdatesCalled</span>)
}
</code></pre><h2>Step 3: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> TableViewController: <span class="type">UITableViewController</span> {
  
  <span class="keyword">func</span> remove(selected: [<span class="type">IndexPath</span>]) {
    tableView.<span class="call">performBatchUpdates</span>({
      <span class="comment">// delete model data
      // remove rows</span>
    })
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uitableview/chapter048</guid><title>Move Row</title><description>Test wheather a row is moved.</description><link>https://gimmetheco.de/uitableview/chapter048</link><pubDate>Fri, 16 Oct 2020 00:48:00 +0200</pubDate><content:encoded><![CDATA[<h1>Move Row</h1><p>Test wheather a row is moved</p><h2>Step 1: Table View Mock</h2><pre><code><span class="keyword">class</span> TableViewMock: <span class="type">UITableView</span> {
  
  <span class="keyword">var</span> movedFrom: <span class="type">IndexPath</span>? = <span class="keyword">nil
  var</span> movedTo: <span class="type">IndexPath</span>? = <span class="keyword">nil
  
  override func</span> moveRow(at indexPath: <span class="type">IndexPath</span>, to newIndexPath: <span class="type">IndexPath</span>) {
    movedFrom = indexPath
    movedTo = newIndexPath
  }
}
</code></pre><h2>Step 2: Test</h2><pre><code><span class="keyword">func</span> test_addUser_deletesRow() {
  <span class="comment">// given</span>
  <span class="keyword">let</span> mockTableView = <span class="type">TableViewMock</span>()
  sut.<span class="property">tableView</span> = mockTableView
  
  <span class="comment">// when</span>
  sut.<span class="call">moveUser</span>(at: <span class="number">2</span>, to: <span class="number">4</span>)
  
  <span class="comment">// then</span>
  <span class="call">XCTAssertEqual</span>(mockTableView.<span class="property">movedFrom</span>, <span class="type">IndexPath</span>(row: <span class="number">2</span>, section: <span class="number">0</span>))
  <span class="call">XCTAssertEqual</span>(mockTableView.<span class="property">movedTo</span>, <span class="type">IndexPath</span>(row: <span class="number">4</span>, section: <span class="number">0</span>))
}
</code></pre><h2>Step 3: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> TableViewController: <span class="type">UITableViewController</span> {
  
  <span class="keyword">func</span> moveUser(at index: <span class="type">Int</span>, to newIndex: <span class="type">Int</span>) {
    
    <span class="keyword">let</span> fromIndexPath = <span class="type">IndexPath</span>(row: index, section: <span class="number">0</span>)
    <span class="keyword">let</span> toIndexPath = <span class="type">IndexPath</span>(row: newIndex, section: <span class="number">0</span>)
    
    tableView.<span class="call">moveRow</span>(at: fromIndexPath, to: toIndexPath)
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uitableview/chapter047</guid><title>Delete Rows</title><description>Test wheather a row is deleted.</description><link>https://gimmetheco.de/uitableview/chapter047</link><pubDate>Fri, 16 Oct 2020 00:47:00 +0200</pubDate><content:encoded><![CDATA[<h1>Delete Rows</h1><p>Test wheather a row is deleted</p><h2>Step 1: Table View Mock</h2><pre><code><span class="keyword">class</span> TableViewMock: <span class="type">UITableView</span> {
  
  <span class="keyword">var</span> indexPathsOfDeletedRows: [<span class="type">IndexPath</span>] = []
  
  <span class="keyword">override func</span> deleteRows(at indexPaths: [<span class="type">IndexPath</span>], with animation: <span class="type">UITableView</span>.<span class="type">RowAnimation</span>) {
    indexPathsOfDeletedRows = indexPaths
  }
}
</code></pre><h2>Step 2: Test</h2><pre><code><span class="keyword">func</span> test_deleteUser_deletesRow() {
  <span class="comment">// given</span>
  <span class="keyword">let</span> mockTableView = <span class="type">TableViewMock</span>()
  sut.<span class="property">tableView</span> = mockTableView
  
  <span class="comment">// when</span>
  sut.<span class="call">deleteUser</span>(at: <span class="number">1</span>)
  
  <span class="comment">// then</span>
  <span class="keyword">let</span> expectedIndexPaths = [<span class="type">IndexPath</span>(row: <span class="number">1</span>, section: <span class="number">0</span>)]
  <span class="call">XCTAssertEqual</span>(mockTableView.<span class="property">indexPathsOfDeletedRows</span>, expectedIndexPaths)
}
</code></pre><h2>Step 3: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> TableViewController: <span class="type">UITableViewController</span> {
  
  <span class="keyword">func</span> deleteUser(at index: <span class="type">Int</span>) {
    <span class="keyword">let</span> indexPath = <span class="type">IndexPath</span>(row: <span class="number">1</span>, section: <span class="number">0</span>)
    tableView.<span class="call">deleteRows</span>(at: [indexPath], with: .<span class="dotAccess">automatic</span>)
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uitableview/chapter046</guid><title>Insert Rows</title><description>Test wheather a row is inserted.</description><link>https://gimmetheco.de/uitableview/chapter046</link><pubDate>Fri, 16 Oct 2020 00:46:00 +0200</pubDate><content:encoded><![CDATA[<h1>Insert Rows</h1><p>Test wheather a row is inserted</p><h2>Step 1: Table View Mock</h2><pre><code><span class="keyword">class</span> TableViewMock: <span class="type">UITableView</span> {
  
  <span class="keyword">var</span> indexPathsOfAddedRows: [<span class="type">IndexPath</span>] = []
  
  <span class="keyword">override func</span> insertRows(at indexPaths: [<span class="type">IndexPath</span>], with animation: <span class="type">UITableView</span>.<span class="type">RowAnimation</span>) {
    indexPathsOfAddedRows = indexPaths
  }
}
</code></pre><h2>Step 2: Test</h2><pre><code><span class="keyword">func</span> test_addUser_insertsRow() {
  <span class="comment">// given</span>
  <span class="keyword">let</span> mockTableView = <span class="type">TableViewMock</span>()
  sut.<span class="property">tableView</span> = mockTableView

  <span class="comment">// when</span>
  sut.<span class="call">addUser</span>()
  
  <span class="comment">// then</span>
  <span class="keyword">let</span> expectedIndexPaths = [<span class="type">IndexPath</span>(row: <span class="number">0</span>, section: <span class="number">0</span>)]
  <span class="call">XCTAssertEqual</span>(mockTableView.<span class="property">indexPathsOfAddedRows</span>, expectedIndexPaths)
}
</code></pre><h2>Step 3: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> TableViewController: <span class="type">UITableViewController</span> {
  
  <span class="keyword">func</span> addUser() {
    
    tableView.<span class="call">insertRows</span>(at: [<span class="type">IndexPath</span>(row: <span class="number">0</span>, section: <span class="number">0</span>)], with: .<span class="dotAccess">automatic</span>)
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uitableview/chapter045</guid><title>Dequeue A Header</title><description>Test wheather a header is dequeued.</description><link>https://gimmetheco.de/uitableview/chapter045</link><pubDate>Fri, 16 Oct 2020 00:45:00 +0200</pubDate><content:encoded><![CDATA[<h1>Dequeue A Header</h1><p>Test wheather a header is dequeued</p><h2>Step 1: Table View Mock</h2><pre><code><span class="keyword">class</span> TableViewMock: <span class="type">UITableView</span> {
  
  <span class="keyword">var</span> dequeueReusableHeaderCalls: [<span class="type">String</span>:<span class="type">Int</span>] = [:]
  
  <span class="keyword">override func</span> dequeueReusableHeaderFooterView(withIdentifier identifier: <span class="type">String</span>) -&gt; <span class="type">UITableViewHeaderFooterView</span>? {
    
    <span class="keyword">var</span> numberOfCalls = dequeueReusableHeaderCalls[identifier] ?? <span class="number">0</span>
    numberOfCalls += <span class="number">1</span>
    dequeueReusableHeaderCalls[identifier] = numberOfCalls
    
    <span class="keyword">return</span> <span class="type">UITableViewHeaderFooterView</span>()
  }
}
</code></pre><h2>Step 2: Test</h2><pre><code><span class="keyword">func</span> test_cellForRow_dequeuesHeader() {
  <span class="comment">// given</span>
  <span class="keyword">let</span> mockTableView = <span class="type">TableViewMock</span>()
  
  <span class="comment">// when</span>
  <span class="keyword">_</span> = sut.<span class="call">tableView</span>(mockTableView, viewForHeaderInSection: <span class="number">0</span>)
  
  <span class="comment">// then</span>
  <span class="call">XCTAssertEqual</span>(mockTableView.<span class="property">dequeueReusableHeaderCalls</span>[<span class="string">"Header"</span>], <span class="number">1</span>)
}
</code></pre><h2>Step 3: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> TableViewController: <span class="type">UITableViewController</span> {
  
  <span class="keyword">override func</span> viewDidLoad() {
    <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
    
    tableView.<span class="call">register</span>(<span class="type">UITableViewHeaderFooterView</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="string">"Header"</span>)
  }
  
  <span class="keyword">override func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, viewForHeaderInSection section: <span class="type">Int</span>) -&gt; <span class="type">UIView</span>? {
    
    <span class="keyword">let</span> header = tableView.<span class="call">dequeueReusableHeaderFooterView</span>(withIdentifier: <span class="string">"Header"</span>)
    
    <span class="keyword">return</span> header
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uitableview/chapter044</guid><title>Dequeue A Cell</title><description>Test wheather a cell is dequeued.</description><link>https://gimmetheco.de/uitableview/chapter044</link><pubDate>Fri, 16 Oct 2020 00:44:00 +0200</pubDate><content:encoded><![CDATA[<h1>Dequeue A Cell</h1><p>Test wheather a cell is dequeued</p><h3>Step 1: Table View Mock</h3><pre><code><span class="keyword">class</span> TableViewMock: <span class="type">UITableView</span> {
  
  <span class="keyword">var</span> dequeueReusableCellCalls: [<span class="type">String</span>:<span class="type">Int</span>] = [:]
  
  <span class="keyword">override func</span> dequeueReusableCell(withIdentifier identifier: <span class="type">String</span>, for indexPath: <span class="type">IndexPath</span>) -&gt; <span class="type">UITableViewCell</span> {
    
    <span class="keyword">var</span> numberOfCalls = dequeueReusableCellCalls[identifier] ?? <span class="number">0</span>
    numberOfCalls += <span class="number">1</span>
    dequeueReusableCellCalls[identifier] = numberOfCalls
    
    <span class="keyword">return</span> <span class="type">UITableViewCell</span>()
  }
}
</code></pre><h2>Step 2: Test</h2><pre><code><span class="keyword">func</span> test_cellForRow_dequeuesCell() {
  <span class="comment">// given</span>
  <span class="keyword">let</span> mockTableView = <span class="type">TableViewMock</span>()
  
  <span class="comment">// when</span>
  <span class="keyword">let</span> indexPath = <span class="type">IndexPath</span>(row: <span class="number">0</span>, section: <span class="number">0</span>)
  <span class="keyword">_</span> = sut.<span class="call">tableView</span>(mockTableView, cellForRowAt: indexPath)

  <span class="comment">// then</span>
  <span class="call">XCTAssertEqual</span>(mockTableView.<span class="property">dequeueReusableCellCalls</span>[<span class="string">"Cell"</span>], <span class="number">1</span>)
}
</code></pre><h2>Step 3: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> TableViewController: <span class="type">UITableViewController</span> {
  
  <span class="keyword">override func</span> viewDidLoad() {
    <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
    
    tableView.<span class="call">register</span>(<span class="type">UITableViewCell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="string">"Cell"</span>)
  }
  
  <span class="keyword">override func</span> tableView(<span class="keyword">_</span> tableView: <span class="type">UITableView</span>, cellForRowAt indexPath: <span class="type">IndexPath</span>) -&gt; <span class="type">UITableViewCell</span> {
    
    <span class="keyword">let</span> cell = tableView.<span class="call">dequeueReusableCell</span>(withIdentifier: <span class="string">"Cell"</span>, for: indexPath)
    
    <span class="keyword">return</span> cell
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uitableview/chapter043</guid><title>Register A Header</title><description>Test wheather headers are registered.</description><link>https://gimmetheco.de/uitableview/chapter043</link><pubDate>Fri, 16 Oct 2020 00:43:00 +0200</pubDate><content:encoded><![CDATA[<h1>Register A Header</h1><p>Test wheather headers are registered</p><h2>Step 1: Test</h2><pre><code><span class="keyword">func</span> test_loadingView_registersHeader() {
  <span class="comment">// when</span>
  sut.<span class="call">loadViewIfNeeded</span>()
  
  <span class="comment">// then</span>
  <span class="keyword">let</span> header = sut.<span class="property">tableView</span>.<span class="call">dequeueReusableHeaderFooterView</span>(withIdentifier: <span class="string">"Header"</span>)
  <span class="call">XCTAssertNotNil</span>(header)
}
</code></pre><h3>Step 2: Example code that makes the test pass</h3><pre><code><span class="keyword">class</span> TableViewController: <span class="type">UITableViewController</span> {
  
  <span class="keyword">override func</span> viewDidLoad() {
    <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
    
    tableView.<span class="call">register</span>(<span class="type">UITableViewHeaderFooterView</span>.<span class="keyword">self</span>, forHeaderFooterViewReuseIdentifier: <span class="string">"Header"</span>)
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uitableview/chapter042</guid><title>Register A Cell</title><description>Test wheather cells are registered.</description><link>https://gimmetheco.de/uitableview/chapter042</link><pubDate>Fri, 16 Oct 2020 00:42:00 +0200</pubDate><content:encoded><![CDATA[<h1>Register A Cell</h1><p>Test wheather cells are registered</p><h2>Step 1: Test</h2><pre><code><span class="keyword">func</span> test_loadingView_registersCell() {
  <span class="comment">// when</span>
  sut.<span class="call">loadViewIfNeeded</span>()
  
  <span class="comment">// then</span>
  <span class="keyword">let</span> cell = sut.<span class="property">tableView</span>.<span class="call">dequeueReusableCell</span>(withIdentifier: <span class="string">"Cell"</span>, for: <span class="type">IndexPath</span>(row: <span class="number">0</span>, section: <span class="number">0</span>))
  <span class="call">XCTAssertNotNil</span>(cell)
  <span class="call">XCTAssertTrue</span>(cell <span class="keyword">is</span> <span class="type">Cell</span>)
}
</code></pre><h2>Step 2: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> TableViewController: <span class="type">UITableViewController</span> {
  
  <span class="keyword">override func</span> viewDidLoad() {
    <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
    
    tableView.<span class="call">register</span>(<span class="type">Cell</span>.<span class="keyword">self</span>, forCellReuseIdentifier: <span class="string">"Cell"</span>)
  }
}

<span class="keyword">class</span> Cell: <span class="type">UITableViewCell</span> {}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uiview/chapter040</guid><title>Update Of Subviews</title><description>Test wheather subviews are updated.</description><link>https://gimmetheco.de/uiview/chapter040</link><pubDate>Fri, 16 Oct 2020 00:40:00 +0200</pubDate><content:encoded><![CDATA[<h1>Update Of Subviews</h1><p>Test wheather subviews are updated</p><h2>Step 1: Test</h2><pre><code><span class="keyword">func</span> test_updateWith_setsString() {
  <span class="comment">// when</span>
  sut.<span class="call">update</span>(with: <span class="string">"Foo"</span>)
  
  <span class="comment">// then</span>
  <span class="call">XCTAssertEqual</span>(sut.<span class="property">label</span>.<span class="property">text</span>, <span class="string">"Foo"</span>)
}
</code></pre><h2>Step 2: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> View: <span class="type">UIView</span> {
  
  <span class="keyword">let</span> label: <span class="type">UILabel</span>
  
  <span class="keyword">override init</span>(frame: <span class="type">CGRect</span>) {
    label = <span class="type">UILabel</span>()
    
    <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)
    
    <span class="call">addSubview</span>(label)
  }
  
  <span class="keyword">required init</span>?(coder aDecoder: <span class="type">NSCoder</span>) {
    <span class="call">fatalError</span>(<span class="string">"has not been implemented"</span>)
  }
  
  <span class="keyword">func</span> update(with input: <span class="type">String</span>) {
    label.<span class="property">text</span> = input
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uiview/chapter039</guid><title>Existence Of Subviews</title><description>Test wheather a view is in the view hierachy.</description><link>https://gimmetheco.de/uiview/chapter039</link><pubDate>Fri, 16 Oct 2020 00:39:00 +0200</pubDate><content:encoded><![CDATA[<h1>Existence Of Subviews</h1><p>Test wheather a view is in the view hierachy</p><h2>Step 1: Test</h2><pre><code><span class="keyword">func</span> test_labelIsSubview() {
  <span class="comment">// then</span>
  <span class="call">XCTAssertTrue</span>(sut.<span class="property">label</span>.<span class="call">isDescendant</span>(of: sut))
}
</code></pre><h2>Step 2: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> View: <span class="type">UIView</span> {
  
  <span class="keyword">let</span> label: <span class="type">UILabel</span>
  <span class="keyword">let</span> stackView: <span class="type">UIStackView</span>
  
  <span class="keyword">override init</span>(frame: <span class="type">CGRect</span>) {
    label = <span class="type">UILabel</span>()
    
    stackView = <span class="type">UIStackView</span>(arrangedSubviews:[label])
    
    <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)
    
    <span class="call">addSubview</span>(stackView)
  }
  
  <span class="keyword">required init</span>?(coder aDecoder: <span class="type">NSCoder</span>) {
    <span class="call">fatalError</span>(<span class="string">"has not been implemented"</span>)
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uiviewcontroller/chapter037</guid><title>Trigger viewWillDisappear and viewDidDisappear</title><description>Trigger view disappearance.</description><link>https://gimmetheco.de/uiviewcontroller/chapter037</link><pubDate>Fri, 16 Oct 2020 00:37:00 +0200</pubDate><content:encoded><![CDATA[<h1>Trigger viewWillDisappear and viewDidDisappear</h1><p>Trigger view disappearance</p><h2>Step 1: Test</h2><p>Call <code>beginAppearanceTransition(_:animated:)</code> and <code>endAppearanceTransition()</code></p><pre><code><span class="keyword">func</span> test_triggerViewDisappearing() {
  <span class="comment">// when</span>
  sut.<span class="call">beginAppearanceTransition</span>(<span class="keyword">false</span>, animated: <span class="keyword">false</span>)
  sut.<span class="call">endAppearanceTransition</span>()
  
  <span class="comment">// then</span>
  <span class="call">XCTAssertTrue</span>(sut.<span class="property">viewWillDisappearGotCalled</span>)
  <span class="call">XCTAssertTrue</span>(sut.<span class="property">viewDidDisappearGotCalled</span>)
}
</code></pre><h2>Step 2: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> ViewController: <span class="type">UIViewController</span> {
  
  <span class="keyword">var</span> viewWillDisappearGotCalled = <span class="keyword">false
  var</span> viewDidDisappearGotCalled = <span class="keyword">false
  
  override func</span> viewWillDisappear(<span class="keyword">_</span> animated: <span class="type">Bool</span>) {
    <span class="keyword">super</span>.<span class="call">viewWillDisappear</span>(animated)
    viewWillDisappearGotCalled = <span class="keyword">true</span>
  }
  
  <span class="keyword">override func</span> viewDidDisappear(<span class="keyword">_</span> animated: <span class="type">Bool</span>) {
    <span class="keyword">super</span>.<span class="call">viewDidDisappear</span>(animated)
    viewDidDisappearGotCalled = <span class="keyword">true</span>
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uiviewcontroller/chapter036</guid><title>Trigger viewWillAppear and viewDidAppear</title><description>Trigger view appearance.</description><link>https://gimmetheco.de/uiviewcontroller/chapter036</link><pubDate>Fri, 16 Oct 2020 00:36:00 +0200</pubDate><content:encoded><![CDATA[<h1>Trigger viewWillAppear and viewDidAppear</h1><p>Trigger view appearance</p><h2>Step 1: Test</h2><p>Call <code>beginAppearanceTransition(_:animated:)</code> and <code>endAppearanceTransition()</code></p><pre><code><span class="keyword">func</span> test_triggerViewAppearing() {
  <span class="comment">// when</span>
  sut.<span class="call">beginAppearanceTransition</span>(
    <span class="keyword">true</span>,
    animated: <span class="keyword">false</span>)
  sut.<span class="call">endAppearanceTransition</span>()
  
  <span class="comment">// then</span>
  <span class="call">XCTAssertTrue</span>(sut.<span class="property">viewWillAppearGotCalled</span>)
  <span class="call">XCTAssertTrue</span>(sut.<span class="property">viewDidAppearGotCalled</span>)
}
</code></pre><h2>Step 2: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> ViewController: <span class="type">UIViewController</span> {
  
  <span class="keyword">var</span> viewWillAppearGotCalled = <span class="keyword">false
  var</span> viewDidAppearGotCalled = <span class="keyword">false
  
  override func</span> viewWillAppear(<span class="keyword">_</span> animated: <span class="type">Bool</span>) {
    
    <span class="keyword">super</span>.<span class="call">viewWillAppear</span>(animated)
    viewWillAppearGotCalled = <span class="keyword">true</span>
  }
  
  <span class="keyword">override func</span> viewDidAppear(<span class="keyword">_</span> animated: <span class="type">Bool</span>) {
    
    <span class="keyword">super</span>.<span class="call">viewDidAppear</span>(animated)
    viewDidAppearGotCalled = <span class="keyword">true</span>
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/uiviewcontroller/chapter035</guid><title>Trigger loadView and viewDidLoad</title><description>Trigger view loading.</description><link>https://gimmetheco.de/uiviewcontroller/chapter035</link><pubDate>Fri, 16 Oct 2020 00:35:00 +0200</pubDate><content:encoded><![CDATA[<h1>Trigger loadView and viewDidLoad</h1><p>Trigger view loading</p><h2>Step 1: Test</h2><p>Call <code>loadViewIfNeeded</code></p><pre><code><span class="keyword">func</span> test_triggerViewLoading() {
  <span class="comment">// when</span>
  sut.<span class="call">loadViewIfNeeded</span>()

  <span class="comment">// then</span>
  <span class="call">XCTAssertTrue</span>(sut.<span class="property">loadViewGotCalled</span>)
  <span class="call">XCTAssertTrue</span>(sut.<span class="property">viewDidLoadGotCalled</span>)
}
</code></pre><h2>Step 2: Example code that makes the test green</h2><pre><code><span class="keyword">class</span> ViewController: <span class="type">UIViewController</span> {
  
  <span class="keyword">var</span> loadViewGotCalled = <span class="keyword">false
  var</span> viewDidLoadGotCalled = <span class="keyword">false
  
  override func</span> loadView() {
    loadViewGotCalled = <span class="keyword">true</span>
    view = <span class="type">UIView</span>()
  }
  
  <span class="keyword">override func</span> viewDidLoad() {
    <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
    viewDidLoadGotCalled = <span class="keyword">true</span>
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/easy_tests/chapter033</guid><title>Target-Action: Action Is Sent To Target</title><description>Test wheather the action is sent to the target.</description><link>https://gimmetheco.de/easy_tests/chapter033</link><pubDate>Fri, 16 Oct 2020 00:33:00 +0200</pubDate><content:encoded><![CDATA[<h1>Target-Action: Action Is Sent To Target</h1><p>Test wheather the action is sent to the target</p><h2>Step 1: Test</h2><pre><code><span class="keyword">func</span> test_buttonAction_increasesCount() {
  <span class="comment">// given</span>
  sut.<span class="call">loadViewIfNeeded</span>()
  <span class="call">XCTAssertEqual</span>(sut.<span class="property">count</span>, <span class="number">0</span>)
  
  <span class="comment">// when</span>
  sut.<span class="property">button</span>?.<span class="call">sendActions</span>(for: .<span class="dotAccess">touchUpInside</span>)
  
  <span class="comment">// then</span>
  <span class="call">XCTAssertEqual</span>(sut.<span class="property">count</span>, <span class="number">1</span>)
}
</code></pre><h2>Step 2: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> ViewController : <span class="type">UIViewController</span> {
  
  <span class="keyword">weak var</span> button: <span class="type">UIButton</span>?
  <span class="keyword">var</span> count = <span class="number">0</span>
  
  <span class="keyword">override func</span> viewDidLoad() {
    <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
    
    <span class="keyword">let</span> tempButton = <span class="type">UIButton</span>(type: .<span class="dotAccess">system</span>)
    tempButton.<span class="call">addTarget</span>(<span class="keyword">self</span>, action:<span class="keyword">#selector</span>(increaseCount), for: .<span class="dotAccess">touchUpInside</span>)
    
    view.<span class="call">addSubview</span>(tempButton)
    
    button = tempButton
  }
  
  <span class="keyword">@objc func</span> increaseCount() {
    count += <span class="number">1</span>
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/easy_tests/chapter031</guid><title>Calls Of Delegate Methods</title><description>Test wheather a delegate method is called.</description><link>https://gimmetheco.de/easy_tests/chapter031</link><pubDate>Fri, 16 Oct 2020 00:31:00 +0200</pubDate><content:encoded><![CDATA[<h1>Calls Of Delegate Methods</h1><p>Test wheather a delegate method is called</p><h2>Step 0: Delegate</h2><pre><code><span class="keyword">protocol</span> UserDelegate {
  <span class="keyword">func</span> score(for user: <span class="type">User</span>) -&gt; <span class="type">Int</span>
}
</code></pre><h2>Step 1: Mock For The Delegate</h2><pre><code><span class="keyword">class</span> UserDelegateMock : <span class="type">UserDelegate</span> {
  
  <span class="keyword">var</span> scoreCallUser: <span class="type">User</span>? = <span class="keyword">nil
  
  func</span> score(for user: <span class="type">User</span>) -&gt; <span class="type">Int</span> {
    scoreCallUser = user
    <span class="keyword">return</span> <span class="number">0</span>
  }
}
</code></pre><h2>Step 2: Test</h2><pre><code><span class="keyword">class</span> UserViewControllerTests : <span class="type">XCTestCase</span> {
  
  <span class="keyword">var</span> sut: <span class="type">UserViewController</span>!
  <span class="keyword">var</span> delegate: <span class="type">UserDelegateMock</span>!
  
  <span class="keyword">override func</span> setUpWithError() <span class="keyword">throws</span> {
    sut = <span class="type">UserViewController</span>()
    delegate = <span class="type">UserDelegateMock</span>()
    sut.<span class="property">delegate</span> = delegate
  }
  
  <span class="keyword">override func</span> tearDownWithError() <span class="keyword">throws</span> {
    sut = <span class="keyword">nil</span>
    delegate = <span class="keyword">nil</span>
  }
  
  <span class="keyword">func</span> test_viewLoading_callsScoreForUser() {
    <span class="comment">// when</span>
    sut.<span class="call">loadViewIfNeeded</span>()
    
    <span class="comment">// then</span>
    <span class="call">XCTAssertEqual</span>(delegate.<span class="property">scoreCallUser</span>, sut.<span class="property">user</span>)
  }
}
</code></pre><h2>Step 3: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> UserViewController : <span class="type">UIViewController</span> {
  <span class="keyword">var</span> delegate: <span class="type">UserDelegate</span>? = <span class="keyword">nil
  let</span> user = <span class="type">User</span>(name: <span class="string">"Foobar"</span>)
  
  <span class="keyword">override func</span> viewDidLoad() {
    <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
    
    delegate?.<span class="call">score</span>(for: user)
  }
}

<span class="keyword">struct</span> User : <span class="type">Equatable</span> {
  <span class="keyword">let</span> name: <span class="type">String</span>
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/easy_tests/chapter030</guid><title>Changes Of Property Values</title><description>Test wheather a property value is changed.</description><link>https://gimmetheco.de/easy_tests/chapter030</link><pubDate>Fri, 16 Oct 2020 00:30:00 +0200</pubDate><content:encoded><![CDATA[<h1>Changes Of Property Values</h1><p>Test wheather a property value is changed</p><h2>Step 1: Test</h2><pre><code><span class="keyword">func</span> test_name_property() {
  <span class="comment">// when</span>
  sut.<span class="property">firstname</span> = <span class="string">"Foo"</span>
  sut.<span class="property">lastname</span> = <span class="string">"Bar"</span>
  
  <span class="comment">// then</span>
  <span class="call">XCTAssertEqual</span>(sut.<span class="property">name</span>, <span class="string">"Foo Bar"</span>)
}
</code></pre><h2>Step 2: Example code that makes the test pass</h2><pre><code><span class="keyword">struct</span> User {
  <span class="keyword">var</span> firstname: <span class="type">String</span> = <span class="string">""</span> {
    <span class="keyword">didSet</span> {
      <span class="call">updateName</span>(firstname: firstname, lastname: lastname)
    }
  }
  <span class="keyword">var</span> lastname: <span class="type">String</span> = <span class="string">""</span> {
    <span class="keyword">didSet</span> {
      <span class="call">updateName</span>(firstname: firstname, lastname: lastname)
    }
  }
  <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">""</span>
  
  <span class="keyword">private mutating func</span> updateName(firstname: <span class="type">String</span>, lastname: <span class="type">String</span>) {
    name = <span class="string">"</span>\(firstname) \(lastname)<span class="string">"</span>
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/expectations/chapter027</guid><title>Waiting For Expectations</title><description></description><link>https://gimmetheco.de/expectations/chapter027</link><pubDate>Fri, 16 Oct 2020 00:27:00 +0200</pubDate><content:encoded><![CDATA[<h1>Waiting For Expectations</h1><h2>Waiting For A List Of Expectations</h2><pre><code><span class="call">wait</span>(for: [asyncExpectation], timeout: <span class="number">1</span>)
</code></pre><h2>Waiting For A List Of Expectations Enforcing The Order</h2><pre><code><span class="call">wait</span>(for: [expectation1, expectation2], timeout: <span class="number">1</span>, enforceOrder: <span class="keyword">true</span>)
</code></pre><h2>Wait For All Expectations</h2><pre><code><span class="call">waitForExpectations</span>(timeout: <span class="number">1</span>) { error <span class="keyword">in</span>
  <span class="comment">// completion handler is called on
  // timeout (error != nil or fulfillment
  // (error == nil).</span>
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/expectations/chapter026</guid><title>XCTNSPredicateExpectation</title><description>Set expectation that a predicate is fulfilled.</description><link>https://gimmetheco.de/expectations/chapter026</link><pubDate>Fri, 16 Oct 2020 00:26:00 +0200</pubDate><content:encoded><![CDATA[<h1>XCTNSPredicateExpectation</h1><p>Set expectation that a predicate is fulfilled</p><h2>Step 1: Test</h2><pre><code><span class="keyword">func</span> test_predicate() {
  <span class="comment">// Arrage</span>
  <span class="keyword">let</span> predicate = <span class="type">NSPredicate</span>(format: <span class="string">"name = %@"</span>, <span class="string">"Foo Bar"</span>)
  <span class="keyword">let</span> predicateExp = <span class="call">expectation</span>(for: predicate, evaluatedWith: sut) { () -&gt; <span class="type">Bool</span> <span class="keyword">in
    return true</span>
  }
  
  <span class="comment">// when</span>
  sut.<span class="property">firstname</span> = <span class="string">"Foo"</span>
  sut.<span class="property">lastname</span> = <span class="string">"Bar"</span>
  
  <span class="comment">// then</span>
  <span class="call">wait</span>(for: [predicateExp], timeout: <span class="number">1</span>)
}
</code></pre><h2>Step 2: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> User: <span class="type">NSObject</span> {
  <span class="keyword">var</span> firstname: <span class="type">String</span> = <span class="string">""</span> {
    <span class="keyword">didSet</span> {
      <span class="call">updateName</span>(firstname: firstname, lastname: lastname)
    }
  }
  <span class="keyword">var</span> lastname: <span class="type">String</span> = <span class="string">""</span> {
    <span class="keyword">didSet</span> {
      <span class="call">updateName</span>(firstname: firstname, lastname: lastname)
    }
  }
  <span class="keyword">@objc dynamic var</span> name: <span class="type">String</span> = <span class="string">""</span>
  
  <span class="keyword">private func</span> updateName(firstname: <span class="type">String</span>, lastname: <span class="type">String</span>) {
    
    <span class="keyword">if</span> firstname.<span class="property">count</span> &gt; <span class="number">0</span> &amp;&amp; lastname.<span class="property">count</span> &gt; <span class="number">0</span> {
      name = <span class="string">"</span>\(firstname) \(lastname)<span class="string">"</span>
    }
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/expectations/chapter025</guid><title>XCTNSNotificationExpectation</title><description>Set an expectation that a notification is sent.</description><link>https://gimmetheco.de/expectations/chapter025</link><pubDate>Fri, 16 Oct 2020 00:25:00 +0200</pubDate><content:encoded><![CDATA[<h1>XCTNSNotificationExpectation</h1><p>Set an expectation that a notification is sent</p><h2>Step 1: Test</h2><pre><code><span class="keyword">func</span> test_settingScore_sendsNotification() {
  <span class="comment">// Arrage</span>
  <span class="call">expectation</span>(forNotification: notificationName, object: <span class="keyword">nil</span>, handler: <span class="keyword">nil</span>)
  
  <span class="comment">// when</span>
  sut.<span class="property">score</span> = <span class="number">5</span>
  
  <span class="comment">// then</span>
  <span class="call">waitForExpectations</span>(timeout: <span class="number">1</span>, handler: <span class="keyword">nil</span>)
}
</code></pre><h2>Step 2: Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> User {
  <span class="keyword">var</span> score: <span class="type">Int</span> {
    <span class="keyword">didSet</span> {
      <span class="type">NotificationCenter</span>.<span class="property">default</span>.<span class="call">post</span>(name: notificationName, object: <span class="keyword">self</span>)
    }
  }
  
  <span class="keyword">init</span>(score: <span class="type">Int</span>) {
    <span class="keyword">self</span>.<span class="property">score</span> = score
  }
}

<span class="keyword">let</span> notificationName = <span class="type">NSNotification</span>.<span class="type">Name</span>(<span class="string">"DDHScoreDidChange"</span>)
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/expectations/chapter024</guid><title>XCTKVOExpectation With Handler</title><description>Set an expectation that a value is set to a given key path. With completion handler.</description><link>https://gimmetheco.de/expectations/chapter024</link><pubDate>Fri, 16 Oct 2020 00:24:00 +0200</pubDate><content:encoded><![CDATA[<h1>XCTKVOExpectation With Handler</h1><p>Set an expectation that a value is set to a given key path. With completion handler.</p><h2>Step 1: Test</h2><pre><code><span class="keyword">func</span> test_kvo() {
  <span class="comment">// given</span>
  <span class="keyword">let</span> kvoExpectation = <span class="call">keyValueObservingExpectation</span>(for: sut <span class="keyword">as</span> <span class="type">Any</span>, keyPath: <span class="string">"name"</span>) { observed, changes -&gt; <span class="type">Bool</span> <span class="keyword">in
    
    guard let</span> new = changes[<span class="string">"new"</span>] <span class="keyword">as</span>? <span class="type">String</span> <span class="keyword">else</span> {
      <span class="keyword">return false</span>
    }
    
    <span class="keyword">return</span> new == <span class="string">"Foo Bar"</span>
  }
  
  <span class="comment">// when</span>
  sut.<span class="property">firstname</span> = <span class="string">"Foo"</span>
  sut.<span class="property">lastname</span> = <span class="string">"Bar"</span>
  
  <span class="comment">// then</span>
  <span class="call">wait</span>(for: [kvoExpectation], timeout: <span class="number">1</span>)
}
</code></pre><h2>Step 2: Example code that makes the test green</h2><pre><code><span class="keyword">class</span> User: <span class="type">NSObject</span> {
  <span class="keyword">var</span> firstname: <span class="type">String</span> = <span class="string">""</span> {
    <span class="keyword">didSet</span> {
      <span class="call">updateName</span>(firstname: firstname, lastname: lastname)
    }
  }
  <span class="keyword">var</span> lastname: <span class="type">String</span> = <span class="string">""</span> {
    <span class="keyword">didSet</span> {
      <span class="call">updateName</span>(firstname: firstname, lastname: lastname)
    }
  }
  <span class="keyword">@objc dynamic var</span> name: <span class="type">String</span> = <span class="string">""</span>
  
  <span class="keyword">private func</span> updateName(firstname: <span class="type">String</span>, lastname: <span class="type">String</span>) {
    
    <span class="keyword">if</span> firstname.<span class="property">count</span> &gt; <span class="number">0</span> &amp;&amp; lastname.<span class="property">count</span> &gt; <span class="number">0</span> {
      name = <span class="string">"</span>\(firstname) \(lastname)<span class="string">"</span>
    }
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/expectations/chapter023</guid><title>XCTKVOExpectation With Expected Value</title><description>Set an expectation that an expected value is set to a given key path.</description><link>https://gimmetheco.de/expectations/chapter023</link><pubDate>Fri, 16 Oct 2020 00:23:00 +0200</pubDate><content:encoded><![CDATA[<h1>XCTKVOExpectation With Expected Value</h1><p>Set an expectation that an expected value is set to a given key path</p><h2>Step 1: Test</h2><pre><code>   <span class="keyword">func</span> test_kvo() {
    <span class="comment">// given</span>
    <span class="keyword">let</span> kvoExpectation = <span class="call">keyValueObservingExpectation</span>(for: sut <span class="keyword">as</span> <span class="type">Any</span>, keyPath: <span class="string">"name"</span>, expectedValue: <span class="string">"Foo Bar"</span>)
    
    <span class="comment">// when</span>
    sut.<span class="property">firstname</span> = <span class="string">"Foo"</span>
    sut.<span class="property">lastname</span> = <span class="string">"Bar"</span>
    
    <span class="comment">// then</span>
    <span class="call">wait</span>(for: [kvoExpectation], timeout: <span class="number">1</span>)
  }
</code></pre><h2>Step 2: Example code that makes the test green</h2><pre><code><span class="keyword">class</span> User: <span class="type">NSObject</span> {
  <span class="keyword">var</span> firstname: <span class="type">String</span> = <span class="string">""</span> {
    <span class="keyword">didSet</span> {
      <span class="call">updateName</span>(firstname: firstname, lastname: lastname)
    }
  }
  <span class="keyword">var</span> lastname: <span class="type">String</span> = <span class="string">""</span> {
    <span class="keyword">didSet</span> {
      <span class="call">updateName</span>(firstname: firstname, lastname: lastname)
    }
  }
  <span class="keyword">@objc dynamic var</span> name: <span class="type">String</span> = <span class="string">""</span>
  
  <span class="keyword">private func</span> updateName(firstname: <span class="type">String</span>, lastname: <span class="type">String</span>) {
    <span class="keyword">if</span> firstname.<span class="property">count</span> &gt; <span class="number">0</span> &amp;&amp; lastname.<span class="property">count</span> &gt; <span class="number">0</span> {
      name = <span class="string">"</span>\(firstname) \(lastname)<span class="string">"</span>
    }
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/expectations/chapter022</guid><title>XCTestExpectation</title><description>Set an expectation and wait unitl it's fulfilled.</description><link>https://gimmetheco.de/expectations/chapter022</link><pubDate>Fri, 16 Oct 2020 00:22:00 +0200</pubDate><content:encoded><![CDATA[<h1>XCTestExpectation</h1><p>Set an expectation and wait unitl it's fulfilled</p><h2>Step 1: Test</h2><p>Wait for a list of expectations.</p><pre><code>   <span class="keyword">func</span> test_asynTask_waitForList() {
    <span class="comment">// given</span>
    <span class="keyword">let</span> asyncExpectation = <span class="call">expectation</span>(description: <span class="string">"async"</span>)
    
    <span class="comment">// when</span>
    <span class="keyword">var</span> result: <span class="type">Bool</span>? = <span class="keyword">nil</span>
    sut.<span class="call">asyncTask</span> { success <span class="keyword">in</span>
      result = success
      asyncExpectation.<span class="call">fulfill</span>()
    }
    
    <span class="comment">// then</span>
    <span class="call">wait</span>(for: [asyncExpectation], timeout: <span class="number">1</span>)
    <span class="call">XCTAssertTrue</span>(result ?? <span class="keyword">false</span>)
  }
</code></pre><p>Wait for all set expectations.</p><pre><code>   <span class="keyword">func</span> test_asynTask_waitForAll() {
    <span class="comment">// given</span>
    <span class="keyword">let</span> asyncExpectation = <span class="call">expectation</span>(description: <span class="string">"async"</span>)
    
    <span class="comment">// when</span>
    <span class="keyword">var</span> result: <span class="type">Bool</span>? = <span class="keyword">nil</span>
    sut.<span class="call">asyncTask</span> { success <span class="keyword">in</span>
      result = success
      asyncExpectation.<span class="call">fulfill</span>()
    }
    
    <span class="comment">// then</span>
    <span class="call">waitForExpectations</span>(timeout: <span class="number">1</span>) { error <span class="keyword">in</span>
      <span class="comment">// completion handler is called on
      // timeout (error != nil or fulfillment
      // (error == nil).</span>
    }
    <span class="call">XCTAssertTrue</span>(result ?? <span class="keyword">false</span>)
  }
</code></pre><h2>Step 2: Example code that makes the test green</h2><pre><code><span class="keyword">struct</span> Worker {
  
  <span class="keyword">func</span> asyncTask(completion: <span class="keyword">@escaping</span> (<span class="type">Bool</span>) -&gt; <span class="type">Void</span>) {
    
    <span class="type">DispatchQueue</span>.<span class="call">global</span>(qos: .<span class="dotAccess">background</span>).<span class="call">asyncAfter</span>(deadline: .<span class="call">now</span>() + <span class="number">0.1</span>) {
      <span class="call">completion</span>(<span class="keyword">true</span>)
    }
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/mocks/chapter020</guid><title>Stubs</title><description>Stubs are used when you need to test whether the system under test reacts to data it gets from another class or module in an expected way. Common examples are UserDefaults and network requests.</description><link>https://gimmetheco.de/mocks/chapter020</link><pubDate>Fri, 16 Oct 2020 00:20:00 +0200</pubDate><content:encoded><![CDATA[<h1>Stubs</h1><p>Stubs are used when you need to test whether the system under test reacts to data it gets from another class or module in an expected way. Common examples are UserDefaults and network requests.</p><h2>Example Stub</h2><pre><code><span class="keyword">class</span> UserDefaultsStub : <span class="type">UserDefaults</span> {
  
  <span class="keyword">private let</span> boolToReturn: <span class="type">Bool</span>
  <span class="keyword">var</span> defaultName: <span class="type">String</span>? = <span class="keyword">nil
  
  init</span>(boolToReturn: <span class="type">Bool</span>) {
    <span class="keyword">self</span>.<span class="property">boolToReturn</span> = boolToReturn
    
    <span class="keyword">super</span>.<span class="keyword">init</span>(suiteName: <span class="keyword">nil</span>)!
  }
  
  <span class="keyword">override func</span> bool(forKey defaultName: <span class="type">String</span>) -&gt; <span class="type">Bool</span> {
    <span class="keyword">self</span>.<span class="property">defaultName</span> = defaultName
    <span class="keyword">return</span> boolToReturn
  }
}
</code></pre><h2>Usage</h2><pre><code>   <span class="keyword">func</span> test_appearance_whenFirstStart_showsOnboarding() {
    <span class="comment">// given</span>
    <span class="keyword">let</span> stubUserDefaults = <span class="type">UserDefaultsStub</span>(boolToReturn: <span class="keyword">false</span>)
    sut.<span class="property">userDefaults</span> = stubUserDefaults
    
    <span class="comment">// when</span>
    sut.<span class="call">beginAppearanceTransition</span>(<span class="keyword">true</span>, animated: <span class="keyword">false</span>)
    sut.<span class="call">endAppearanceTransition</span>()
    
    <span class="comment">// then</span>
    <span class="call">XCTAssertTrue</span>(sut.<span class="property">presentedViewController</span> <span class="keyword">is</span> <span class="type">OnboardingViewController</span>)
    <span class="call">XCTAssertEqual</span>(stubUserDefaults.<span class="property">defaultName</span>, <span class="string">"AlreadyStartedKey"</span>)
  }
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/mocks/chapter019</guid><title>Mocks</title><description>Mocks are used when you need to verify that your system under test interacts with another class in an expeced way. It's often a good idea to define the interaction of the system under test and the class to be mocked with a protocol.</description><link>https://gimmetheco.de/mocks/chapter019</link><pubDate>Fri, 16 Oct 2020 00:19:00 +0200</pubDate><content:encoded><![CDATA[<h1>Mocks</h1><p>Mocks are used when you need to verify that your system under test interacts with another class in an expeced way. It's often a good idea to define the interaction of the system under test and the class to be mocked with a protocol.</p><h2>Protocol</h2><pre><code><span class="keyword">protocol</span> UserUpdateable {
  <span class="keyword">func</span> update(with: <span class="type">User</span>)
}
</code></pre><h2>Example Mock</h2><pre><code><span class="keyword">class</span> ViewMock : <span class="type">UIView</span>, <span class="type">UserUpdateable</span> {

  <span class="keyword">var</span> updateUser: <span class="type">User</span>? = <span class="keyword">nil
  
  func</span> update(with user: <span class="type">User</span>) {
    updateUser = user
  }
}
</code></pre><h2>Usage</h2><pre><code>   <span class="keyword">func</span> test_settingUser_callsUpdate() {
    <span class="comment">// given</span>
    <span class="keyword">let</span> viewMock = <span class="type">ViewMock</span>()
    sut.<span class="property">view</span> = viewMock
    <span class="keyword">let</span> user = <span class="type">User</span>(name: <span class="string">"Foo"</span>, lastname: <span class="string">"Bar"</span>)
    
    <span class="comment">// when</span>
    sut.<span class="property">user</span> = user
    
    <span class="comment">// then</span>
    <span class="call">XCTAssertEqual</span>(viewMock.<span class="property">updateUser</span>, user)
  }
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/depenency_injection/chapter017</guid><title>Interface Injection</title><description></description><link>https://gimmetheco.de/depenency_injection/chapter017</link><pubDate>Fri, 16 Oct 2020 00:17:00 +0200</pubDate><content:encoded><![CDATA[<h1>Interface Injection</h1><p>Inject dependency via interface</p><h2>Step 1: Protocols</h2><pre><code><span class="keyword">import</span> Foundation

<span class="keyword">protocol</span> DefaultsProtocol {
  <span class="keyword">func</span> bool(forKey: <span class="type">String</span>) -&gt; <span class="type">Bool</span>
}

<span class="keyword">extension</span> <span class="type">UserDefaults</span> : <span class="type">DefaultsProtocol</span> {}

<span class="keyword">protocol</span> InjectDependencyProtocol {
  <span class="keyword">mutating func</span> inject(defaults: <span class="type">DefaultsProtocol</span>)
}
</code></pre><h2>Step 2: Injection Point</h2><pre><code><span class="keyword">struct</span> User : <span class="type">InjectDependencyProtocol</span> {
  <span class="keyword">private lazy var</span> defaults: <span class="type">DefaultsProtocol</span> = <span class="type">UserDefaults</span>.<span class="property">standard</span>
  
  <span class="keyword">mutating func</span> inject(defaults: <span class="type">DefaultsProtocol</span>) {
    <span class="keyword">self</span>.<span class="property">defaults</span> = defaults
  }
}
</code></pre><h2>Step 3: Fake Object</h2><pre><code><span class="keyword">struct</span> DefaultsMock : <span class="type">DefaultsProtocol</span> {
  <span class="keyword">let</span> boolToReturn: <span class="type">Bool</span>
  
  <span class="keyword">func</span> bool(forKey: <span class="type">String</span>) -&gt; <span class="type">Bool</span> {
    <span class="keyword">return</span> boolToReturn
  }
}
</code></pre><h2>Step 4: Injection</h2><pre><code><span class="keyword">let</span> defaultsMock = <span class="type">DefaultsMock</span>(boolToReturn: <span class="keyword">false</span>)
<span class="keyword">var</span> user = <span class="type">User</span>()
user.<span class="call">inject</span>(defaults: defaultsMock)
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/depenency_injection/chapter016</guid><title>Setter Injection</title><description></description><link>https://gimmetheco.de/depenency_injection/chapter016</link><pubDate>Fri, 16 Oct 2020 00:16:00 +0200</pubDate><content:encoded><![CDATA[<h1>Setter Injection</h1><p>Inject dependency via setter</p><h2>Step 1: Protocol</h2><pre><code><span class="keyword">import</span> Foundation

<span class="keyword">protocol</span> DefaultsProtocol {
  <span class="keyword">func</span> bool(forKey: <span class="type">String</span>) -&gt; <span class="type">Bool</span>
}

<span class="keyword">extension</span> <span class="type">UserDefaults</span> : <span class="type">DefaultsProtocol</span> {}
</code></pre><h2>Step 2: Injection Point</h2><pre><code><span class="keyword">struct</span> User {
  <span class="keyword">lazy var</span> defaults: <span class="type">DefaultsProtocol</span> = <span class="type">UserDefaults</span>.<span class="property">standard</span>
}
</code></pre><h2>Step 3: Fake Object</h2><pre><code><span class="keyword">struct</span> DefaultsStub : <span class="type">DefaultsProtocol</span> {
  <span class="keyword">let</span> boolToReturn: <span class="type">Bool</span>
  
  <span class="keyword">func</span> bool(forKey: <span class="type">String</span>) -&gt; <span class="type">Bool</span> {
    <span class="keyword">return</span> boolToReturn
  }
}
</code></pre><h2>Step 4: Injection</h2><pre><code><span class="keyword">let</span> defaultsStub = <span class="type">DefaultsStub</span>(boolToReturn: <span class="keyword">false</span>)
<span class="keyword">var</span> user = <span class="type">User</span>()
user.<span class="property">defaults</span> = defaultsStub
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/depenency_injection/chapter015</guid><title>Constructor Injection</title><description></description><link>https://gimmetheco.de/depenency_injection/chapter015</link><pubDate>Fri, 16 Oct 2020 00:15:00 +0200</pubDate><content:encoded><![CDATA[<h1>Constructor Injection</h1><p>Inject dependency in constructor</p><h2>Step 1: Protocol</h2><pre><code><span class="keyword">import</span> Foundation

<span class="keyword">protocol</span> DefaultsProtocol {
  <span class="keyword">func</span> bool(forKey: <span class="type">String</span>) -&gt; <span class="type">Bool</span>
}

<span class="keyword">extension</span> <span class="type">UserDefaults</span> : <span class="type">DefaultsProtocol</span> {}
</code></pre><h2>Step 2: The Injection Point</h2><pre><code><span class="keyword">struct</span> User {
  <span class="keyword">let</span> defaults: <span class="type">DefaultsProtocol</span>
  
  <span class="keyword">init</span>(defaults: <span class="type">DefaultsProtocol</span> = <span class="type">UserDefaults</span>.<span class="property">standard</span>) {
    <span class="keyword">self</span>.<span class="property">defaults</span> = defaults
  }
}
</code></pre><h2>Step 3: Fake Object</h2><pre><code><span class="keyword">struct</span> DefaultsStub : <span class="type">DefaultsProtocol</span> {
  <span class="keyword">let</span> boolToReturn: <span class="type">Bool</span>
  
  <span class="keyword">func</span> bool(forKey: <span class="type">String</span>) -&gt; <span class="type">Bool</span> {
    <span class="keyword">return</span> boolToReturn
  }
}
</code></pre><h2>Step 4: Injection</h2><pre><code><span class="keyword">let</span> defaultsStub = <span class="type">DefaultsStub</span>(boolToReturn: <span class="keyword">false</span>)
<span class="keyword">let</span> user = <span class="type">User</span>(defaults: defaultsStub)
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/depenency_injection/chapter014</guid><title>Dependency Injection</title><description></description><link>https://gimmetheco.de/depenency_injection/chapter014</link><pubDate>Fri, 16 Oct 2020 00:14:00 +0200</pubDate><content:encoded><![CDATA[<h1>Dependency Injection</h1><p>The different components in your code base depend on each other and on other frameworks (Apple and 3rd party). An example:</p><pre><code><span class="keyword">import</span> Foundation

<span class="keyword">func</span> loadBooks() {
  <span class="keyword">guard let</span> url = <span class="type">URL</span>(string: <span class="string">"http://example.com/books"</span>) <span class="keyword">else</span> {
    <span class="call">fatalError</span>()
  }
  
  <span class="type">URLSession</span>.<span class="property">shared</span>.<span class="call">dataTask</span>(with: url) { data, response, error <span class="keyword">in</span>
    
    <span class="comment">// do stuff</span>
    
    }.<span class="call">resume</span>()
}
</code></pre><p>This code depends on <code>URLSession</code> and its implementation of <code>dataTask(with:completionHandler:)</code>. In a test you often like to exchange such dependencies to make the tests faster and to make testing different scenarios easier. You'd like to 'inject the dependency'. This is sometimes also called 'inversion of control'.</p><h2>Advantages of Dependency Injection</h2><ol><li>In unit tests you need to control the behaviour of the dependencies to be able to test all relevant scenarios (error handling, edge cases, happy path).</li><li>In unit tests you need to replace long running computations (like network calls, data base access, complicated computations) with instant return of fake data.</li><li>You'd like to decouple the different parts of your code from each other and control how they interact from the outside. This also improves readability of your code.</li></ol><h2>How to inject dependencies</h2><p>There are three main ways to inject dependencies.</p><ol><li>Constructor injection</li><li>Setter injection</li><li>Interface injection</li></ol>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/general/chapter013</guid><title>func addTeardownBlock( block:)</title><description></description><link>https://gimmetheco.de/general/chapter013</link><pubDate>Fri, 16 Oct 2020 00:13:00 +0200</pubDate><content:encoded><![CDATA[<h1>func addTeardownBlock(_ block:)</h1><blockquote><p><strong>Apple docs:</strong> &gt; &gt; Call addTeardownBlock(_:) during a test method's execution to register a block of code to be called when the test method ends. &gt; Example is from the Apple docs.</p></blockquote><pre><code><span class="keyword">class</span> ReadAndWriteTests: <span class="type">XCTestCase</span> {
  
  <span class="keyword">func</span> temporaryFileURL() -&gt; <span class="type">URL</span> {
    
    <span class="keyword">let</span> directory = <span class="type">NSTemporaryDirectory</span>()
    <span class="keyword">let</span> filename = <span class="type">UUID</span>().<span class="property">uuidString</span>
    <span class="keyword">let</span> fileURL = <span class="type">URL</span>(fileURLWithPath: directory).<span class="call">appendingPathComponent</span>(filename)
    
    <span class="comment">// Add a teardown block to delete any file
    // at `fileURL`.</span>
    <span class="call">addTeardownBlock</span> {
      <span class="keyword">do</span> {
        <span class="keyword">let</span> fileManager = <span class="type">FileManager</span>.<span class="property">default</span>
        
        <span class="keyword">if</span> fileManager.<span class="call">fileExists</span>(atPath: fileURL.<span class="property">path</span>) {
          
          <span class="keyword">try</span> fileManager.<span class="call">removeItem</span>(at: fileURL)
          
          <span class="call">XCTAssertFalse</span>(fileManager.<span class="call">fileExists</span>(atPath: fileURL.<span class="property">path</span>))
        }
      } <span class="keyword">catch</span> {
        <span class="type">XCTFail</span>(<span class="string">"Error:</span> \(error)<span class="string">"</span>)
      }
    }
    <span class="keyword">return</span> fileURL
  }
  
  <span class="keyword">func</span> testReadAndWriteDataToTemporaryFile() {
    
    <span class="keyword">let</span> fileURL = <span class="call">temporaryFileURL</span>()
    
    <span class="keyword">let</span> originalString = <span class="string">"Hello there"</span>
    
    <span class="keyword">do</span> {
      <span class="keyword">try</span> originalString.<span class="call">write</span>(to: fileURL, atomically: <span class="keyword">true</span>, encoding: .<span class="dotAccess">utf8</span>)

      <span class="keyword">let</span> readString = <span class="keyword">try</span> <span class="type">String</span>(contentsOf: fileURL, encoding: .<span class="dotAccess">utf8</span>)

      <span class="call">XCTAssertEqual</span>(readString, originalString)
    } <span class="keyword">catch</span> {
      <span class="type">XCTFail</span>(<span class="string">"Error:</span> \(error)<span class="string">"</span>)
    }
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/general/chapter012</guid><title>func setUpWithError() and func tearDownWithError()</title><description></description><link>https://gimmetheco.de/general/chapter012</link><pubDate>Fri, 16 Oct 2020 00:12:00 +0200</pubDate><content:encoded><![CDATA[<h1><code>func setUpWithError()</code> and <code>func tearDownWithError()</code></h1><blockquote><p><strong>Apple docs:</strong> &gt; &gt; Before each test begins, XCTest calls setUpWithError(), followed by setUp(). If state preparation might throw errors, override setUpWithError(). XCTest marks the test failed when when it catches errors, or skipped when it catches XCTSkip. &gt; &gt; ... &gt; &gt; After each test completes, XCTest calls tearDown(), followed by tearDownWithError(). If state cleanup might throw errors, override tearDownWithError(). XCTest marks the test failed when when it catches errors, or skipped when it catches XCTSkip.</p></blockquote><pre><code><span class="keyword">class</span> ViewTests : <span class="type">XCTestCase</span> {
  
  <span class="keyword">var</span> sut: <span class="type">View</span>!
  
  <span class="keyword">override func</span> setUpWithError() <span class="keyword">throws</span> {
    sut = <span class="type">View</span>()
  }
  
  <span class="keyword">override func</span> tearDownWithError() <span class="keyword">throws</span> {
    sut = <span class="keyword">nil</span>
  }
  
  <span class="keyword">func</span> test_labelIsSubview() {
    <span class="comment">// then</span>
    <span class="call">XCTAssertTrue</span>(sut.<span class="property">label</span>.<span class="call">isDescendant</span>(of: sut))
  }
}
</code></pre><h2>Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> View : <span class="type">UIView</span> {
  
  <span class="keyword">let</span> label: <span class="type">UILabel</span>
  
  <span class="keyword">override init</span>(frame: <span class="type">CGRect</span>) {
    label = <span class="type">UILabel</span>()
    
    <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)
    
    <span class="call">addSubview</span>(label)
  }
  
  <span class="keyword">required init</span>?(coder aDecoder: <span class="type">NSCoder</span>) { <span class="call">fatalError</span>() }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/general/chapter011</guid><title>func setUp() and func tearDown()</title><description></description><link>https://gimmetheco.de/general/chapter011</link><pubDate>Fri, 16 Oct 2020 00:11:00 +0200</pubDate><content:encoded><![CDATA[<h1><code>func setUp()</code> and <code>func tearDown()</code></h1><blockquote><p><strong>Apple docs:</strong> &gt; &gt; Before each test begins, XCTest calls setUpWithError(), followed by setUp(). Override this method to reset state for each test method. If state preparation might throw errors, override setUpWithError(). &gt; &gt; ... &gt; &gt; After each test completes, XCTest calls tearDown(), followed by tearDownWithError(). Override this method to perform any per-test cleanup.</p></blockquote><pre><code><span class="keyword">class</span> ViewTests : <span class="type">XCTestCase</span> {
  
  <span class="keyword">var</span> sut: <span class="type">View</span>!
  
  <span class="keyword">override func</span> setUp() {
    sut = <span class="type">View</span>()
  }
  
  <span class="keyword">override func</span> tearDown() {
    sut = <span class="keyword">nil</span>
  }
  
  <span class="keyword">func</span> test_labelIsSubview() {
    <span class="comment">// then</span>
    <span class="call">XCTAssertTrue</span>(sut.<span class="property">label</span>.<span class="call">isDescendant</span>(of: sut))
  }
}
</code></pre><h2>Example code that makes the test pass</h2><pre><code><span class="keyword">class</span> View : <span class="type">UIView</span> {
  
  <span class="keyword">let</span> label: <span class="type">UILabel</span>
  
  <span class="keyword">override init</span>(frame: <span class="type">CGRect</span>) {
    label = <span class="type">UILabel</span>()
    
    <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)
    
    <span class="call">addSubview</span>(label)
  }
  
  <span class="keyword">required init</span>?(coder aDecoder: <span class="type">NSCoder</span>) { <span class="call">fatalError</span>() }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/general/chapter010</guid><title>class func setUp() and class func tearDown()</title><description></description><link>https://gimmetheco.de/general/chapter010</link><pubDate>Fri, 16 Oct 2020 00:10:00 +0200</pubDate><content:encoded><![CDATA[<h1><code>class func setUp()</code> and <code>class func tearDown()</code></h1><blockquote><p><strong>Apple docs:</strong> &gt; &gt; The setUp() class method is called exactly once for a test case, before its first test method is called. Override this method to customize the initial state for all tests in the test case. &gt; &gt; ... &gt; &gt; The tearDown() class method is called exactly once for a test case, after its final test method completes. Override this method to perform any cleanup after all test methods have ended.</p></blockquote><pre><code><span class="keyword">class</span> FooTests : <span class="type">XCTestCase</span> {
  
  <span class="keyword">static var</span> dateFormatter: <span class="type">DateFormatter</span>!
  
  <span class="keyword">override class func</span> setUp() {
    dateFormatter = <span class="type">DateFormatter</span>()
    dateFormatter.<span class="property">dateFormat</span> = <span class="string">"yyyy-MM-dd"</span>
  }
  
  <span class="keyword">override class func</span> tearDown() {
    dateFormatter = <span class="keyword">nil</span>
  }
  
  <span class="keyword">func</span> test_date() {
    <span class="comment">// given</span>
    <span class="keyword">let</span> dateString = <span class="string">"2019-03-01"</span>
    <span class="keyword">let</span> date = <span class="type">FooTests</span>.<span class="property">dateFormatter</span>.<span class="call">date</span>(from: dateString)!
    
    <span class="comment">// when</span>
    <span class="keyword">let</span> result = <span class="type">Foo</span>(date: date)
    
    <span class="comment">// then</span>
    <span class="call">XCTAssertEqual</span>(result.<span class="property">dateString</span>, dateString)
  }
}
</code></pre><h2>Example code that makes the test pass</h2><pre><code><span class="keyword">struct</span> Foo {
  <span class="keyword">let</span> dateString: <span class="type">String</span>
  
  <span class="keyword">init</span>(date: <span class="type">Date</span>) {
    <span class="keyword">let</span> dateFormatter = <span class="type">DateFormatter</span>()
    dateFormatter.<span class="property">dateFormat</span> = <span class="string">"yyyy-MM-dd"</span>
    
    dateString = dateFormatter.<span class="call">string</span>(from: date)
  }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/general/chapter008</guid><title>Custom Test Assertions</title><description>You can define your own custom assertions. Let's say we have a test that compares two dictionaries.</description><link>https://gimmetheco.de/general/chapter008</link><pubDate>Fri, 16 Oct 2020 00:08:00 +0200</pubDate><content:encoded><![CDATA[<h1>Custom Test Assertions</h1><p>You can define your own custom assertions. Let's say we have a test that compares two dictionaries.</p><pre><code>   <span class="keyword">func</span> test_dictsAreQual() {
    <span class="keyword">let</span> dict1 = [<span class="string">"id"</span>: <span class="string">"2"</span>, <span class="string">"name"</span>: <span class="string">"foo"</span>]
    <span class="keyword">let</span> dict2 = [<span class="string">"id"</span>: <span class="string">"2"</span>, <span class="string">"name"</span>: <span class="string">"fo"</span>]
    
    <span class="call">XCTAssertEqual</span>(dict1, dict2)
  }
</code></pre><p>In this case, the test output is this:</p><pre><code>XCTAssertEqual failed: (<span class="string">"["id": "2", "name": "foo"]"</span>) <span class="keyword">is</span> not equal to (<span class="string">"["id": "2", "name": "fo"]"</span>) -
</code></pre><p>In this case it's easy see, what is different in the two dictionaries but what if you try to compare two dictionaries with hundreds of entries? Won't work. To improve the output, we can define a custom assertion method.</p><pre><code><span class="keyword">extension</span> <span class="type">Dictionary</span> <span class="keyword">where</span> <span class="type">Key</span>: <span class="type">Hashable</span>, <span class="type">Value</span>: <span class="type">Equatable</span> {
  
  <span class="keyword">func</span> assertEqual(to otherDict: [<span class="type">Key</span> : <span class="type">Value</span>], file: <span class="type">StaticString</span> = file, line: <span class="type">UInt</span> = <span class="keyword">#line</span>) {
    
    <span class="keyword">for</span> key <span class="keyword">in</span> keys {
      
      <span class="keyword">let</span> value1 = <span class="type">String</span>(describing: <span class="keyword">self</span>[key])
      <span class="keyword">let</span> value2 = <span class="type">String</span>(describing: otherDict[key])
      <span class="keyword">let</span> keyValue1 = <span class="string">"\"</span>\(key)<span class="string">\":</span> \(value1)<span class="string">"</span>
      <span class="keyword">let</span> keyValue2 = <span class="string">"\"</span>\(key)<span class="string">\":</span> \(value2)<span class="string">"</span>
      <span class="keyword">let</span> message = <span class="string">"""</span>
      \(keyValue1<span class="string">) is not equal to</span> \(keyValue2)
      <span class="string">"""</span>
      
      <span class="call">XCTAssertTrue</span>(<span class="keyword">self</span>[key] == otherDict[key], message, file: file, line: line)
    }
  }
}
</code></pre><p>With this extension, the test becomes:</p><pre><code>   <span class="keyword">func</span> test_dictsAreQual2() {
    <span class="keyword">let</span> dict1 = [<span class="string">"id"</span>: <span class="string">"2"</span>, <span class="string">"name"</span>: <span class="string">"foo"</span>]
    <span class="keyword">let</span> dict2 = [<span class="string">"id"</span>: <span class="string">"2"</span>, <span class="string">"name"</span>: <span class="string">"fo"</span>]
    
    dict1.<span class="call">assertEqual</span>(to: dict2)
  }
</code></pre><p>And the output becomes:</p><pre><code>XCTAssertTrue failed - <span class="string">"name"</span>: <span class="type">Optional</span>(<span class="string">"foo"</span>) <span class="keyword">is</span> not equal to <span class="string">"name"</span>: <span class="type">Optional</span>(<span class="string">"fo"</span>)
</code></pre><h3><code>#file</code> and <code>#line</code></h3><p>With the help of the parameter <code>file</code> and <code>line</code> in the custom assertions and the default values <code>#file</code> and <code>#line</code>, Xcode prints the assertion at the line where the assertion method is called. When we ommit those parameter the failure is reported in the line where the actual XCTAssert... call is located. That would not be helpful.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/general/chapter007</guid><title>XCTAssert Functions</title><description>There are many different assert methods to be used in a test. When in doubt always choose the one with the most helpful output. To be able to choose wise, you need to learn what all the assert methods do.</description><link>https://gimmetheco.de/general/chapter007</link><pubDate>Fri, 16 Oct 2020 00:07:00 +0200</pubDate><content:encoded><![CDATA[<h1>XCTAssert Functions</h1><p>There are many different assert methods to be used in a test. When in doubt always choose the one with the most helpful output. To be able to choose wise, you need to learn what all the assert methods do.</p><h2>XCTAssert(_:)</h2><pre><code>   <span class="call">XCTAssert</span>(<span class="number">1</span>==<span class="number">2</span>)
</code></pre><p>Assert that an expression is true. Output:</p><pre><code>XCTAssertTrue failed -
</code></pre><h3>Declaration</h3><pre><code><span class="keyword">public func</span> XCTAssert(<span class="keyword">_</span> expression: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">Bool</span>,
                      <span class="keyword">_</span> message: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span> = <span class="keyword">default</span>,
                      file: <span class="type">StaticString</span> = <span class="keyword">#file</span>,
                      line: <span class="type">UInt</span> = <span class="keyword">#line</span>)
</code></pre><h2>XCTAssertEqual(_:_:)</h2><pre><code>   <span class="call">XCTAssertEqual</span>(<span class="number">1</span>, <span class="number">2</span>)
</code></pre><p>Assert that two expressions are equal. Both expressions need to be of the same type and this type needs to confom to <code>Equatable</code>. One or both expressions can return optional values. The method uses the <code>==</code> operator to check for equality. You should not use this method to check floating point values (<code>Float</code>, <code>Double</code>, ...) for equality. For floating point values use <a href="#xctassertequal_with_accuracy">XCTAssertEqual(_:_:accuracy:)</a>. Output:</p><pre><code>XCTAssertEqual failed: (<span class="string">"1"</span>) <span class="keyword">is</span> not equal to (<span class="string">"2"</span>) -
</code></pre><h3>Declaration</h3><pre><code><span class="keyword">public func</span> XCTAssertEqual&lt;T&gt;(<span class="keyword">_</span> expression1: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                              <span class="keyword">_</span> expression2: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                              <span class="keyword">_</span> message: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span> = <span class="keyword">default</span>,
                              file: <span class="type">StaticString</span> = <span class="keyword">#file</span>,
                              line: <span class="type">UInt</span> = <span class="keyword">#line</span>) <span class="keyword">where</span> <span class="type">T</span> : <span class="type">Equatable</span>
</code></pre><h2>XCTAssertEqual(_:_:accuracy:) {#xctassertequal<em>with</em>accuracy}</h2><pre><code>   <span class="call">XCTAssertEqual</span>(<span class="number">1.01</span>, <span class="number">1.03</span>, accuracy: <span class="number">0.01</span>)
</code></pre><p>Assert that two expressions are equal within the accuracy. Both expressions and the value for accuracy need to be of the same type and this type needs to confom to <code>FloatingPoint</code>. Use this method to check floating point values (<code>Float</code>, <code>Double</code>, ...) for equality. Output:</p><pre><code>XCTAssertEqualWithAccuracy failed: (<span class="string">"1.01"</span>) <span class="keyword">is</span> not equal to (<span class="string">"1.03"</span>) +/- (<span class="string">"0.01"</span>) -
</code></pre><h3>Declaration</h3><pre><code><span class="keyword">public func</span> XCTAssertEqual&lt;T&gt;(<span class="keyword">_</span> expression1: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                              <span class="keyword">_</span> expression2: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                              accuracy: <span class="type">T</span>,
                              <span class="keyword">_</span> message: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span> = <span class="keyword">default</span>,
                              file: <span class="type">StaticString</span> = <span class="keyword">#file</span>,
                              line: <span class="type">UInt</span> = <span class="keyword">#line</span>) <span class="keyword">where</span> <span class="type">T</span> : <span class="type">FloatingPoint</span>
</code></pre><h2>XCTAssertNotEqual(_:_:)</h2><pre><code>   <span class="call">XCTAssertNotEqual</span>(<span class="number">1</span>, <span class="number">1</span>)
</code></pre><p>Assert that two expressions are not equal. Both expressions need to be of the same type and this type needs to confom to <code>Equatable</code>. One or both expressions can return optional values. The method uses the <code>==</code> operator to check for equality. You should not use this method to check floating point values (<code>Float</code>, <code>Double</code>, ...) for equality. For floating point values use <a href="#xctassertnotequal_with_accuracy">XCTAssertNotEqual(_:_:accuracy:)</a>. Output:</p><pre><code>XCTAssertNotEqual failed: (<span class="string">"1"</span>) <span class="keyword">is</span> equal to (<span class="string">"1"</span>) -
</code></pre><h3>Declaration</h3><pre><code><span class="keyword">public func</span> XCTAssertNotEqual&lt;T&gt;(<span class="keyword">_</span> expression1: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                                 <span class="keyword">_</span> expression2: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                                 <span class="keyword">_</span> message: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span> = <span class="keyword">default</span>,
                                 file: <span class="type">StaticString</span> = <span class="keyword">#file</span>,
                                 line: <span class="type">UInt</span> = <span class="keyword">#line</span>) <span class="keyword">where</span> <span class="type">T</span> : <span class="type">Equatable</span>
</code></pre><h2>XCTAssertNotEqual(_:_:accuracy:) {#xctassertnotequal<em>with</em>accuracy}</h2><pre><code>   <span class="call">XCTAssertNotEqual</span>(<span class="number">1.01</span>, <span class="number">1.02</span>, accuracy: <span class="number">0.02</span>)
</code></pre><p>Assert that two expressions are not equal within the accuracy. Both expressions and the value for accuracy need to be of the same type and this type needs to confom to <code>FloatingPoint</code>. Use this method to check floating point values (<code>Float</code>, <code>Double</code>, ...) for equality. Output: <code></code>`swift XCTAssertNotEqualWithAccuracy failed: ("1.01") is equal to ("1.02") +/- ("0.02") - <code></code>`</p><h3>Declaration</h3><pre><code><span class="keyword">public func</span> XCTAssertNotEqual&lt;T&gt;(<span class="keyword">_</span> expression1: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                                 <span class="keyword">_</span> expression2: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                                 accuracy: <span class="type">T</span>,
                                 <span class="keyword">_</span> message: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span> = <span class="keyword">default</span>,
                                 file: <span class="type">StaticString</span> =<span class="keyword">#file</span>,
                                 line: <span class="type">UInt</span> =<span class="keyword">#line</span>) <span class="keyword">where</span> <span class="type">T</span> : <span class="type">FloatingPoint</span>
</code></pre><h2>XCTAssertGreaterThan(_:_:)</h2><pre><code>   <span class="call">XCTAssertGreaterThan</span>(<span class="number">1</span>, <span class="number">1</span>)
</code></pre><p>Assert that an expression is greater than an other expression. Both expressions need to be of the same type and this type needs to confom to <code>Comparable</code>. Output:</p><pre><code>XCTAssertGreaterThan failed: (<span class="string">"1"</span>) <span class="keyword">is</span> not greater than (<span class="string">"1"</span>) -
</code></pre><h3>Declaration</h3><pre><code><span class="keyword">public func</span> XCTAssertGreaterThan&lt;T&gt;(<span class="keyword">_</span> expression1: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                                    <span class="keyword">_</span> expression2: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                                    <span class="keyword">_</span> message: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span> = <span class="keyword">default</span>,
                                    file: <span class="type">StaticString</span> = <span class="keyword">#file</span>,
                                    line: <span class="type">UInt</span> = <span class="keyword">#line</span>) <span class="keyword">where</span> <span class="type">T</span> : <span class="type">Comparable</span>
</code></pre><h2>XCTAssertGreaterThanOrEqual(_:_:)</h2><pre><code>   <span class="call">XCTAssertGreaterThanOrEqual</span>(<span class="number">1</span>, <span class="number">1.01</span>)
</code></pre><p>Assert that an expression is greater than or equal to an other expression. Both expressions need to be of the same type and this type needs to confom to <code>Comparable</code>. Output:</p><pre><code>XCTAssertGreaterThanOrEqual failed: (<span class="string">"1.0"</span>) <span class="keyword">is</span> less than (<span class="string">"1.01"</span>) -
</code></pre><h3>Declaration</h3><pre><code><span class="keyword">public func</span> XCTAssertGreaterThanOrEqual&lt;T&gt;(<span class="keyword">_</span> expression1: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                                           <span class="keyword">_</span> expression2: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                                           <span class="keyword">_</span> message: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span> = <span class="keyword">default</span>,
                                           file: <span class="type">StaticString</span> = <span class="keyword">#file</span>,
                                           line: <span class="type">UInt</span> = <span class="keyword">#line</span>) <span class="keyword">where</span> <span class="type">T</span> : <span class="type">Comparable</span>
</code></pre><h2>XCTAssertLessThan(_:_:)</h2><pre><code>   <span class="call">XCTAssertLessThan</span>(<span class="number">1</span>,<span class="number">1</span>)
</code></pre><p>Assert that an expression is less than an other expression. Both expressions need to be of the same type and this type needs to confom to <code>Comparable</code>. Output:</p><pre><code>XCTAssertLessThan failed: (<span class="string">"1"</span>) <span class="keyword">is</span> not less than (<span class="string">"1"</span>) -
</code></pre><h3>Declaration</h3><pre><code><span class="keyword">public func</span> XCTAssertLessThan&lt;T&gt;(<span class="keyword">_</span> expression1: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                                 <span class="keyword">_</span> expression2: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                                 <span class="keyword">_</span> message: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span> = <span class="keyword">default</span>,
                                 file: <span class="type">StaticString</span> = <span class="keyword">#file</span>,
                                 line: <span class="type">UInt</span> = <span class="keyword">#line</span>) <span class="keyword">where</span> <span class="type">T</span> : <span class="type">Comparable</span>
</code></pre><h2>XCTAssertLessThanOrEqual(_:_:)</h2><pre><code>   <span class="call">XCTAssertLessThanOrEqual</span>(<span class="number">1.01</span>,<span class="number">1</span>)
</code></pre><p>Assert that an expression is less than or equal to an other expression. Both expressions need to be of the same type and this type needs to confom to <code>Comparable</code>. Output:</p><pre><code>XCTAssertLessThanOrEqual failed: (<span class="string">"1.01"</span>) <span class="keyword">is</span> greater than (<span class="string">"1.0"</span>) -
</code></pre><h3>Declaration</h3><pre><code><span class="keyword">public func</span> XCTAssertLessThanOrEqual&lt;T&gt;(<span class="keyword">_</span> expression1: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                                        <span class="keyword">_</span> expression2: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                                        <span class="keyword">_</span> message: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span> = <span class="keyword">default</span>,
                                        file: <span class="type">StaticString</span> = <span class="keyword">#file</span>,
                                        line: <span class="type">UInt</span> = <span class="keyword">#line</span>) <span class="keyword">where</span> <span class="type">T</span> : <span class="type">Comparable</span>
</code></pre><h2>XCTAssertNil(_:)</h2><pre><code>   <span class="call">XCTAssertNil</span>(<span class="number">1</span>)
</code></pre><p>Assert that an expression is nil. Output:</p><pre><code>XCTAssertNil failed: <span class="string">"1"</span> -
</code></pre><h3>Declaration</h3><pre><code><span class="keyword">public func</span> XCTAssertNil(<span class="keyword">_</span> expression: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">Any</span>?,
                         <span class="keyword">_</span> message: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span> = <span class="keyword">default</span>,
                         file: <span class="type">StaticString</span> = <span class="keyword">#file</span>,
                         line: <span class="type">UInt</span> = <span class="keyword">#line</span>)
</code></pre><h2>XCTAssertNotNil(_:)</h2><pre><code>   <span class="call">XCTAssertNotNil</span>(<span class="keyword">nil</span>)
</code></pre><p>Assert that an expression is not nil. Output:</p><pre><code>XCTAssertNotNil failed -
</code></pre><h3>Declaration</h3><pre><code><span class="keyword">public func</span> XCTAssertNotNil(<span class="keyword">_</span> expression: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">Any</span>?,
                            <span class="keyword">_</span> message: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span> = <span class="keyword">default</span>,
                            file: <span class="type">StaticString</span> = <span class="keyword">#file</span>,
                            line: <span class="type">UInt</span> = <span class="keyword">#line</span>)
</code></pre><h2>XCTAssertThrowsError(_:)</h2><pre><code>   <span class="call">XCTAssertThrowsError</span>(<span class="keyword">try</span> <span class="call">notThrowing</span>())
</code></pre><p>Assert that an expression does throw an error. Output:</p><pre><code>XCTAssertThrowsError failed: did not <span class="keyword">throw</span> an error -
</code></pre><h3>Declaration</h3><pre><code><span class="keyword">public func</span> XCTAssertThrowsError&lt;T&gt;(<span class="keyword">_</span> expression: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                                    <span class="keyword">_</span> message: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span> = <span class="keyword">default</span>,
                                    file: <span class="type">StaticString</span> = <span class="keyword">#file</span>,
                                    line: <span class="type">UInt</span> = <span class="keyword">#line</span>,
                                    <span class="keyword">_</span> errorHandler: (<span class="type">Error</span>) -&gt; <span class="type">Void</span> = <span class="keyword">default</span>)
</code></pre><h2>XCTAssertNoThrow(_:)</h2><pre><code>   <span class="call">XCTAssertNoThrow</span>(<span class="keyword">try</span> <span class="call">throwing</span>())
</code></pre><p>Assert that an expression does not throw an error. Output:</p><pre><code>XCTAssertNoThrow failed: threw error <span class="string">"Error Domain=Dummy error Code=42 "</span>(null)<span class="string">""</span> -
</code></pre><h3>Declaration</h3><pre><code><span class="keyword">public func</span> XCTAssertNoThrow&lt;T&gt;(<span class="keyword">_</span> expression: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">T</span>,
                                <span class="keyword">_</span> message: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span> = <span class="keyword">default</span>,
                                file: <span class="type">StaticString</span> = <span class="keyword">#file</span>,
                                line: <span class="type">UInt</span> = <span class="keyword">#line</span>)
</code></pre><h2>XCTAssertTrue(_:)</h2><pre><code>   <span class="call">XCTAssertTrue</span>(<span class="number">1</span>==<span class="number">2</span>)
</code></pre><p>Assert that an expression is true. Output:</p><pre><code>XCTAssertTrue failed -
</code></pre><h3>Declaration</h3><pre><code><span class="keyword">public func</span> XCTAssertTrue(<span class="keyword">_</span> expression: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">Bool</span>,
                          <span class="keyword">_</span> message: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span> = <span class="keyword">default</span>,
                          file: <span class="type">StaticString</span> = <span class="keyword">#file</span>,
                          line: <span class="type">UInt</span> = <span class="keyword">#line</span>)
</code></pre><h2>XCTAssertFalse(_:)</h2><pre><code>   <span class="call">XCTAssertFalse</span>(<span class="number">1</span>==<span class="number">1</span>)
</code></pre><p>Assert that an expression is false. Output:</p><pre><code>XCTAssertFalse failed -
</code></pre><h3>Declaration</h3><pre><code><span class="keyword">public func</span> XCTAssertFalse(<span class="keyword">_</span> expression: <span class="keyword">@autoclosure</span> () <span class="keyword">throws</span> -&gt; <span class="type">Bool</span>,
                           <span class="keyword">_</span> message: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">String</span> = <span class="keyword">default</span>,
                           file: <span class="type">StaticString</span> = <span class="keyword">#file</span>,
                           line: <span class="type">UInt</span> = <span class="keyword">#line</span>)
</code></pre><h2>XCTFail()</h2><pre><code>   <span class="type">XCTFail</span>()
</code></pre><p>Fails the test. Output:</p><pre><code>failed -
</code></pre><h3>Declaration</h3><pre><code><span class="keyword">public func</span> XCTFail(<span class="keyword">_</span> message: <span class="type">String</span> = <span class="keyword">default</span>,
                   file: <span class="type">StaticString</span> = <span class="keyword">#file</span>,
                   line: <span class="type">UInt</span> = <span class="keyword">#line</span>)
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/general/chapter006</guid><title>Xcode Behaviors</title><description>With behaviors you can tell Xcode what to do when things happen.</description><link>https://gimmetheco.de/general/chapter006</link><pubDate>Fri, 16 Oct 2020 00:06:00 +0200</pubDate><content:encoded><![CDATA[<h1>Xcode Behaviors</h1><p>With behaviors you can tell Xcode what to do when things happen. <img src="../../images/xcode_behaviors_1.png" alt="Behavior window with my behavior for when testing starts"/> On the left side you can activate various different triggers like 'Build Starts', 'Test Fails', and 'Search Completes with result'. The behaviors are roughly devided in three parts. 1. Attention (like 'Play sound') 1. Navigation (like 'Show tab named') 1. Run a script As inspiration, here is the behavior I set up for when the test fails: <img src="../../images/xcode_behaviors_2.png"/> Play a sound 'Funk' : Often compiling and running the tests takes to long to keep watching and waiting. So most of the times I do something different in that time like grap three balls and do some juggling or read again the ticket I'm working on. So I need to be notified when the test finishes. This behavior does exalty that. I have different sounds for succeeding and failing tests. Notify using bezel or system notification : Same as above. I like to have a visual notification when the tests are finished and what the result is. Show tab named 🤓 : The tab with the 'name' 🤓 is my programming tab. In TDD a failing test means I need to write code to make the test pass. So I switch to the programming tab. Show test navigator : When the test fails I'd like to see an overview over all tests to see which tests failed.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/general/chapter005</guid><title>Xcode Menu Items For Testing</title><description></description><link>https://gimmetheco.de/general/chapter005</link><pubDate>Fri, 16 Oct 2020 00:05:00 +0200</pubDate><content:encoded><![CDATA[<h1>Xcode Menu Items For Testing</h1><h2>Test (⌘U)</h2><p>Runs all active tests for the currently selected scheme.</p><p><strong>Menu item:</strong> <code>Product &gt; Test</code></p><p><strong>Shortcut:</strong> ⌘U</p><h2>Show Test Navigator (⌘6)</h2><p>The test navigator shows an overview of all test in the project.</p><p><strong>Menu item:</strong> <code>View &gt; Navigator &gt; Show Test Navigator</code></p><p><strong>Shortcut:</strong> ⌘6</p><img src="../../images/test_navigator.png"/><p>On the right is a symbol that shows the result of the test. If you hover over that symbol it changes to a play icon. This means if you click that icon, Xcode runs jurst this one test. The same way you can run all tests in one test case when you click at that possition next to the test case name.</p><h2>Build For Testing (⇧⌘U)</h2><p><strong>Menu item:</strong> <code>Product &gt; Build For &gt; Testing</code></p><p><strong>Shortcut:</strong> ⇧⌘U</p><h2>Test Without Building (⌃⌘U)</h2><p><strong>Menu item:</strong> <code>Product &gt; Perform Action &gt; Test Without Building</code></p><p><strong>Shortcut:</strong> ⌃⌘U</p><h2>Run Current Test (⌃⌥⌘U)</h2><p>Runs the test method, in which the cursor is currently located.</p><p><strong>Menu item:</strong> <code>Product &gt; Perform Action &gt; Test</code></p><p><strong>Shortcut:</strong> ⌃⌥⌘U</p><h2>Test Again (⌃⌥⌘G)</h2><p>Runs the last tests that have been run.</p><p><strong>Menu item:</strong> <code>Product &gt; Perform Action &gt; Test Again</code></p><p><strong>Shortcut:</strong> ⌃⌥⌘G</p><h2>Create Test Failure Breakpoint</h2><p><strong>Menu item:</strong> <code>Debug &gt; Breakpoints &gt; Create Test Failure Breakpoint</code></p>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/general/chapter003</guid><title>General</title><description>This book is not intended for beginners in Test-Driven Development. But if you are the kind of person who skips the text in blog posts to just read the important stuff (== the code) you might get enough information from this book to start writing valuable tests. This chapter sums up the essential information in case you are just starting with TDD.</description><link>https://gimmetheco.de/general/chapter003</link><pubDate>Fri, 16 Oct 2020 00:03:00 +0200</pubDate><content:encoded><![CDATA[<h1>General</h1><p>This book is not intended for beginners in Test-Driven Development. But if you are the kind of person who skips the text in blog posts to just read the important stuff (== the code) you might get enough information from this book to start writing valuable tests. This chapter sums up the essential information in case you are just starting with TDD.</p><h2>Add Test Target</h2><p>For the tests, you need at least one testing target in Xcode. In this target all the tests are collected. You can have more than one testing target but at the beginning one is enough. When you create a new project check the option 'Include Unit Tests' to add a testing target to your project. <img src="../../images/new_project_testing_target.png" alt="New project with testing target"/> To add a testing target to an existing target open the targets screen in Xcode and click the plus sign at the bottom of the screen. <img src="../../images/add_target.png" alt="Add target to existing project"/> <img src="../../images/add_testing_target.png" alt="Make the new target a testing target"/> When you add tests to the project, you need to add them to the testing target.</p><h2>Red-Green-Refactor</h2><h3>Red</h3><p>In Test-Driven Development you always start with a failing test. This means you write the test code before you write the code to be tested. As there is no code to be tested, this test will definitely fail. A failing test is often shown by some red information. In Xcode it's a red diamond with a white x. That's why this step is called Red.</p><h3>Green</h3><p>Next you write the code that is needed to make the test pass. Usually this information is shown in combination with the color green. In Xcode this is a green diamond with a white checkmark. This step is called Green. Following these steps you have shown that the code you have written is tested by the test code. Otherwise the test would not have changed from failing (red) to passing (green). This is one value of starting with the test. If you first write the code and then the test, a green test tells you nothing. It could be that the test is always green. Only by switching from red to green you know that the test can fail.</p><h3>Refactor</h3><p>The last step in the cycle is refactoring. Now that you have the test that is testing something you can refactor the code. This step is very important. Always check the code if it can be improved. The test is there to make sure you don't break anything while improving.</p><h2>Test Structure</h2><p>Usually a test case looks like this:</p><pre><code><span class="keyword">import</span> XCTest                   <span class="comment">// 1</span>
<span class="keyword">@testable import</span> MyModule       <span class="comment">// 2</span>
 
<span class="keyword">class</span> SomeTests : <span class="type">XCTestCase</span> {  <span class="comment">// 3</span>

  <span class="keyword">var</span> sut: <span class="type">SomeClass</span>!           <span class="comment">// 4</span>

  <span class="keyword">override func</span> setUpWithError() <span class="keyword">throws</span> {       <span class="comment">// 5</span>
    sut = <span class="type">SomeClass</span>()
  }

  <span class="keyword">override func</span> tearDownWithError() <span class="keyword">throws</span> {    <span class="comment">// 6</span>
    sut = <span class="keyword">nil</span>
  }

  <span class="keyword">func</span> test_name_property() {   <span class="comment">// 7
    // The test code</span>
  }
}
</code></pre><ol><li>Import XCTest: This is the testing framework provided by Apple<ol start="2"><li>Import the module (= target) you'd like to test: Using <code>@testable</code> the module is imported in a way that you can access the public and the internal properties and methods. Without this keyword you can only access the public information.</li><li>The test class is a subclass of <code>XCTestCase</code>.</li><li>Usually you have one 'thing' (class, struct, enum) to test per test class. This is often called <code>sut</code> which stands for system under test (see next section).</li><li>The instance method <code>setUpWithError()</code> is called before each test. Usually you put there the setup code needed for each test, like setting up the instance you'd like to test.</li><li>Use <code>tearDownWithError()</code> to clean up if needed. Usually you destroy the instance under test.</li><li>Test methods need to start with the prefix <code>test</code>. Otherwise the test runner doesn't find the test.</li></ol></li></ol><h2>sut: System Under Test</h2><p>When you read test code from other developers you'll often encounter the term 'sut'. 'sut' is short for 'system under test'. This is the name usually used as the name for the instance that is tested in a test case. There are several reasons why it's a good idea to use this name in tests: 1. Easier copy and paste 2. It's obvious what is tested and what is setup to be able to test 3. Easier to read than <code>loginViewController</code> and <code>networkingClient</code>.</p><h2>You Might Repeat yourself</h2><p>It's OK to not do DRY (Don't Repeat Yourself) in tests. The most important quality of a test is to be as readable and as quickly scannable as possible. This means if a test is easier to read when you copy and paste code from somewhere else, do it. Imagine you have 300k lines of code and more than 2000 tests and suddenly a test you wrote six month ago fails. You don't want to spent an hour on why the test fails. You don’t want to run the debugger to figure out what belongs to the test. Always try to write the test in a way that it is immediately clean what the test does. But this doesn't mean you should write bad code when writing tests. It's often a good idea to put code you use several times into a helper method. But keep in mind that the tests schould be readable first.</p><h2>Force-Unwrapping in Tests</h2><p>In good Swift code you seldom see values that are forcefully unwrapped. Each forced unwrapping is a potential crash. It's good practice to use the possibilities Swift provides to avoid potential crashes like <code>if let</code> and <code>guard let</code>. Test code is different. As mentioned above, test code has to be easy to read before everything else. That's why it's OK to use force unwrapping in test code. If the test crashes, it's just a test failure. A test failure tells you what did go wrong and what you have to do to fix it. Keep in mind that this is my opinion on this topic. There are many other opinios out there. You should try to use force-unwrapping in tests for a few days and then use <code>if let</code> and <code>guard let</code> for a few days and then figure out for youself what feels best for you.</p><h2>What To Test</h2><p>The easy and most useless answer is: &gt; Test everything that needs to work properly. If you strictly follow the rules of Test-Driven Development you are only allowed to write production code if you have a failing test. And you have to stop writing production code as soon as all tests pass. This way, in theory you have tests for all the code you write. In practice it's not that easy. And it becomes more difficult when you write some of the tests after you have written the code to be tested. So, what should be tested? The tests should give you confidence in the code and they should make refactoring easier. If you are in doubt, ask yourself if the test you are going to write would increase you confidence in the code. And always try to write the tests in a way that they are unlikely to break during refactoring of the code.</p><h2>What If Something Is Really Hard To Test</h2><p>Sometimes, especially when you try to add tests to code you wrote a few weeks ago, it's not obvious how to write tests. Often the reason is that the different parts of the code are too tightly coupled to each other. Sometimes the class you want to test does to much. Some people say, code that is not easy to test, is bad code. So how do you transform it to testable (good) code? There is not a general answer to this question. But it won't hurt to proceed in small steps. Maybe you can add a few UI tests that help to make sure that you don't break something while you refactor the code to make it testable via unit tests. If it's not possible to use UI tests, only change parts of the code that can be verified by hand in a few minutes. An example: Let's say we have an app that shows an info box at the first start after an update of the app. To distinguish the first start of the app from all the other starts the first view controller checks the version stored in the UserDefaults. If it's the first start, the version is updates in the UserDefaults. To test this, you need to be able to control the UserDefaults in your test. This is <em>the</em> standard use case for dependency injection. But this means you need to change the code to allow to inject that dependency. The changes needed to allow injecting the dependency could break this functionality. So you need to be extra careful in checking if this feature still works after you changed the code. This could mean to delete and reinstall the app several times until you get it right. But the effort pays off. After you have changed the code, you are able to control the circumstances of the start from the test. It could even happen, that this helps further down the live cycle of the app when requirements change and you need make changes to that part of the code. First you now have tests to ensure the feature does not break. Second injecting the dependency into that part of the code makes the code easier to change.</p><h2>Code That Is Easy To Test</h2><p>The easiest thing to test are pure functions. Pure functions are functions without any side effect. For example this function is a pure function:</p><pre><code><span class="keyword">func</span> add(a: <span class="type">Int</span>, b: <span class="type">Int</span>) -&gt; <span class="type">Int</span> {
  <span class="keyword">return</span> a + b
}
</code></pre><p>Often this results in the impression that one should only test model objects because it's easy to write pure functions when dealing with the model objects of an app. But you can and should test each and every aspect of you app. Sure, testing the behaviour of a view controller is not as straight forward as testing pure functions. But with a bit of practice you'll be able to write tests for each and every corner of you app. In general, code that's easy to test is: - focused (does only one thing) - can be controlled from outside (dependency injection) - is explicit (it's obvious what the code does; clever code isn't clever) - uses descriptive names But don't trust my words on this. There are many books about how to write good code. And good code is testable. :)</p>]]></content:encoded></item><item><guid isPermaLink="true">https://gimmetheco.de/introduction/chapter002</guid><title>Introduction</title><description>This website is a Gimme-The-Code website for iOS developers about Test-Driven Development. You cannot learn Test-Driven Development from this website. Use it to look up how to implement many test cases encountered in iOS development.</description><link>https://gimmetheco.de/introduction/chapter002</link><pubDate>Fri, 16 Oct 2020 00:02:00 +0200</pubDate><content:encoded><![CDATA[<h1>Introduction</h1><p>This website is a Gimme-The-Code website for iOS developers about Test-Driven Development. You cannot learn Test-Driven Development from this website. Use it to look up how to implement many test cases encountered in iOS development.</p><p>To make this as quick as possible, this website mainly contains the code you need to write the tests. You won't find any explanations why it is done this way on this website. If you want to know the why behind tests, search for books, search the internet, and read blog posts.</p><h1>This Website Is For You</h1><p>This website is for you if you</p><ul><li>already have a little bit experience with Test-Driven iOS Development</li><li>are the kind of person who skips the text in blog posts when searching for a solution of a problem</li><li>are looking for code examples for the most common testing scenarios in iOS development</li><li>know how to search the internet in case you need to know why the code in this website makes sense (or why it doesn't)</li></ul><h1>This Website Is Not For You</h1><p>This website is <strong>not</strong> for you if you are looking for</p><ul><li>an introduction to Unit-Tests</li><li>an introduction to Test-Driven iOS Development</li><li>an in depth discussion <strong>why</strong> tests are written like this</li></ul><h1>Storyboards vs Code</h1><p>It doesn't matter if you use Storyboards for you user interface or if you type it all in code. But user interfaces defined in code are a bit easier to test. The main difference is how you get an instance of the view controller you'd like to run your tests on. This section describes theses differences.</p><h2>Storyboards</h2><p>If your user interface is defined in a Storyboard, you first need to set a storyboard id for the scene you want to write tests for. Then in the test case you setup the system under test (which is the view controller connected to the scene) like this:</p><pre><code><span class="keyword">import</span> UIKit
<span class="keyword">import</span> XCTest

<span class="keyword">class</span> ProfileViewControllerTests : <span class="type">XCTestCase</span> {

  <span class="keyword">var</span> sut: <span class="type">ProfileViewController</span>!

  <span class="keyword">override func</span> setUpWithError() <span class="keyword">throws</span> {
    <span class="keyword">let</span> storyboard = <span class="type">UIStoryboard</span>(name: <span class="string">"Main"</span>, bundle: <span class="keyword">nil</span>)
    sut = storyboard.<span class="call">instantiateViewController</span>(withIdentifier: <span class="string">"ProfileViewController"</span>) <span class="keyword">as</span>! <span class="type">ProfileViewController</span>
  }

  <span class="keyword">override func</span> tearDownWithError() <span class="keyword">throws</span> {
    sut = <span class="keyword">nil</span>
  }
}
</code></pre><h2>User Interface In Code</h2><p>In case you've defined you user interface in code. You just need to call the initialiser of the view controller unter test.</p><pre><code><span class="keyword">import</span> UIKit
<span class="keyword">import</span> XCTest

<span class="keyword">class</span> ProfileViewControllerTests : <span class="type">XCTestCase</span> {

  <span class="keyword">var</span> sut: <span class="type">ProfileViewController</span>!

  <span class="keyword">override func</span> setUpWithError() <span class="keyword">throws</span> {
    sut = <span class="type">ProfileViewController</span>()
  }

  <span class="keyword">override func</span> tearDownWithError() <span class="keyword">throws</span> {
    sut = <span class="keyword">nil</span>
  }
}
</code></pre><h1>Thank You</h1><p>This book would have not been possible without the awesome iOS community. I have the privilege to be part of this community since 2009. Thank you all for sharing your knowledge and help each other to grow.</p><p>I'd like to thank especially a few people who helped me to do my first steps in Test Driven iOS Development:</p><ul><li><a href="https://twitter.com/iwasleeg">Graham Lee</a> for his awesome book about Test Driven iOS Development</li><li><a href="https://twitter.com/qcoding">Jon Reid</a> for helping me understand key concepts and giving me new input through his awesome blog</li><li><a href="https://twitter.com/joemasilotti">Joe Masilotti</a> for his UI Testing Cheat Sheet that helped me getting into UI Testing<ul></ul></li></ul><p>I hope this website helps some (or better many) people to get into TDD for iOS apps. I'd love to hear from you if you find this book helpful.</p>]]></content:encoded></item></channel></rss>